
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Property
 * 
 */
export type Property = $Result.DefaultSelection<Prisma.$PropertyPayload>
/**
 * Model SourceRecord
 * 
 */
export type SourceRecord = $Result.DefaultSelection<Prisma.$SourceRecordPayload>
/**
 * Model OwnershipEvent
 * 
 */
export type OwnershipEvent = $Result.DefaultSelection<Prisma.$OwnershipEventPayload>
/**
 * Model Sale
 * 
 */
export type Sale = $Result.DefaultSelection<Prisma.$SalePayload>
/**
 * Model Permit
 * 
 */
export type Permit = $Result.DefaultSelection<Prisma.$PermitPayload>
/**
 * Model ContractorCompany
 * 
 */
export type ContractorCompany = $Result.DefaultSelection<Prisma.$ContractorCompanyPayload>
/**
 * Model WorkEvent
 * 
 */
export type WorkEvent = $Result.DefaultSelection<Prisma.$WorkEventPayload>
/**
 * Model RentalSignal
 * 
 */
export type RentalSignal = $Result.DefaultSelection<Prisma.$RentalSignalPayload>
/**
 * Model InsuranceClaim
 * 
 */
export type InsuranceClaim = $Result.DefaultSelection<Prisma.$InsuranceClaimPayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model NotificationSubscription
 * 
 */
export type NotificationSubscription = $Result.DefaultSelection<Prisma.$NotificationSubscriptionPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Properties
 * const properties = await prisma.property.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Properties
   * const properties = await prisma.property.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.property`: Exposes CRUD operations for the **Property** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Properties
    * const properties = await prisma.property.findMany()
    * ```
    */
  get property(): Prisma.PropertyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sourceRecord`: Exposes CRUD operations for the **SourceRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SourceRecords
    * const sourceRecords = await prisma.sourceRecord.findMany()
    * ```
    */
  get sourceRecord(): Prisma.SourceRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ownershipEvent`: Exposes CRUD operations for the **OwnershipEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OwnershipEvents
    * const ownershipEvents = await prisma.ownershipEvent.findMany()
    * ```
    */
  get ownershipEvent(): Prisma.OwnershipEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sale`: Exposes CRUD operations for the **Sale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sales
    * const sales = await prisma.sale.findMany()
    * ```
    */
  get sale(): Prisma.SaleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permit`: Exposes CRUD operations for the **Permit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permits
    * const permits = await prisma.permit.findMany()
    * ```
    */
  get permit(): Prisma.PermitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contractorCompany`: Exposes CRUD operations for the **ContractorCompany** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContractorCompanies
    * const contractorCompanies = await prisma.contractorCompany.findMany()
    * ```
    */
  get contractorCompany(): Prisma.ContractorCompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workEvent`: Exposes CRUD operations for the **WorkEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkEvents
    * const workEvents = await prisma.workEvent.findMany()
    * ```
    */
  get workEvent(): Prisma.WorkEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rentalSignal`: Exposes CRUD operations for the **RentalSignal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RentalSignals
    * const rentalSignals = await prisma.rentalSignal.findMany()
    * ```
    */
  get rentalSignal(): Prisma.RentalSignalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.insuranceClaim`: Exposes CRUD operations for the **InsuranceClaim** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InsuranceClaims
    * const insuranceClaims = await prisma.insuranceClaim.findMany()
    * ```
    */
  get insuranceClaim(): Prisma.InsuranceClaimDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationSubscription`: Exposes CRUD operations for the **NotificationSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationSubscriptions
    * const notificationSubscriptions = await prisma.notificationSubscription.findMany()
    * ```
    */
  get notificationSubscription(): Prisma.NotificationSubscriptionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Property: 'Property',
    SourceRecord: 'SourceRecord',
    OwnershipEvent: 'OwnershipEvent',
    Sale: 'Sale',
    Permit: 'Permit',
    ContractorCompany: 'ContractorCompany',
    WorkEvent: 'WorkEvent',
    RentalSignal: 'RentalSignal',
    InsuranceClaim: 'InsuranceClaim',
    Report: 'Report',
    User: 'User',
    NotificationSubscription: 'NotificationSubscription'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "property" | "sourceRecord" | "ownershipEvent" | "sale" | "permit" | "contractorCompany" | "workEvent" | "rentalSignal" | "insuranceClaim" | "report" | "user" | "notificationSubscription"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Property: {
        payload: Prisma.$PropertyPayload<ExtArgs>
        fields: Prisma.PropertyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findFirst: {
            args: Prisma.PropertyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findMany: {
            args: Prisma.PropertyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          create: {
            args: Prisma.PropertyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          createMany: {
            args: Prisma.PropertyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          delete: {
            args: Prisma.PropertyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          update: {
            args: Prisma.PropertyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          deleteMany: {
            args: Prisma.PropertyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          upsert: {
            args: Prisma.PropertyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          aggregate: {
            args: Prisma.PropertyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProperty>
          }
          groupBy: {
            args: Prisma.PropertyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyCountAggregateOutputType> | number
          }
        }
      }
      SourceRecord: {
        payload: Prisma.$SourceRecordPayload<ExtArgs>
        fields: Prisma.SourceRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SourceRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SourceRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceRecordPayload>
          }
          findFirst: {
            args: Prisma.SourceRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SourceRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceRecordPayload>
          }
          findMany: {
            args: Prisma.SourceRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceRecordPayload>[]
          }
          create: {
            args: Prisma.SourceRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceRecordPayload>
          }
          createMany: {
            args: Prisma.SourceRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SourceRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceRecordPayload>[]
          }
          delete: {
            args: Prisma.SourceRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceRecordPayload>
          }
          update: {
            args: Prisma.SourceRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceRecordPayload>
          }
          deleteMany: {
            args: Prisma.SourceRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SourceRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SourceRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceRecordPayload>[]
          }
          upsert: {
            args: Prisma.SourceRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SourceRecordPayload>
          }
          aggregate: {
            args: Prisma.SourceRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSourceRecord>
          }
          groupBy: {
            args: Prisma.SourceRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<SourceRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.SourceRecordCountArgs<ExtArgs>
            result: $Utils.Optional<SourceRecordCountAggregateOutputType> | number
          }
        }
      }
      OwnershipEvent: {
        payload: Prisma.$OwnershipEventPayload<ExtArgs>
        fields: Prisma.OwnershipEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OwnershipEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnershipEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OwnershipEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnershipEventPayload>
          }
          findFirst: {
            args: Prisma.OwnershipEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnershipEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OwnershipEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnershipEventPayload>
          }
          findMany: {
            args: Prisma.OwnershipEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnershipEventPayload>[]
          }
          create: {
            args: Prisma.OwnershipEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnershipEventPayload>
          }
          createMany: {
            args: Prisma.OwnershipEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OwnershipEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnershipEventPayload>[]
          }
          delete: {
            args: Prisma.OwnershipEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnershipEventPayload>
          }
          update: {
            args: Prisma.OwnershipEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnershipEventPayload>
          }
          deleteMany: {
            args: Prisma.OwnershipEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OwnershipEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OwnershipEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnershipEventPayload>[]
          }
          upsert: {
            args: Prisma.OwnershipEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OwnershipEventPayload>
          }
          aggregate: {
            args: Prisma.OwnershipEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOwnershipEvent>
          }
          groupBy: {
            args: Prisma.OwnershipEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<OwnershipEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.OwnershipEventCountArgs<ExtArgs>
            result: $Utils.Optional<OwnershipEventCountAggregateOutputType> | number
          }
        }
      }
      Sale: {
        payload: Prisma.$SalePayload<ExtArgs>
        fields: Prisma.SaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          findFirst: {
            args: Prisma.SaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          findMany: {
            args: Prisma.SaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>[]
          }
          create: {
            args: Prisma.SaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          createMany: {
            args: Prisma.SaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>[]
          }
          delete: {
            args: Prisma.SaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          update: {
            args: Prisma.SaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          deleteMany: {
            args: Prisma.SaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SaleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>[]
          }
          upsert: {
            args: Prisma.SaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          aggregate: {
            args: Prisma.SaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSale>
          }
          groupBy: {
            args: Prisma.SaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleCountArgs<ExtArgs>
            result: $Utils.Optional<SaleCountAggregateOutputType> | number
          }
        }
      }
      Permit: {
        payload: Prisma.$PermitPayload<ExtArgs>
        fields: Prisma.PermitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermitPayload>
          }
          findFirst: {
            args: Prisma.PermitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermitPayload>
          }
          findMany: {
            args: Prisma.PermitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermitPayload>[]
          }
          create: {
            args: Prisma.PermitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermitPayload>
          }
          createMany: {
            args: Prisma.PermitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermitPayload>[]
          }
          delete: {
            args: Prisma.PermitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermitPayload>
          }
          update: {
            args: Prisma.PermitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermitPayload>
          }
          deleteMany: {
            args: Prisma.PermitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PermitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermitPayload>[]
          }
          upsert: {
            args: Prisma.PermitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermitPayload>
          }
          aggregate: {
            args: Prisma.PermitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermit>
          }
          groupBy: {
            args: Prisma.PermitGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermitGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermitCountArgs<ExtArgs>
            result: $Utils.Optional<PermitCountAggregateOutputType> | number
          }
        }
      }
      ContractorCompany: {
        payload: Prisma.$ContractorCompanyPayload<ExtArgs>
        fields: Prisma.ContractorCompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContractorCompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorCompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContractorCompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorCompanyPayload>
          }
          findFirst: {
            args: Prisma.ContractorCompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorCompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContractorCompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorCompanyPayload>
          }
          findMany: {
            args: Prisma.ContractorCompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorCompanyPayload>[]
          }
          create: {
            args: Prisma.ContractorCompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorCompanyPayload>
          }
          createMany: {
            args: Prisma.ContractorCompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContractorCompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorCompanyPayload>[]
          }
          delete: {
            args: Prisma.ContractorCompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorCompanyPayload>
          }
          update: {
            args: Prisma.ContractorCompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorCompanyPayload>
          }
          deleteMany: {
            args: Prisma.ContractorCompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContractorCompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContractorCompanyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorCompanyPayload>[]
          }
          upsert: {
            args: Prisma.ContractorCompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractorCompanyPayload>
          }
          aggregate: {
            args: Prisma.ContractorCompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContractorCompany>
          }
          groupBy: {
            args: Prisma.ContractorCompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContractorCompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContractorCompanyCountArgs<ExtArgs>
            result: $Utils.Optional<ContractorCompanyCountAggregateOutputType> | number
          }
        }
      }
      WorkEvent: {
        payload: Prisma.$WorkEventPayload<ExtArgs>
        fields: Prisma.WorkEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkEventPayload>
          }
          findFirst: {
            args: Prisma.WorkEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkEventPayload>
          }
          findMany: {
            args: Prisma.WorkEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkEventPayload>[]
          }
          create: {
            args: Prisma.WorkEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkEventPayload>
          }
          createMany: {
            args: Prisma.WorkEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkEventPayload>[]
          }
          delete: {
            args: Prisma.WorkEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkEventPayload>
          }
          update: {
            args: Prisma.WorkEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkEventPayload>
          }
          deleteMany: {
            args: Prisma.WorkEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkEventPayload>[]
          }
          upsert: {
            args: Prisma.WorkEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkEventPayload>
          }
          aggregate: {
            args: Prisma.WorkEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkEvent>
          }
          groupBy: {
            args: Prisma.WorkEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkEventCountArgs<ExtArgs>
            result: $Utils.Optional<WorkEventCountAggregateOutputType> | number
          }
        }
      }
      RentalSignal: {
        payload: Prisma.$RentalSignalPayload<ExtArgs>
        fields: Prisma.RentalSignalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RentalSignalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalSignalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RentalSignalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalSignalPayload>
          }
          findFirst: {
            args: Prisma.RentalSignalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalSignalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RentalSignalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalSignalPayload>
          }
          findMany: {
            args: Prisma.RentalSignalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalSignalPayload>[]
          }
          create: {
            args: Prisma.RentalSignalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalSignalPayload>
          }
          createMany: {
            args: Prisma.RentalSignalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RentalSignalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalSignalPayload>[]
          }
          delete: {
            args: Prisma.RentalSignalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalSignalPayload>
          }
          update: {
            args: Prisma.RentalSignalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalSignalPayload>
          }
          deleteMany: {
            args: Prisma.RentalSignalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RentalSignalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RentalSignalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalSignalPayload>[]
          }
          upsert: {
            args: Prisma.RentalSignalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RentalSignalPayload>
          }
          aggregate: {
            args: Prisma.RentalSignalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRentalSignal>
          }
          groupBy: {
            args: Prisma.RentalSignalGroupByArgs<ExtArgs>
            result: $Utils.Optional<RentalSignalGroupByOutputType>[]
          }
          count: {
            args: Prisma.RentalSignalCountArgs<ExtArgs>
            result: $Utils.Optional<RentalSignalCountAggregateOutputType> | number
          }
        }
      }
      InsuranceClaim: {
        payload: Prisma.$InsuranceClaimPayload<ExtArgs>
        fields: Prisma.InsuranceClaimFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InsuranceClaimFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceClaimPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InsuranceClaimFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceClaimPayload>
          }
          findFirst: {
            args: Prisma.InsuranceClaimFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceClaimPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InsuranceClaimFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceClaimPayload>
          }
          findMany: {
            args: Prisma.InsuranceClaimFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceClaimPayload>[]
          }
          create: {
            args: Prisma.InsuranceClaimCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceClaimPayload>
          }
          createMany: {
            args: Prisma.InsuranceClaimCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InsuranceClaimCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceClaimPayload>[]
          }
          delete: {
            args: Prisma.InsuranceClaimDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceClaimPayload>
          }
          update: {
            args: Prisma.InsuranceClaimUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceClaimPayload>
          }
          deleteMany: {
            args: Prisma.InsuranceClaimDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InsuranceClaimUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InsuranceClaimUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceClaimPayload>[]
          }
          upsert: {
            args: Prisma.InsuranceClaimUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceClaimPayload>
          }
          aggregate: {
            args: Prisma.InsuranceClaimAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInsuranceClaim>
          }
          groupBy: {
            args: Prisma.InsuranceClaimGroupByArgs<ExtArgs>
            result: $Utils.Optional<InsuranceClaimGroupByOutputType>[]
          }
          count: {
            args: Prisma.InsuranceClaimCountArgs<ExtArgs>
            result: $Utils.Optional<InsuranceClaimCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      NotificationSubscription: {
        payload: Prisma.$NotificationSubscriptionPayload<ExtArgs>
        fields: Prisma.NotificationSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.NotificationSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSubscriptionPayload>
          }
          findMany: {
            args: Prisma.NotificationSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSubscriptionPayload>[]
          }
          create: {
            args: Prisma.NotificationSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSubscriptionPayload>
          }
          createMany: {
            args: Prisma.NotificationSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.NotificationSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSubscriptionPayload>
          }
          update: {
            args: Prisma.NotificationSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.NotificationSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationSubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.NotificationSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.NotificationSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationSubscription>
          }
          groupBy: {
            args: Prisma.NotificationSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationSubscriptionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    property?: PropertyOmit
    sourceRecord?: SourceRecordOmit
    ownershipEvent?: OwnershipEventOmit
    sale?: SaleOmit
    permit?: PermitOmit
    contractorCompany?: ContractorCompanyOmit
    workEvent?: WorkEventOmit
    rentalSignal?: RentalSignalOmit
    insuranceClaim?: InsuranceClaimOmit
    report?: ReportOmit
    user?: UserOmit
    notificationSubscription?: NotificationSubscriptionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PropertyCountOutputType
   */

  export type PropertyCountOutputType = {
    sourceRecords: number
    ownershipEvents: number
    sales: number
    permits: number
    workEvents: number
    rentalSignals: number
    insuranceClaims: number
    reports: number
    notifications: number
  }

  export type PropertyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceRecords?: boolean | PropertyCountOutputTypeCountSourceRecordsArgs
    ownershipEvents?: boolean | PropertyCountOutputTypeCountOwnershipEventsArgs
    sales?: boolean | PropertyCountOutputTypeCountSalesArgs
    permits?: boolean | PropertyCountOutputTypeCountPermitsArgs
    workEvents?: boolean | PropertyCountOutputTypeCountWorkEventsArgs
    rentalSignals?: boolean | PropertyCountOutputTypeCountRentalSignalsArgs
    insuranceClaims?: boolean | PropertyCountOutputTypeCountInsuranceClaimsArgs
    reports?: boolean | PropertyCountOutputTypeCountReportsArgs
    notifications?: boolean | PropertyCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCountOutputType
     */
    select?: PropertyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountSourceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourceRecordWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountOwnershipEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnershipEventWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountPermitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermitWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountWorkEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkEventWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountRentalSignalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RentalSignalWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountInsuranceClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsuranceClaimWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationSubscriptionWhereInput
  }


  /**
   * Count Type ContractorCompanyCountOutputType
   */

  export type ContractorCompanyCountOutputType = {
    workEvents: number
    insuranceClaims: number
  }

  export type ContractorCompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workEvents?: boolean | ContractorCompanyCountOutputTypeCountWorkEventsArgs
    insuranceClaims?: boolean | ContractorCompanyCountOutputTypeCountInsuranceClaimsArgs
  }

  // Custom InputTypes
  /**
   * ContractorCompanyCountOutputType without action
   */
  export type ContractorCompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorCompanyCountOutputType
     */
    select?: ContractorCompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContractorCompanyCountOutputType without action
   */
  export type ContractorCompanyCountOutputTypeCountWorkEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkEventWhereInput
  }

  /**
   * ContractorCompanyCountOutputType without action
   */
  export type ContractorCompanyCountOutputTypeCountInsuranceClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsuranceClaimWhereInput
  }


  /**
   * Count Type InsuranceClaimCountOutputType
   */

  export type InsuranceClaimCountOutputType = {
    workEvents: number
  }

  export type InsuranceClaimCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workEvents?: boolean | InsuranceClaimCountOutputTypeCountWorkEventsArgs
  }

  // Custom InputTypes
  /**
   * InsuranceClaimCountOutputType without action
   */
  export type InsuranceClaimCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceClaimCountOutputType
     */
    select?: InsuranceClaimCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InsuranceClaimCountOutputType without action
   */
  export type InsuranceClaimCountOutputTypeCountWorkEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkEventWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    notifications: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationSubscriptionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Property
   */

  export type AggregateProperty = {
    _count: PropertyCountAggregateOutputType | null
    _avg: PropertyAvgAggregateOutputType | null
    _sum: PropertySumAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  export type PropertyAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    lotSize: number | null
    livingArea: number | null
    bedrooms: number | null
    bathrooms: number | null
    yearBuilt: number | null
  }

  export type PropertySumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    lotSize: number | null
    livingArea: number | null
    bedrooms: number | null
    bathrooms: number | null
    yearBuilt: number | null
  }

  export type PropertyMinAggregateOutputType = {
    id: string | null
    apn: string | null
    address: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    county: string | null
    latitude: number | null
    longitude: number | null
    lotSize: number | null
    livingArea: number | null
    bedrooms: number | null
    bathrooms: number | null
    yearBuilt: number | null
    propertyType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyMaxAggregateOutputType = {
    id: string | null
    apn: string | null
    address: string | null
    addressLine2: string | null
    city: string | null
    state: string | null
    zipCode: string | null
    county: string | null
    latitude: number | null
    longitude: number | null
    lotSize: number | null
    livingArea: number | null
    bedrooms: number | null
    bathrooms: number | null
    yearBuilt: number | null
    propertyType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyCountAggregateOutputType = {
    id: number
    apn: number
    address: number
    addressLine2: number
    city: number
    state: number
    zipCode: number
    county: number
    latitude: number
    longitude: number
    lotSize: number
    livingArea: number
    bedrooms: number
    bathrooms: number
    yearBuilt: number
    propertyType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PropertyAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    lotSize?: true
    livingArea?: true
    bedrooms?: true
    bathrooms?: true
    yearBuilt?: true
  }

  export type PropertySumAggregateInputType = {
    latitude?: true
    longitude?: true
    lotSize?: true
    livingArea?: true
    bedrooms?: true
    bathrooms?: true
    yearBuilt?: true
  }

  export type PropertyMinAggregateInputType = {
    id?: true
    apn?: true
    address?: true
    addressLine2?: true
    city?: true
    state?: true
    zipCode?: true
    county?: true
    latitude?: true
    longitude?: true
    lotSize?: true
    livingArea?: true
    bedrooms?: true
    bathrooms?: true
    yearBuilt?: true
    propertyType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyMaxAggregateInputType = {
    id?: true
    apn?: true
    address?: true
    addressLine2?: true
    city?: true
    state?: true
    zipCode?: true
    county?: true
    latitude?: true
    longitude?: true
    lotSize?: true
    livingArea?: true
    bedrooms?: true
    bathrooms?: true
    yearBuilt?: true
    propertyType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyCountAggregateInputType = {
    id?: true
    apn?: true
    address?: true
    addressLine2?: true
    city?: true
    state?: true
    zipCode?: true
    county?: true
    latitude?: true
    longitude?: true
    lotSize?: true
    livingArea?: true
    bedrooms?: true
    bathrooms?: true
    yearBuilt?: true
    propertyType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PropertyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Property to aggregate.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Properties
    **/
    _count?: true | PropertyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyMaxAggregateInputType
  }

  export type GetPropertyAggregateType<T extends PropertyAggregateArgs> = {
        [P in keyof T & keyof AggregateProperty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProperty[P]>
      : GetScalarType<T[P], AggregateProperty[P]>
  }




  export type PropertyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithAggregationInput | PropertyOrderByWithAggregationInput[]
    by: PropertyScalarFieldEnum[] | PropertyScalarFieldEnum
    having?: PropertyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyCountAggregateInputType | true
    _avg?: PropertyAvgAggregateInputType
    _sum?: PropertySumAggregateInputType
    _min?: PropertyMinAggregateInputType
    _max?: PropertyMaxAggregateInputType
  }

  export type PropertyGroupByOutputType = {
    id: string
    apn: string | null
    address: string
    addressLine2: string | null
    city: string
    state: string
    zipCode: string
    county: string
    latitude: number | null
    longitude: number | null
    lotSize: number | null
    livingArea: number | null
    bedrooms: number | null
    bathrooms: number | null
    yearBuilt: number | null
    propertyType: string | null
    createdAt: Date
    updatedAt: Date
    _count: PropertyCountAggregateOutputType | null
    _avg: PropertyAvgAggregateOutputType | null
    _sum: PropertySumAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  type GetPropertyGroupByPayload<T extends PropertyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyGroupByOutputType[P]>
        }
      >
    >


  export type PropertySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apn?: boolean
    address?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    county?: boolean
    latitude?: boolean
    longitude?: boolean
    lotSize?: boolean
    livingArea?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    yearBuilt?: boolean
    propertyType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sourceRecords?: boolean | Property$sourceRecordsArgs<ExtArgs>
    ownershipEvents?: boolean | Property$ownershipEventsArgs<ExtArgs>
    sales?: boolean | Property$salesArgs<ExtArgs>
    permits?: boolean | Property$permitsArgs<ExtArgs>
    workEvents?: boolean | Property$workEventsArgs<ExtArgs>
    rentalSignals?: boolean | Property$rentalSignalsArgs<ExtArgs>
    insuranceClaims?: boolean | Property$insuranceClaimsArgs<ExtArgs>
    reports?: boolean | Property$reportsArgs<ExtArgs>
    notifications?: boolean | Property$notificationsArgs<ExtArgs>
    _count?: boolean | PropertyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apn?: boolean
    address?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    county?: boolean
    latitude?: boolean
    longitude?: boolean
    lotSize?: boolean
    livingArea?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    yearBuilt?: boolean
    propertyType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["property"]>

  export type PropertySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    apn?: boolean
    address?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    county?: boolean
    latitude?: boolean
    longitude?: boolean
    lotSize?: boolean
    livingArea?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    yearBuilt?: boolean
    propertyType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["property"]>

  export type PropertySelectScalar = {
    id?: boolean
    apn?: boolean
    address?: boolean
    addressLine2?: boolean
    city?: boolean
    state?: boolean
    zipCode?: boolean
    county?: boolean
    latitude?: boolean
    longitude?: boolean
    lotSize?: boolean
    livingArea?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    yearBuilt?: boolean
    propertyType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PropertyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "apn" | "address" | "addressLine2" | "city" | "state" | "zipCode" | "county" | "latitude" | "longitude" | "lotSize" | "livingArea" | "bedrooms" | "bathrooms" | "yearBuilt" | "propertyType" | "createdAt" | "updatedAt", ExtArgs["result"]["property"]>
  export type PropertyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceRecords?: boolean | Property$sourceRecordsArgs<ExtArgs>
    ownershipEvents?: boolean | Property$ownershipEventsArgs<ExtArgs>
    sales?: boolean | Property$salesArgs<ExtArgs>
    permits?: boolean | Property$permitsArgs<ExtArgs>
    workEvents?: boolean | Property$workEventsArgs<ExtArgs>
    rentalSignals?: boolean | Property$rentalSignalsArgs<ExtArgs>
    insuranceClaims?: boolean | Property$insuranceClaimsArgs<ExtArgs>
    reports?: boolean | Property$reportsArgs<ExtArgs>
    notifications?: boolean | Property$notificationsArgs<ExtArgs>
    _count?: boolean | PropertyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PropertyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PropertyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PropertyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Property"
    objects: {
      sourceRecords: Prisma.$SourceRecordPayload<ExtArgs>[]
      ownershipEvents: Prisma.$OwnershipEventPayload<ExtArgs>[]
      sales: Prisma.$SalePayload<ExtArgs>[]
      permits: Prisma.$PermitPayload<ExtArgs>[]
      workEvents: Prisma.$WorkEventPayload<ExtArgs>[]
      rentalSignals: Prisma.$RentalSignalPayload<ExtArgs>[]
      insuranceClaims: Prisma.$InsuranceClaimPayload<ExtArgs>[]
      reports: Prisma.$ReportPayload<ExtArgs>[]
      notifications: Prisma.$NotificationSubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      apn: string | null
      address: string
      addressLine2: string | null
      city: string
      state: string
      zipCode: string
      county: string
      latitude: number | null
      longitude: number | null
      lotSize: number | null
      livingArea: number | null
      bedrooms: number | null
      bathrooms: number | null
      yearBuilt: number | null
      propertyType: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["property"]>
    composites: {}
  }

  type PropertyGetPayload<S extends boolean | null | undefined | PropertyDefaultArgs> = $Result.GetResult<Prisma.$PropertyPayload, S>

  type PropertyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyCountAggregateInputType | true
    }

  export interface PropertyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Property'], meta: { name: 'Property' } }
    /**
     * Find zero or one Property that matches the filter.
     * @param {PropertyFindUniqueArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyFindUniqueArgs>(args: SelectSubset<T, PropertyFindUniqueArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Property that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyFindUniqueOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Property that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyFindFirstArgs>(args?: SelectSubset<T, PropertyFindFirstArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Property that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Properties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Properties
     * const properties = await prisma.property.findMany()
     * 
     * // Get first 10 Properties
     * const properties = await prisma.property.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyWithIdOnly = await prisma.property.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyFindManyArgs>(args?: SelectSubset<T, PropertyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Property.
     * @param {PropertyCreateArgs} args - Arguments to create a Property.
     * @example
     * // Create one Property
     * const Property = await prisma.property.create({
     *   data: {
     *     // ... data to create a Property
     *   }
     * })
     * 
     */
    create<T extends PropertyCreateArgs>(args: SelectSubset<T, PropertyCreateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Properties.
     * @param {PropertyCreateManyArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyCreateManyArgs>(args?: SelectSubset<T, PropertyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Properties and returns the data saved in the database.
     * @param {PropertyCreateManyAndReturnArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Properties and only return the `id`
     * const propertyWithIdOnly = await prisma.property.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Property.
     * @param {PropertyDeleteArgs} args - Arguments to delete one Property.
     * @example
     * // Delete one Property
     * const Property = await prisma.property.delete({
     *   where: {
     *     // ... filter to delete one Property
     *   }
     * })
     * 
     */
    delete<T extends PropertyDeleteArgs>(args: SelectSubset<T, PropertyDeleteArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Property.
     * @param {PropertyUpdateArgs} args - Arguments to update one Property.
     * @example
     * // Update one Property
     * const property = await prisma.property.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyUpdateArgs>(args: SelectSubset<T, PropertyUpdateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Properties.
     * @param {PropertyDeleteManyArgs} args - Arguments to filter Properties to delete.
     * @example
     * // Delete a few Properties
     * const { count } = await prisma.property.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyDeleteManyArgs>(args?: SelectSubset<T, PropertyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyUpdateManyArgs>(args: SelectSubset<T, PropertyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties and returns the data updated in the database.
     * @param {PropertyUpdateManyAndReturnArgs} args - Arguments to update many Properties.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Properties and only return the `id`
     * const propertyWithIdOnly = await prisma.property.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Property.
     * @param {PropertyUpsertArgs} args - Arguments to update or create a Property.
     * @example
     * // Update or create a Property
     * const property = await prisma.property.upsert({
     *   create: {
     *     // ... data to create a Property
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Property we want to update
     *   }
     * })
     */
    upsert<T extends PropertyUpsertArgs>(args: SelectSubset<T, PropertyUpsertArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCountArgs} args - Arguments to filter Properties to count.
     * @example
     * // Count the number of Properties
     * const count = await prisma.property.count({
     *   where: {
     *     // ... the filter for the Properties we want to count
     *   }
     * })
    **/
    count<T extends PropertyCountArgs>(
      args?: Subset<T, PropertyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyAggregateArgs>(args: Subset<T, PropertyAggregateArgs>): Prisma.PrismaPromise<GetPropertyAggregateType<T>>

    /**
     * Group by Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyGroupByArgs['orderBy'] }
        : { orderBy?: PropertyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Property model
   */
  readonly fields: PropertyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Property.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sourceRecords<T extends Property$sourceRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Property$sourceRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ownershipEvents<T extends Property$ownershipEventsArgs<ExtArgs> = {}>(args?: Subset<T, Property$ownershipEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnershipEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sales<T extends Property$salesArgs<ExtArgs> = {}>(args?: Subset<T, Property$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    permits<T extends Property$permitsArgs<ExtArgs> = {}>(args?: Subset<T, Property$permitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workEvents<T extends Property$workEventsArgs<ExtArgs> = {}>(args?: Subset<T, Property$workEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rentalSignals<T extends Property$rentalSignalsArgs<ExtArgs> = {}>(args?: Subset<T, Property$rentalSignalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalSignalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    insuranceClaims<T extends Property$insuranceClaimsArgs<ExtArgs> = {}>(args?: Subset<T, Property$insuranceClaimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsuranceClaimPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reports<T extends Property$reportsArgs<ExtArgs> = {}>(args?: Subset<T, Property$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Property$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Property$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Property model
   */
  interface PropertyFieldRefs {
    readonly id: FieldRef<"Property", 'String'>
    readonly apn: FieldRef<"Property", 'String'>
    readonly address: FieldRef<"Property", 'String'>
    readonly addressLine2: FieldRef<"Property", 'String'>
    readonly city: FieldRef<"Property", 'String'>
    readonly state: FieldRef<"Property", 'String'>
    readonly zipCode: FieldRef<"Property", 'String'>
    readonly county: FieldRef<"Property", 'String'>
    readonly latitude: FieldRef<"Property", 'Float'>
    readonly longitude: FieldRef<"Property", 'Float'>
    readonly lotSize: FieldRef<"Property", 'Float'>
    readonly livingArea: FieldRef<"Property", 'Float'>
    readonly bedrooms: FieldRef<"Property", 'Int'>
    readonly bathrooms: FieldRef<"Property", 'Float'>
    readonly yearBuilt: FieldRef<"Property", 'Int'>
    readonly propertyType: FieldRef<"Property", 'String'>
    readonly createdAt: FieldRef<"Property", 'DateTime'>
    readonly updatedAt: FieldRef<"Property", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Property findUnique
   */
  export type PropertyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property findUniqueOrThrow
   */
  export type PropertyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property findFirst
   */
  export type PropertyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property findFirstOrThrow
   */
  export type PropertyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property findMany
   */
  export type PropertyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Properties to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property create
   */
  export type PropertyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to create a Property.
     */
    data: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
  }

  /**
   * Property createMany
   */
  export type PropertyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Property createManyAndReturn
   */
  export type PropertyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Property update
   */
  export type PropertyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to update a Property.
     */
    data: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
    /**
     * Choose, which Property to update.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property updateMany
   */
  export type PropertyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Properties.
     */
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyInput>
    /**
     * Filter which Properties to update
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to update.
     */
    limit?: number
  }

  /**
   * Property updateManyAndReturn
   */
  export type PropertyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * The data used to update Properties.
     */
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyInput>
    /**
     * Filter which Properties to update
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to update.
     */
    limit?: number
  }

  /**
   * Property upsert
   */
  export type PropertyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The filter to search for the Property to update in case it exists.
     */
    where: PropertyWhereUniqueInput
    /**
     * In case the Property found by the `where` argument doesn't exist, create a new Property with this data.
     */
    create: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
    /**
     * In case the Property was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
  }

  /**
   * Property delete
   */
  export type PropertyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter which Property to delete.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property deleteMany
   */
  export type PropertyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Properties to delete
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to delete.
     */
    limit?: number
  }

  /**
   * Property.sourceRecords
   */
  export type Property$sourceRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceRecord
     */
    select?: SourceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceRecord
     */
    omit?: SourceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceRecordInclude<ExtArgs> | null
    where?: SourceRecordWhereInput
    orderBy?: SourceRecordOrderByWithRelationInput | SourceRecordOrderByWithRelationInput[]
    cursor?: SourceRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SourceRecordScalarFieldEnum | SourceRecordScalarFieldEnum[]
  }

  /**
   * Property.ownershipEvents
   */
  export type Property$ownershipEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnershipEvent
     */
    select?: OwnershipEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnershipEvent
     */
    omit?: OwnershipEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnershipEventInclude<ExtArgs> | null
    where?: OwnershipEventWhereInput
    orderBy?: OwnershipEventOrderByWithRelationInput | OwnershipEventOrderByWithRelationInput[]
    cursor?: OwnershipEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OwnershipEventScalarFieldEnum | OwnershipEventScalarFieldEnum[]
  }

  /**
   * Property.sales
   */
  export type Property$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    cursor?: SaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Property.permits
   */
  export type Property$permitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permit
     */
    select?: PermitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permit
     */
    omit?: PermitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermitInclude<ExtArgs> | null
    where?: PermitWhereInput
    orderBy?: PermitOrderByWithRelationInput | PermitOrderByWithRelationInput[]
    cursor?: PermitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermitScalarFieldEnum | PermitScalarFieldEnum[]
  }

  /**
   * Property.workEvents
   */
  export type Property$workEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkEvent
     */
    select?: WorkEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkEvent
     */
    omit?: WorkEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkEventInclude<ExtArgs> | null
    where?: WorkEventWhereInput
    orderBy?: WorkEventOrderByWithRelationInput | WorkEventOrderByWithRelationInput[]
    cursor?: WorkEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkEventScalarFieldEnum | WorkEventScalarFieldEnum[]
  }

  /**
   * Property.rentalSignals
   */
  export type Property$rentalSignalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalSignal
     */
    select?: RentalSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalSignal
     */
    omit?: RentalSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalSignalInclude<ExtArgs> | null
    where?: RentalSignalWhereInput
    orderBy?: RentalSignalOrderByWithRelationInput | RentalSignalOrderByWithRelationInput[]
    cursor?: RentalSignalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RentalSignalScalarFieldEnum | RentalSignalScalarFieldEnum[]
  }

  /**
   * Property.insuranceClaims
   */
  export type Property$insuranceClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceClaim
     */
    select?: InsuranceClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceClaim
     */
    omit?: InsuranceClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceClaimInclude<ExtArgs> | null
    where?: InsuranceClaimWhereInput
    orderBy?: InsuranceClaimOrderByWithRelationInput | InsuranceClaimOrderByWithRelationInput[]
    cursor?: InsuranceClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InsuranceClaimScalarFieldEnum | InsuranceClaimScalarFieldEnum[]
  }

  /**
   * Property.reports
   */
  export type Property$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Property.notifications
   */
  export type Property$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSubscription
     */
    select?: NotificationSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSubscription
     */
    omit?: NotificationSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSubscriptionInclude<ExtArgs> | null
    where?: NotificationSubscriptionWhereInput
    orderBy?: NotificationSubscriptionOrderByWithRelationInput | NotificationSubscriptionOrderByWithRelationInput[]
    cursor?: NotificationSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationSubscriptionScalarFieldEnum | NotificationSubscriptionScalarFieldEnum[]
  }

  /**
   * Property without action
   */
  export type PropertyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
  }


  /**
   * Model SourceRecord
   */

  export type AggregateSourceRecord = {
    _count: SourceRecordCountAggregateOutputType | null
    _avg: SourceRecordAvgAggregateOutputType | null
    _sum: SourceRecordSumAggregateOutputType | null
    _min: SourceRecordMinAggregateOutputType | null
    _max: SourceRecordMaxAggregateOutputType | null
  }

  export type SourceRecordAvgAggregateOutputType = {
    version: number | null
  }

  export type SourceRecordSumAggregateOutputType = {
    version: number | null
  }

  export type SourceRecordMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    source: string | null
    sourceId: string | null
    ingestedAt: Date | null
    version: number | null
  }

  export type SourceRecordMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    source: string | null
    sourceId: string | null
    ingestedAt: Date | null
    version: number | null
  }

  export type SourceRecordCountAggregateOutputType = {
    id: number
    propertyId: number
    source: number
    sourceId: number
    rawPayload: number
    ingestedAt: number
    version: number
    _all: number
  }


  export type SourceRecordAvgAggregateInputType = {
    version?: true
  }

  export type SourceRecordSumAggregateInputType = {
    version?: true
  }

  export type SourceRecordMinAggregateInputType = {
    id?: true
    propertyId?: true
    source?: true
    sourceId?: true
    ingestedAt?: true
    version?: true
  }

  export type SourceRecordMaxAggregateInputType = {
    id?: true
    propertyId?: true
    source?: true
    sourceId?: true
    ingestedAt?: true
    version?: true
  }

  export type SourceRecordCountAggregateInputType = {
    id?: true
    propertyId?: true
    source?: true
    sourceId?: true
    rawPayload?: true
    ingestedAt?: true
    version?: true
    _all?: true
  }

  export type SourceRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SourceRecord to aggregate.
     */
    where?: SourceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceRecords to fetch.
     */
    orderBy?: SourceRecordOrderByWithRelationInput | SourceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SourceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SourceRecords
    **/
    _count?: true | SourceRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SourceRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SourceRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SourceRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SourceRecordMaxAggregateInputType
  }

  export type GetSourceRecordAggregateType<T extends SourceRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateSourceRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSourceRecord[P]>
      : GetScalarType<T[P], AggregateSourceRecord[P]>
  }




  export type SourceRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SourceRecordWhereInput
    orderBy?: SourceRecordOrderByWithAggregationInput | SourceRecordOrderByWithAggregationInput[]
    by: SourceRecordScalarFieldEnum[] | SourceRecordScalarFieldEnum
    having?: SourceRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SourceRecordCountAggregateInputType | true
    _avg?: SourceRecordAvgAggregateInputType
    _sum?: SourceRecordSumAggregateInputType
    _min?: SourceRecordMinAggregateInputType
    _max?: SourceRecordMaxAggregateInputType
  }

  export type SourceRecordGroupByOutputType = {
    id: string
    propertyId: string
    source: string
    sourceId: string | null
    rawPayload: JsonValue | null
    ingestedAt: Date
    version: number
    _count: SourceRecordCountAggregateOutputType | null
    _avg: SourceRecordAvgAggregateOutputType | null
    _sum: SourceRecordSumAggregateOutputType | null
    _min: SourceRecordMinAggregateOutputType | null
    _max: SourceRecordMaxAggregateOutputType | null
  }

  type GetSourceRecordGroupByPayload<T extends SourceRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SourceRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SourceRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SourceRecordGroupByOutputType[P]>
            : GetScalarType<T[P], SourceRecordGroupByOutputType[P]>
        }
      >
    >


  export type SourceRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    source?: boolean
    sourceId?: boolean
    rawPayload?: boolean
    ingestedAt?: boolean
    version?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sourceRecord"]>

  export type SourceRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    source?: boolean
    sourceId?: boolean
    rawPayload?: boolean
    ingestedAt?: boolean
    version?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sourceRecord"]>

  export type SourceRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    source?: boolean
    sourceId?: boolean
    rawPayload?: boolean
    ingestedAt?: boolean
    version?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sourceRecord"]>

  export type SourceRecordSelectScalar = {
    id?: boolean
    propertyId?: boolean
    source?: boolean
    sourceId?: boolean
    rawPayload?: boolean
    ingestedAt?: boolean
    version?: boolean
  }

  export type SourceRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "source" | "sourceId" | "rawPayload" | "ingestedAt" | "version", ExtArgs["result"]["sourceRecord"]>
  export type SourceRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type SourceRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type SourceRecordIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $SourceRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SourceRecord"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      source: string
      sourceId: string | null
      rawPayload: Prisma.JsonValue | null
      ingestedAt: Date
      version: number
    }, ExtArgs["result"]["sourceRecord"]>
    composites: {}
  }

  type SourceRecordGetPayload<S extends boolean | null | undefined | SourceRecordDefaultArgs> = $Result.GetResult<Prisma.$SourceRecordPayload, S>

  type SourceRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SourceRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SourceRecordCountAggregateInputType | true
    }

  export interface SourceRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SourceRecord'], meta: { name: 'SourceRecord' } }
    /**
     * Find zero or one SourceRecord that matches the filter.
     * @param {SourceRecordFindUniqueArgs} args - Arguments to find a SourceRecord
     * @example
     * // Get one SourceRecord
     * const sourceRecord = await prisma.sourceRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SourceRecordFindUniqueArgs>(args: SelectSubset<T, SourceRecordFindUniqueArgs<ExtArgs>>): Prisma__SourceRecordClient<$Result.GetResult<Prisma.$SourceRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SourceRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SourceRecordFindUniqueOrThrowArgs} args - Arguments to find a SourceRecord
     * @example
     * // Get one SourceRecord
     * const sourceRecord = await prisma.sourceRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SourceRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, SourceRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SourceRecordClient<$Result.GetResult<Prisma.$SourceRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SourceRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceRecordFindFirstArgs} args - Arguments to find a SourceRecord
     * @example
     * // Get one SourceRecord
     * const sourceRecord = await prisma.sourceRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SourceRecordFindFirstArgs>(args?: SelectSubset<T, SourceRecordFindFirstArgs<ExtArgs>>): Prisma__SourceRecordClient<$Result.GetResult<Prisma.$SourceRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SourceRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceRecordFindFirstOrThrowArgs} args - Arguments to find a SourceRecord
     * @example
     * // Get one SourceRecord
     * const sourceRecord = await prisma.sourceRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SourceRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, SourceRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__SourceRecordClient<$Result.GetResult<Prisma.$SourceRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SourceRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SourceRecords
     * const sourceRecords = await prisma.sourceRecord.findMany()
     * 
     * // Get first 10 SourceRecords
     * const sourceRecords = await prisma.sourceRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sourceRecordWithIdOnly = await prisma.sourceRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SourceRecordFindManyArgs>(args?: SelectSubset<T, SourceRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SourceRecord.
     * @param {SourceRecordCreateArgs} args - Arguments to create a SourceRecord.
     * @example
     * // Create one SourceRecord
     * const SourceRecord = await prisma.sourceRecord.create({
     *   data: {
     *     // ... data to create a SourceRecord
     *   }
     * })
     * 
     */
    create<T extends SourceRecordCreateArgs>(args: SelectSubset<T, SourceRecordCreateArgs<ExtArgs>>): Prisma__SourceRecordClient<$Result.GetResult<Prisma.$SourceRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SourceRecords.
     * @param {SourceRecordCreateManyArgs} args - Arguments to create many SourceRecords.
     * @example
     * // Create many SourceRecords
     * const sourceRecord = await prisma.sourceRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SourceRecordCreateManyArgs>(args?: SelectSubset<T, SourceRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SourceRecords and returns the data saved in the database.
     * @param {SourceRecordCreateManyAndReturnArgs} args - Arguments to create many SourceRecords.
     * @example
     * // Create many SourceRecords
     * const sourceRecord = await prisma.sourceRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SourceRecords and only return the `id`
     * const sourceRecordWithIdOnly = await prisma.sourceRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SourceRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, SourceRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SourceRecord.
     * @param {SourceRecordDeleteArgs} args - Arguments to delete one SourceRecord.
     * @example
     * // Delete one SourceRecord
     * const SourceRecord = await prisma.sourceRecord.delete({
     *   where: {
     *     // ... filter to delete one SourceRecord
     *   }
     * })
     * 
     */
    delete<T extends SourceRecordDeleteArgs>(args: SelectSubset<T, SourceRecordDeleteArgs<ExtArgs>>): Prisma__SourceRecordClient<$Result.GetResult<Prisma.$SourceRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SourceRecord.
     * @param {SourceRecordUpdateArgs} args - Arguments to update one SourceRecord.
     * @example
     * // Update one SourceRecord
     * const sourceRecord = await prisma.sourceRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SourceRecordUpdateArgs>(args: SelectSubset<T, SourceRecordUpdateArgs<ExtArgs>>): Prisma__SourceRecordClient<$Result.GetResult<Prisma.$SourceRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SourceRecords.
     * @param {SourceRecordDeleteManyArgs} args - Arguments to filter SourceRecords to delete.
     * @example
     * // Delete a few SourceRecords
     * const { count } = await prisma.sourceRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SourceRecordDeleteManyArgs>(args?: SelectSubset<T, SourceRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SourceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SourceRecords
     * const sourceRecord = await prisma.sourceRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SourceRecordUpdateManyArgs>(args: SelectSubset<T, SourceRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SourceRecords and returns the data updated in the database.
     * @param {SourceRecordUpdateManyAndReturnArgs} args - Arguments to update many SourceRecords.
     * @example
     * // Update many SourceRecords
     * const sourceRecord = await prisma.sourceRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SourceRecords and only return the `id`
     * const sourceRecordWithIdOnly = await prisma.sourceRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SourceRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, SourceRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SourceRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SourceRecord.
     * @param {SourceRecordUpsertArgs} args - Arguments to update or create a SourceRecord.
     * @example
     * // Update or create a SourceRecord
     * const sourceRecord = await prisma.sourceRecord.upsert({
     *   create: {
     *     // ... data to create a SourceRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SourceRecord we want to update
     *   }
     * })
     */
    upsert<T extends SourceRecordUpsertArgs>(args: SelectSubset<T, SourceRecordUpsertArgs<ExtArgs>>): Prisma__SourceRecordClient<$Result.GetResult<Prisma.$SourceRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SourceRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceRecordCountArgs} args - Arguments to filter SourceRecords to count.
     * @example
     * // Count the number of SourceRecords
     * const count = await prisma.sourceRecord.count({
     *   where: {
     *     // ... the filter for the SourceRecords we want to count
     *   }
     * })
    **/
    count<T extends SourceRecordCountArgs>(
      args?: Subset<T, SourceRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SourceRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SourceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SourceRecordAggregateArgs>(args: Subset<T, SourceRecordAggregateArgs>): Prisma.PrismaPromise<GetSourceRecordAggregateType<T>>

    /**
     * Group by SourceRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SourceRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SourceRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SourceRecordGroupByArgs['orderBy'] }
        : { orderBy?: SourceRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SourceRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSourceRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SourceRecord model
   */
  readonly fields: SourceRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SourceRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SourceRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SourceRecord model
   */
  interface SourceRecordFieldRefs {
    readonly id: FieldRef<"SourceRecord", 'String'>
    readonly propertyId: FieldRef<"SourceRecord", 'String'>
    readonly source: FieldRef<"SourceRecord", 'String'>
    readonly sourceId: FieldRef<"SourceRecord", 'String'>
    readonly rawPayload: FieldRef<"SourceRecord", 'Json'>
    readonly ingestedAt: FieldRef<"SourceRecord", 'DateTime'>
    readonly version: FieldRef<"SourceRecord", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SourceRecord findUnique
   */
  export type SourceRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceRecord
     */
    select?: SourceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceRecord
     */
    omit?: SourceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceRecordInclude<ExtArgs> | null
    /**
     * Filter, which SourceRecord to fetch.
     */
    where: SourceRecordWhereUniqueInput
  }

  /**
   * SourceRecord findUniqueOrThrow
   */
  export type SourceRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceRecord
     */
    select?: SourceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceRecord
     */
    omit?: SourceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceRecordInclude<ExtArgs> | null
    /**
     * Filter, which SourceRecord to fetch.
     */
    where: SourceRecordWhereUniqueInput
  }

  /**
   * SourceRecord findFirst
   */
  export type SourceRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceRecord
     */
    select?: SourceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceRecord
     */
    omit?: SourceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceRecordInclude<ExtArgs> | null
    /**
     * Filter, which SourceRecord to fetch.
     */
    where?: SourceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceRecords to fetch.
     */
    orderBy?: SourceRecordOrderByWithRelationInput | SourceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SourceRecords.
     */
    cursor?: SourceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SourceRecords.
     */
    distinct?: SourceRecordScalarFieldEnum | SourceRecordScalarFieldEnum[]
  }

  /**
   * SourceRecord findFirstOrThrow
   */
  export type SourceRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceRecord
     */
    select?: SourceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceRecord
     */
    omit?: SourceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceRecordInclude<ExtArgs> | null
    /**
     * Filter, which SourceRecord to fetch.
     */
    where?: SourceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceRecords to fetch.
     */
    orderBy?: SourceRecordOrderByWithRelationInput | SourceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SourceRecords.
     */
    cursor?: SourceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SourceRecords.
     */
    distinct?: SourceRecordScalarFieldEnum | SourceRecordScalarFieldEnum[]
  }

  /**
   * SourceRecord findMany
   */
  export type SourceRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceRecord
     */
    select?: SourceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceRecord
     */
    omit?: SourceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceRecordInclude<ExtArgs> | null
    /**
     * Filter, which SourceRecords to fetch.
     */
    where?: SourceRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SourceRecords to fetch.
     */
    orderBy?: SourceRecordOrderByWithRelationInput | SourceRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SourceRecords.
     */
    cursor?: SourceRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SourceRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SourceRecords.
     */
    skip?: number
    distinct?: SourceRecordScalarFieldEnum | SourceRecordScalarFieldEnum[]
  }

  /**
   * SourceRecord create
   */
  export type SourceRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceRecord
     */
    select?: SourceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceRecord
     */
    omit?: SourceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a SourceRecord.
     */
    data: XOR<SourceRecordCreateInput, SourceRecordUncheckedCreateInput>
  }

  /**
   * SourceRecord createMany
   */
  export type SourceRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SourceRecords.
     */
    data: SourceRecordCreateManyInput | SourceRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SourceRecord createManyAndReturn
   */
  export type SourceRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceRecord
     */
    select?: SourceRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SourceRecord
     */
    omit?: SourceRecordOmit<ExtArgs> | null
    /**
     * The data used to create many SourceRecords.
     */
    data: SourceRecordCreateManyInput | SourceRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SourceRecord update
   */
  export type SourceRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceRecord
     */
    select?: SourceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceRecord
     */
    omit?: SourceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a SourceRecord.
     */
    data: XOR<SourceRecordUpdateInput, SourceRecordUncheckedUpdateInput>
    /**
     * Choose, which SourceRecord to update.
     */
    where: SourceRecordWhereUniqueInput
  }

  /**
   * SourceRecord updateMany
   */
  export type SourceRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SourceRecords.
     */
    data: XOR<SourceRecordUpdateManyMutationInput, SourceRecordUncheckedUpdateManyInput>
    /**
     * Filter which SourceRecords to update
     */
    where?: SourceRecordWhereInput
    /**
     * Limit how many SourceRecords to update.
     */
    limit?: number
  }

  /**
   * SourceRecord updateManyAndReturn
   */
  export type SourceRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceRecord
     */
    select?: SourceRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SourceRecord
     */
    omit?: SourceRecordOmit<ExtArgs> | null
    /**
     * The data used to update SourceRecords.
     */
    data: XOR<SourceRecordUpdateManyMutationInput, SourceRecordUncheckedUpdateManyInput>
    /**
     * Filter which SourceRecords to update
     */
    where?: SourceRecordWhereInput
    /**
     * Limit how many SourceRecords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceRecordIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SourceRecord upsert
   */
  export type SourceRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceRecord
     */
    select?: SourceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceRecord
     */
    omit?: SourceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the SourceRecord to update in case it exists.
     */
    where: SourceRecordWhereUniqueInput
    /**
     * In case the SourceRecord found by the `where` argument doesn't exist, create a new SourceRecord with this data.
     */
    create: XOR<SourceRecordCreateInput, SourceRecordUncheckedCreateInput>
    /**
     * In case the SourceRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SourceRecordUpdateInput, SourceRecordUncheckedUpdateInput>
  }

  /**
   * SourceRecord delete
   */
  export type SourceRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceRecord
     */
    select?: SourceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceRecord
     */
    omit?: SourceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceRecordInclude<ExtArgs> | null
    /**
     * Filter which SourceRecord to delete.
     */
    where: SourceRecordWhereUniqueInput
  }

  /**
   * SourceRecord deleteMany
   */
  export type SourceRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SourceRecords to delete
     */
    where?: SourceRecordWhereInput
    /**
     * Limit how many SourceRecords to delete.
     */
    limit?: number
  }

  /**
   * SourceRecord without action
   */
  export type SourceRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SourceRecord
     */
    select?: SourceRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SourceRecord
     */
    omit?: SourceRecordOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SourceRecordInclude<ExtArgs> | null
  }


  /**
   * Model OwnershipEvent
   */

  export type AggregateOwnershipEvent = {
    _count: OwnershipEventCountAggregateOutputType | null
    _min: OwnershipEventMinAggregateOutputType | null
    _max: OwnershipEventMaxAggregateOutputType | null
  }

  export type OwnershipEventMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    ownerName: string | null
    ownerType: string | null
    fromDate: Date | null
    toDate: Date | null
    isCurrent: boolean | null
    documentRef: string | null
    source: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OwnershipEventMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    ownerName: string | null
    ownerType: string | null
    fromDate: Date | null
    toDate: Date | null
    isCurrent: boolean | null
    documentRef: string | null
    source: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OwnershipEventCountAggregateOutputType = {
    id: number
    propertyId: number
    ownerName: number
    ownerType: number
    fromDate: number
    toDate: number
    isCurrent: number
    documentRef: number
    source: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OwnershipEventMinAggregateInputType = {
    id?: true
    propertyId?: true
    ownerName?: true
    ownerType?: true
    fromDate?: true
    toDate?: true
    isCurrent?: true
    documentRef?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OwnershipEventMaxAggregateInputType = {
    id?: true
    propertyId?: true
    ownerName?: true
    ownerType?: true
    fromDate?: true
    toDate?: true
    isCurrent?: true
    documentRef?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OwnershipEventCountAggregateInputType = {
    id?: true
    propertyId?: true
    ownerName?: true
    ownerType?: true
    fromDate?: true
    toDate?: true
    isCurrent?: true
    documentRef?: true
    source?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OwnershipEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OwnershipEvent to aggregate.
     */
    where?: OwnershipEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnershipEvents to fetch.
     */
    orderBy?: OwnershipEventOrderByWithRelationInput | OwnershipEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OwnershipEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnershipEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnershipEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OwnershipEvents
    **/
    _count?: true | OwnershipEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OwnershipEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OwnershipEventMaxAggregateInputType
  }

  export type GetOwnershipEventAggregateType<T extends OwnershipEventAggregateArgs> = {
        [P in keyof T & keyof AggregateOwnershipEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOwnershipEvent[P]>
      : GetScalarType<T[P], AggregateOwnershipEvent[P]>
  }




  export type OwnershipEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OwnershipEventWhereInput
    orderBy?: OwnershipEventOrderByWithAggregationInput | OwnershipEventOrderByWithAggregationInput[]
    by: OwnershipEventScalarFieldEnum[] | OwnershipEventScalarFieldEnum
    having?: OwnershipEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OwnershipEventCountAggregateInputType | true
    _min?: OwnershipEventMinAggregateInputType
    _max?: OwnershipEventMaxAggregateInputType
  }

  export type OwnershipEventGroupByOutputType = {
    id: string
    propertyId: string
    ownerName: string
    ownerType: string | null
    fromDate: Date
    toDate: Date | null
    isCurrent: boolean
    documentRef: string | null
    source: string
    createdAt: Date
    updatedAt: Date
    _count: OwnershipEventCountAggregateOutputType | null
    _min: OwnershipEventMinAggregateOutputType | null
    _max: OwnershipEventMaxAggregateOutputType | null
  }

  type GetOwnershipEventGroupByPayload<T extends OwnershipEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OwnershipEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OwnershipEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OwnershipEventGroupByOutputType[P]>
            : GetScalarType<T[P], OwnershipEventGroupByOutputType[P]>
        }
      >
    >


  export type OwnershipEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    ownerName?: boolean
    ownerType?: boolean
    fromDate?: boolean
    toDate?: boolean
    isCurrent?: boolean
    documentRef?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ownershipEvent"]>

  export type OwnershipEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    ownerName?: boolean
    ownerType?: boolean
    fromDate?: boolean
    toDate?: boolean
    isCurrent?: boolean
    documentRef?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ownershipEvent"]>

  export type OwnershipEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    ownerName?: boolean
    ownerType?: boolean
    fromDate?: boolean
    toDate?: boolean
    isCurrent?: boolean
    documentRef?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ownershipEvent"]>

  export type OwnershipEventSelectScalar = {
    id?: boolean
    propertyId?: boolean
    ownerName?: boolean
    ownerType?: boolean
    fromDate?: boolean
    toDate?: boolean
    isCurrent?: boolean
    documentRef?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OwnershipEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "ownerName" | "ownerType" | "fromDate" | "toDate" | "isCurrent" | "documentRef" | "source" | "createdAt" | "updatedAt", ExtArgs["result"]["ownershipEvent"]>
  export type OwnershipEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type OwnershipEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type OwnershipEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $OwnershipEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OwnershipEvent"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      ownerName: string
      ownerType: string | null
      fromDate: Date
      toDate: Date | null
      isCurrent: boolean
      documentRef: string | null
      source: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ownershipEvent"]>
    composites: {}
  }

  type OwnershipEventGetPayload<S extends boolean | null | undefined | OwnershipEventDefaultArgs> = $Result.GetResult<Prisma.$OwnershipEventPayload, S>

  type OwnershipEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OwnershipEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OwnershipEventCountAggregateInputType | true
    }

  export interface OwnershipEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OwnershipEvent'], meta: { name: 'OwnershipEvent' } }
    /**
     * Find zero or one OwnershipEvent that matches the filter.
     * @param {OwnershipEventFindUniqueArgs} args - Arguments to find a OwnershipEvent
     * @example
     * // Get one OwnershipEvent
     * const ownershipEvent = await prisma.ownershipEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OwnershipEventFindUniqueArgs>(args: SelectSubset<T, OwnershipEventFindUniqueArgs<ExtArgs>>): Prisma__OwnershipEventClient<$Result.GetResult<Prisma.$OwnershipEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OwnershipEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OwnershipEventFindUniqueOrThrowArgs} args - Arguments to find a OwnershipEvent
     * @example
     * // Get one OwnershipEvent
     * const ownershipEvent = await prisma.ownershipEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OwnershipEventFindUniqueOrThrowArgs>(args: SelectSubset<T, OwnershipEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OwnershipEventClient<$Result.GetResult<Prisma.$OwnershipEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OwnershipEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnershipEventFindFirstArgs} args - Arguments to find a OwnershipEvent
     * @example
     * // Get one OwnershipEvent
     * const ownershipEvent = await prisma.ownershipEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OwnershipEventFindFirstArgs>(args?: SelectSubset<T, OwnershipEventFindFirstArgs<ExtArgs>>): Prisma__OwnershipEventClient<$Result.GetResult<Prisma.$OwnershipEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OwnershipEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnershipEventFindFirstOrThrowArgs} args - Arguments to find a OwnershipEvent
     * @example
     * // Get one OwnershipEvent
     * const ownershipEvent = await prisma.ownershipEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OwnershipEventFindFirstOrThrowArgs>(args?: SelectSubset<T, OwnershipEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__OwnershipEventClient<$Result.GetResult<Prisma.$OwnershipEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OwnershipEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnershipEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OwnershipEvents
     * const ownershipEvents = await prisma.ownershipEvent.findMany()
     * 
     * // Get first 10 OwnershipEvents
     * const ownershipEvents = await prisma.ownershipEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ownershipEventWithIdOnly = await prisma.ownershipEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OwnershipEventFindManyArgs>(args?: SelectSubset<T, OwnershipEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnershipEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OwnershipEvent.
     * @param {OwnershipEventCreateArgs} args - Arguments to create a OwnershipEvent.
     * @example
     * // Create one OwnershipEvent
     * const OwnershipEvent = await prisma.ownershipEvent.create({
     *   data: {
     *     // ... data to create a OwnershipEvent
     *   }
     * })
     * 
     */
    create<T extends OwnershipEventCreateArgs>(args: SelectSubset<T, OwnershipEventCreateArgs<ExtArgs>>): Prisma__OwnershipEventClient<$Result.GetResult<Prisma.$OwnershipEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OwnershipEvents.
     * @param {OwnershipEventCreateManyArgs} args - Arguments to create many OwnershipEvents.
     * @example
     * // Create many OwnershipEvents
     * const ownershipEvent = await prisma.ownershipEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OwnershipEventCreateManyArgs>(args?: SelectSubset<T, OwnershipEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OwnershipEvents and returns the data saved in the database.
     * @param {OwnershipEventCreateManyAndReturnArgs} args - Arguments to create many OwnershipEvents.
     * @example
     * // Create many OwnershipEvents
     * const ownershipEvent = await prisma.ownershipEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OwnershipEvents and only return the `id`
     * const ownershipEventWithIdOnly = await prisma.ownershipEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OwnershipEventCreateManyAndReturnArgs>(args?: SelectSubset<T, OwnershipEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnershipEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OwnershipEvent.
     * @param {OwnershipEventDeleteArgs} args - Arguments to delete one OwnershipEvent.
     * @example
     * // Delete one OwnershipEvent
     * const OwnershipEvent = await prisma.ownershipEvent.delete({
     *   where: {
     *     // ... filter to delete one OwnershipEvent
     *   }
     * })
     * 
     */
    delete<T extends OwnershipEventDeleteArgs>(args: SelectSubset<T, OwnershipEventDeleteArgs<ExtArgs>>): Prisma__OwnershipEventClient<$Result.GetResult<Prisma.$OwnershipEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OwnershipEvent.
     * @param {OwnershipEventUpdateArgs} args - Arguments to update one OwnershipEvent.
     * @example
     * // Update one OwnershipEvent
     * const ownershipEvent = await prisma.ownershipEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OwnershipEventUpdateArgs>(args: SelectSubset<T, OwnershipEventUpdateArgs<ExtArgs>>): Prisma__OwnershipEventClient<$Result.GetResult<Prisma.$OwnershipEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OwnershipEvents.
     * @param {OwnershipEventDeleteManyArgs} args - Arguments to filter OwnershipEvents to delete.
     * @example
     * // Delete a few OwnershipEvents
     * const { count } = await prisma.ownershipEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OwnershipEventDeleteManyArgs>(args?: SelectSubset<T, OwnershipEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OwnershipEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnershipEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OwnershipEvents
     * const ownershipEvent = await prisma.ownershipEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OwnershipEventUpdateManyArgs>(args: SelectSubset<T, OwnershipEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OwnershipEvents and returns the data updated in the database.
     * @param {OwnershipEventUpdateManyAndReturnArgs} args - Arguments to update many OwnershipEvents.
     * @example
     * // Update many OwnershipEvents
     * const ownershipEvent = await prisma.ownershipEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OwnershipEvents and only return the `id`
     * const ownershipEventWithIdOnly = await prisma.ownershipEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OwnershipEventUpdateManyAndReturnArgs>(args: SelectSubset<T, OwnershipEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OwnershipEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OwnershipEvent.
     * @param {OwnershipEventUpsertArgs} args - Arguments to update or create a OwnershipEvent.
     * @example
     * // Update or create a OwnershipEvent
     * const ownershipEvent = await prisma.ownershipEvent.upsert({
     *   create: {
     *     // ... data to create a OwnershipEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OwnershipEvent we want to update
     *   }
     * })
     */
    upsert<T extends OwnershipEventUpsertArgs>(args: SelectSubset<T, OwnershipEventUpsertArgs<ExtArgs>>): Prisma__OwnershipEventClient<$Result.GetResult<Prisma.$OwnershipEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OwnershipEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnershipEventCountArgs} args - Arguments to filter OwnershipEvents to count.
     * @example
     * // Count the number of OwnershipEvents
     * const count = await prisma.ownershipEvent.count({
     *   where: {
     *     // ... the filter for the OwnershipEvents we want to count
     *   }
     * })
    **/
    count<T extends OwnershipEventCountArgs>(
      args?: Subset<T, OwnershipEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OwnershipEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OwnershipEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnershipEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OwnershipEventAggregateArgs>(args: Subset<T, OwnershipEventAggregateArgs>): Prisma.PrismaPromise<GetOwnershipEventAggregateType<T>>

    /**
     * Group by OwnershipEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OwnershipEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OwnershipEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OwnershipEventGroupByArgs['orderBy'] }
        : { orderBy?: OwnershipEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OwnershipEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOwnershipEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OwnershipEvent model
   */
  readonly fields: OwnershipEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OwnershipEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OwnershipEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OwnershipEvent model
   */
  interface OwnershipEventFieldRefs {
    readonly id: FieldRef<"OwnershipEvent", 'String'>
    readonly propertyId: FieldRef<"OwnershipEvent", 'String'>
    readonly ownerName: FieldRef<"OwnershipEvent", 'String'>
    readonly ownerType: FieldRef<"OwnershipEvent", 'String'>
    readonly fromDate: FieldRef<"OwnershipEvent", 'DateTime'>
    readonly toDate: FieldRef<"OwnershipEvent", 'DateTime'>
    readonly isCurrent: FieldRef<"OwnershipEvent", 'Boolean'>
    readonly documentRef: FieldRef<"OwnershipEvent", 'String'>
    readonly source: FieldRef<"OwnershipEvent", 'String'>
    readonly createdAt: FieldRef<"OwnershipEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"OwnershipEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OwnershipEvent findUnique
   */
  export type OwnershipEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnershipEvent
     */
    select?: OwnershipEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnershipEvent
     */
    omit?: OwnershipEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnershipEventInclude<ExtArgs> | null
    /**
     * Filter, which OwnershipEvent to fetch.
     */
    where: OwnershipEventWhereUniqueInput
  }

  /**
   * OwnershipEvent findUniqueOrThrow
   */
  export type OwnershipEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnershipEvent
     */
    select?: OwnershipEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnershipEvent
     */
    omit?: OwnershipEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnershipEventInclude<ExtArgs> | null
    /**
     * Filter, which OwnershipEvent to fetch.
     */
    where: OwnershipEventWhereUniqueInput
  }

  /**
   * OwnershipEvent findFirst
   */
  export type OwnershipEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnershipEvent
     */
    select?: OwnershipEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnershipEvent
     */
    omit?: OwnershipEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnershipEventInclude<ExtArgs> | null
    /**
     * Filter, which OwnershipEvent to fetch.
     */
    where?: OwnershipEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnershipEvents to fetch.
     */
    orderBy?: OwnershipEventOrderByWithRelationInput | OwnershipEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OwnershipEvents.
     */
    cursor?: OwnershipEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnershipEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnershipEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OwnershipEvents.
     */
    distinct?: OwnershipEventScalarFieldEnum | OwnershipEventScalarFieldEnum[]
  }

  /**
   * OwnershipEvent findFirstOrThrow
   */
  export type OwnershipEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnershipEvent
     */
    select?: OwnershipEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnershipEvent
     */
    omit?: OwnershipEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnershipEventInclude<ExtArgs> | null
    /**
     * Filter, which OwnershipEvent to fetch.
     */
    where?: OwnershipEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnershipEvents to fetch.
     */
    orderBy?: OwnershipEventOrderByWithRelationInput | OwnershipEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OwnershipEvents.
     */
    cursor?: OwnershipEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnershipEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnershipEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OwnershipEvents.
     */
    distinct?: OwnershipEventScalarFieldEnum | OwnershipEventScalarFieldEnum[]
  }

  /**
   * OwnershipEvent findMany
   */
  export type OwnershipEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnershipEvent
     */
    select?: OwnershipEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnershipEvent
     */
    omit?: OwnershipEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnershipEventInclude<ExtArgs> | null
    /**
     * Filter, which OwnershipEvents to fetch.
     */
    where?: OwnershipEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OwnershipEvents to fetch.
     */
    orderBy?: OwnershipEventOrderByWithRelationInput | OwnershipEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OwnershipEvents.
     */
    cursor?: OwnershipEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OwnershipEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OwnershipEvents.
     */
    skip?: number
    distinct?: OwnershipEventScalarFieldEnum | OwnershipEventScalarFieldEnum[]
  }

  /**
   * OwnershipEvent create
   */
  export type OwnershipEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnershipEvent
     */
    select?: OwnershipEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnershipEvent
     */
    omit?: OwnershipEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnershipEventInclude<ExtArgs> | null
    /**
     * The data needed to create a OwnershipEvent.
     */
    data: XOR<OwnershipEventCreateInput, OwnershipEventUncheckedCreateInput>
  }

  /**
   * OwnershipEvent createMany
   */
  export type OwnershipEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OwnershipEvents.
     */
    data: OwnershipEventCreateManyInput | OwnershipEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OwnershipEvent createManyAndReturn
   */
  export type OwnershipEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnershipEvent
     */
    select?: OwnershipEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OwnershipEvent
     */
    omit?: OwnershipEventOmit<ExtArgs> | null
    /**
     * The data used to create many OwnershipEvents.
     */
    data: OwnershipEventCreateManyInput | OwnershipEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnershipEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OwnershipEvent update
   */
  export type OwnershipEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnershipEvent
     */
    select?: OwnershipEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnershipEvent
     */
    omit?: OwnershipEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnershipEventInclude<ExtArgs> | null
    /**
     * The data needed to update a OwnershipEvent.
     */
    data: XOR<OwnershipEventUpdateInput, OwnershipEventUncheckedUpdateInput>
    /**
     * Choose, which OwnershipEvent to update.
     */
    where: OwnershipEventWhereUniqueInput
  }

  /**
   * OwnershipEvent updateMany
   */
  export type OwnershipEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OwnershipEvents.
     */
    data: XOR<OwnershipEventUpdateManyMutationInput, OwnershipEventUncheckedUpdateManyInput>
    /**
     * Filter which OwnershipEvents to update
     */
    where?: OwnershipEventWhereInput
    /**
     * Limit how many OwnershipEvents to update.
     */
    limit?: number
  }

  /**
   * OwnershipEvent updateManyAndReturn
   */
  export type OwnershipEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnershipEvent
     */
    select?: OwnershipEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OwnershipEvent
     */
    omit?: OwnershipEventOmit<ExtArgs> | null
    /**
     * The data used to update OwnershipEvents.
     */
    data: XOR<OwnershipEventUpdateManyMutationInput, OwnershipEventUncheckedUpdateManyInput>
    /**
     * Filter which OwnershipEvents to update
     */
    where?: OwnershipEventWhereInput
    /**
     * Limit how many OwnershipEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnershipEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OwnershipEvent upsert
   */
  export type OwnershipEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnershipEvent
     */
    select?: OwnershipEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnershipEvent
     */
    omit?: OwnershipEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnershipEventInclude<ExtArgs> | null
    /**
     * The filter to search for the OwnershipEvent to update in case it exists.
     */
    where: OwnershipEventWhereUniqueInput
    /**
     * In case the OwnershipEvent found by the `where` argument doesn't exist, create a new OwnershipEvent with this data.
     */
    create: XOR<OwnershipEventCreateInput, OwnershipEventUncheckedCreateInput>
    /**
     * In case the OwnershipEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OwnershipEventUpdateInput, OwnershipEventUncheckedUpdateInput>
  }

  /**
   * OwnershipEvent delete
   */
  export type OwnershipEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnershipEvent
     */
    select?: OwnershipEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnershipEvent
     */
    omit?: OwnershipEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnershipEventInclude<ExtArgs> | null
    /**
     * Filter which OwnershipEvent to delete.
     */
    where: OwnershipEventWhereUniqueInput
  }

  /**
   * OwnershipEvent deleteMany
   */
  export type OwnershipEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OwnershipEvents to delete
     */
    where?: OwnershipEventWhereInput
    /**
     * Limit how many OwnershipEvents to delete.
     */
    limit?: number
  }

  /**
   * OwnershipEvent without action
   */
  export type OwnershipEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OwnershipEvent
     */
    select?: OwnershipEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OwnershipEvent
     */
    omit?: OwnershipEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OwnershipEventInclude<ExtArgs> | null
  }


  /**
   * Model Sale
   */

  export type AggregateSale = {
    _count: SaleCountAggregateOutputType | null
    _avg: SaleAvgAggregateOutputType | null
    _sum: SaleSumAggregateOutputType | null
    _min: SaleMinAggregateOutputType | null
    _max: SaleMaxAggregateOutputType | null
  }

  export type SaleAvgAggregateOutputType = {
    salePrice: number | null
  }

  export type SaleSumAggregateOutputType = {
    salePrice: number | null
  }

  export type SaleMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    saleDate: Date | null
    salePrice: number | null
    saleType: string | null
    buyerName: string | null
    sellerName: string | null
    documentRef: string | null
    source: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SaleMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    saleDate: Date | null
    salePrice: number | null
    saleType: string | null
    buyerName: string | null
    sellerName: string | null
    documentRef: string | null
    source: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SaleCountAggregateOutputType = {
    id: number
    propertyId: number
    saleDate: number
    salePrice: number
    saleType: number
    buyerName: number
    sellerName: number
    documentRef: number
    source: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SaleAvgAggregateInputType = {
    salePrice?: true
  }

  export type SaleSumAggregateInputType = {
    salePrice?: true
  }

  export type SaleMinAggregateInputType = {
    id?: true
    propertyId?: true
    saleDate?: true
    salePrice?: true
    saleType?: true
    buyerName?: true
    sellerName?: true
    documentRef?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SaleMaxAggregateInputType = {
    id?: true
    propertyId?: true
    saleDate?: true
    salePrice?: true
    saleType?: true
    buyerName?: true
    sellerName?: true
    documentRef?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SaleCountAggregateInputType = {
    id?: true
    propertyId?: true
    saleDate?: true
    salePrice?: true
    saleType?: true
    buyerName?: true
    sellerName?: true
    documentRef?: true
    source?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sale to aggregate.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sales
    **/
    _count?: true | SaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleMaxAggregateInputType
  }

  export type GetSaleAggregateType<T extends SaleAggregateArgs> = {
        [P in keyof T & keyof AggregateSale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSale[P]>
      : GetScalarType<T[P], AggregateSale[P]>
  }




  export type SaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithAggregationInput | SaleOrderByWithAggregationInput[]
    by: SaleScalarFieldEnum[] | SaleScalarFieldEnum
    having?: SaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleCountAggregateInputType | true
    _avg?: SaleAvgAggregateInputType
    _sum?: SaleSumAggregateInputType
    _min?: SaleMinAggregateInputType
    _max?: SaleMaxAggregateInputType
  }

  export type SaleGroupByOutputType = {
    id: string
    propertyId: string
    saleDate: Date
    salePrice: number
    saleType: string | null
    buyerName: string | null
    sellerName: string | null
    documentRef: string | null
    source: string
    createdAt: Date
    updatedAt: Date
    _count: SaleCountAggregateOutputType | null
    _avg: SaleAvgAggregateOutputType | null
    _sum: SaleSumAggregateOutputType | null
    _min: SaleMinAggregateOutputType | null
    _max: SaleMaxAggregateOutputType | null
  }

  type GetSaleGroupByPayload<T extends SaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleGroupByOutputType[P]>
            : GetScalarType<T[P], SaleGroupByOutputType[P]>
        }
      >
    >


  export type SaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    saleDate?: boolean
    salePrice?: boolean
    saleType?: boolean
    buyerName?: boolean
    sellerName?: boolean
    documentRef?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sale"]>

  export type SaleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    saleDate?: boolean
    salePrice?: boolean
    saleType?: boolean
    buyerName?: boolean
    sellerName?: boolean
    documentRef?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sale"]>

  export type SaleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    saleDate?: boolean
    salePrice?: boolean
    saleType?: boolean
    buyerName?: boolean
    sellerName?: boolean
    documentRef?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sale"]>

  export type SaleSelectScalar = {
    id?: boolean
    propertyId?: boolean
    saleDate?: boolean
    salePrice?: boolean
    saleType?: boolean
    buyerName?: boolean
    sellerName?: boolean
    documentRef?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SaleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "saleDate" | "salePrice" | "saleType" | "buyerName" | "sellerName" | "documentRef" | "source" | "createdAt" | "updatedAt", ExtArgs["result"]["sale"]>
  export type SaleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type SaleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type SaleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $SalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sale"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      saleDate: Date
      salePrice: number
      saleType: string | null
      buyerName: string | null
      sellerName: string | null
      documentRef: string | null
      source: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["sale"]>
    composites: {}
  }

  type SaleGetPayload<S extends boolean | null | undefined | SaleDefaultArgs> = $Result.GetResult<Prisma.$SalePayload, S>

  type SaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SaleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SaleCountAggregateInputType | true
    }

  export interface SaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sale'], meta: { name: 'Sale' } }
    /**
     * Find zero or one Sale that matches the filter.
     * @param {SaleFindUniqueArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleFindUniqueArgs>(args: SelectSubset<T, SaleFindUniqueArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sale that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SaleFindUniqueOrThrowArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindFirstArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleFindFirstArgs>(args?: SelectSubset<T, SaleFindFirstArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindFirstOrThrowArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sales
     * const sales = await prisma.sale.findMany()
     * 
     * // Get first 10 Sales
     * const sales = await prisma.sale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleWithIdOnly = await prisma.sale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaleFindManyArgs>(args?: SelectSubset<T, SaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sale.
     * @param {SaleCreateArgs} args - Arguments to create a Sale.
     * @example
     * // Create one Sale
     * const Sale = await prisma.sale.create({
     *   data: {
     *     // ... data to create a Sale
     *   }
     * })
     * 
     */
    create<T extends SaleCreateArgs>(args: SelectSubset<T, SaleCreateArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sales.
     * @param {SaleCreateManyArgs} args - Arguments to create many Sales.
     * @example
     * // Create many Sales
     * const sale = await prisma.sale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleCreateManyArgs>(args?: SelectSubset<T, SaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sales and returns the data saved in the database.
     * @param {SaleCreateManyAndReturnArgs} args - Arguments to create many Sales.
     * @example
     * // Create many Sales
     * const sale = await prisma.sale.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sales and only return the `id`
     * const saleWithIdOnly = await prisma.sale.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaleCreateManyAndReturnArgs>(args?: SelectSubset<T, SaleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sale.
     * @param {SaleDeleteArgs} args - Arguments to delete one Sale.
     * @example
     * // Delete one Sale
     * const Sale = await prisma.sale.delete({
     *   where: {
     *     // ... filter to delete one Sale
     *   }
     * })
     * 
     */
    delete<T extends SaleDeleteArgs>(args: SelectSubset<T, SaleDeleteArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sale.
     * @param {SaleUpdateArgs} args - Arguments to update one Sale.
     * @example
     * // Update one Sale
     * const sale = await prisma.sale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleUpdateArgs>(args: SelectSubset<T, SaleUpdateArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sales.
     * @param {SaleDeleteManyArgs} args - Arguments to filter Sales to delete.
     * @example
     * // Delete a few Sales
     * const { count } = await prisma.sale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleDeleteManyArgs>(args?: SelectSubset<T, SaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sales
     * const sale = await prisma.sale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleUpdateManyArgs>(args: SelectSubset<T, SaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sales and returns the data updated in the database.
     * @param {SaleUpdateManyAndReturnArgs} args - Arguments to update many Sales.
     * @example
     * // Update many Sales
     * const sale = await prisma.sale.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sales and only return the `id`
     * const saleWithIdOnly = await prisma.sale.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SaleUpdateManyAndReturnArgs>(args: SelectSubset<T, SaleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sale.
     * @param {SaleUpsertArgs} args - Arguments to update or create a Sale.
     * @example
     * // Update or create a Sale
     * const sale = await prisma.sale.upsert({
     *   create: {
     *     // ... data to create a Sale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sale we want to update
     *   }
     * })
     */
    upsert<T extends SaleUpsertArgs>(args: SelectSubset<T, SaleUpsertArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleCountArgs} args - Arguments to filter Sales to count.
     * @example
     * // Count the number of Sales
     * const count = await prisma.sale.count({
     *   where: {
     *     // ... the filter for the Sales we want to count
     *   }
     * })
    **/
    count<T extends SaleCountArgs>(
      args?: Subset<T, SaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleAggregateArgs>(args: Subset<T, SaleAggregateArgs>): Prisma.PrismaPromise<GetSaleAggregateType<T>>

    /**
     * Group by Sale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleGroupByArgs['orderBy'] }
        : { orderBy?: SaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sale model
   */
  readonly fields: SaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sale model
   */
  interface SaleFieldRefs {
    readonly id: FieldRef<"Sale", 'String'>
    readonly propertyId: FieldRef<"Sale", 'String'>
    readonly saleDate: FieldRef<"Sale", 'DateTime'>
    readonly salePrice: FieldRef<"Sale", 'Float'>
    readonly saleType: FieldRef<"Sale", 'String'>
    readonly buyerName: FieldRef<"Sale", 'String'>
    readonly sellerName: FieldRef<"Sale", 'String'>
    readonly documentRef: FieldRef<"Sale", 'String'>
    readonly source: FieldRef<"Sale", 'String'>
    readonly createdAt: FieldRef<"Sale", 'DateTime'>
    readonly updatedAt: FieldRef<"Sale", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sale findUnique
   */
  export type SaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale findUniqueOrThrow
   */
  export type SaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale findFirst
   */
  export type SaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sales.
     */
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale findFirstOrThrow
   */
  export type SaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sales.
     */
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale findMany
   */
  export type SaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sales to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale create
   */
  export type SaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The data needed to create a Sale.
     */
    data: XOR<SaleCreateInput, SaleUncheckedCreateInput>
  }

  /**
   * Sale createMany
   */
  export type SaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sales.
     */
    data: SaleCreateManyInput | SaleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sale createManyAndReturn
   */
  export type SaleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * The data used to create many Sales.
     */
    data: SaleCreateManyInput | SaleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sale update
   */
  export type SaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The data needed to update a Sale.
     */
    data: XOR<SaleUpdateInput, SaleUncheckedUpdateInput>
    /**
     * Choose, which Sale to update.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale updateMany
   */
  export type SaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sales.
     */
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyInput>
    /**
     * Filter which Sales to update
     */
    where?: SaleWhereInput
    /**
     * Limit how many Sales to update.
     */
    limit?: number
  }

  /**
   * Sale updateManyAndReturn
   */
  export type SaleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * The data used to update Sales.
     */
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyInput>
    /**
     * Filter which Sales to update
     */
    where?: SaleWhereInput
    /**
     * Limit how many Sales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sale upsert
   */
  export type SaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The filter to search for the Sale to update in case it exists.
     */
    where: SaleWhereUniqueInput
    /**
     * In case the Sale found by the `where` argument doesn't exist, create a new Sale with this data.
     */
    create: XOR<SaleCreateInput, SaleUncheckedCreateInput>
    /**
     * In case the Sale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleUpdateInput, SaleUncheckedUpdateInput>
  }

  /**
   * Sale delete
   */
  export type SaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter which Sale to delete.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale deleteMany
   */
  export type SaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sales to delete
     */
    where?: SaleWhereInput
    /**
     * Limit how many Sales to delete.
     */
    limit?: number
  }

  /**
   * Sale without action
   */
  export type SaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
  }


  /**
   * Model Permit
   */

  export type AggregatePermit = {
    _count: PermitCountAggregateOutputType | null
    _min: PermitMinAggregateOutputType | null
    _max: PermitMaxAggregateOutputType | null
  }

  export type PermitMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    permitNumber: string | null
    permitType: string | null
    status: string | null
    issuedDate: Date | null
    completedDate: Date | null
    expirationDate: Date | null
    description: string | null
    contractorName: string | null
    jurisdiction: string | null
    source: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermitMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    permitNumber: string | null
    permitType: string | null
    status: string | null
    issuedDate: Date | null
    completedDate: Date | null
    expirationDate: Date | null
    description: string | null
    contractorName: string | null
    jurisdiction: string | null
    source: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PermitCountAggregateOutputType = {
    id: number
    propertyId: number
    permitNumber: number
    permitType: number
    status: number
    issuedDate: number
    completedDate: number
    expirationDate: number
    description: number
    contractorName: number
    jurisdiction: number
    source: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PermitMinAggregateInputType = {
    id?: true
    propertyId?: true
    permitNumber?: true
    permitType?: true
    status?: true
    issuedDate?: true
    completedDate?: true
    expirationDate?: true
    description?: true
    contractorName?: true
    jurisdiction?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermitMaxAggregateInputType = {
    id?: true
    propertyId?: true
    permitNumber?: true
    permitType?: true
    status?: true
    issuedDate?: true
    completedDate?: true
    expirationDate?: true
    description?: true
    contractorName?: true
    jurisdiction?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PermitCountAggregateInputType = {
    id?: true
    propertyId?: true
    permitNumber?: true
    permitType?: true
    status?: true
    issuedDate?: true
    completedDate?: true
    expirationDate?: true
    description?: true
    contractorName?: true
    jurisdiction?: true
    source?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PermitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permit to aggregate.
     */
    where?: PermitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permits to fetch.
     */
    orderBy?: PermitOrderByWithRelationInput | PermitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permits
    **/
    _count?: true | PermitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermitMaxAggregateInputType
  }

  export type GetPermitAggregateType<T extends PermitAggregateArgs> = {
        [P in keyof T & keyof AggregatePermit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermit[P]>
      : GetScalarType<T[P], AggregatePermit[P]>
  }




  export type PermitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermitWhereInput
    orderBy?: PermitOrderByWithAggregationInput | PermitOrderByWithAggregationInput[]
    by: PermitScalarFieldEnum[] | PermitScalarFieldEnum
    having?: PermitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermitCountAggregateInputType | true
    _min?: PermitMinAggregateInputType
    _max?: PermitMaxAggregateInputType
  }

  export type PermitGroupByOutputType = {
    id: string
    propertyId: string
    permitNumber: string
    permitType: string
    status: string
    issuedDate: Date | null
    completedDate: Date | null
    expirationDate: Date | null
    description: string | null
    contractorName: string | null
    jurisdiction: string
    source: string
    createdAt: Date
    updatedAt: Date
    _count: PermitCountAggregateOutputType | null
    _min: PermitMinAggregateOutputType | null
    _max: PermitMaxAggregateOutputType | null
  }

  type GetPermitGroupByPayload<T extends PermitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermitGroupByOutputType[P]>
            : GetScalarType<T[P], PermitGroupByOutputType[P]>
        }
      >
    >


  export type PermitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    permitNumber?: boolean
    permitType?: boolean
    status?: boolean
    issuedDate?: boolean
    completedDate?: boolean
    expirationDate?: boolean
    description?: boolean
    contractorName?: boolean
    jurisdiction?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permit"]>

  export type PermitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    permitNumber?: boolean
    permitType?: boolean
    status?: boolean
    issuedDate?: boolean
    completedDate?: boolean
    expirationDate?: boolean
    description?: boolean
    contractorName?: boolean
    jurisdiction?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permit"]>

  export type PermitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    permitNumber?: boolean
    permitType?: boolean
    status?: boolean
    issuedDate?: boolean
    completedDate?: boolean
    expirationDate?: boolean
    description?: boolean
    contractorName?: boolean
    jurisdiction?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permit"]>

  export type PermitSelectScalar = {
    id?: boolean
    propertyId?: boolean
    permitNumber?: boolean
    permitType?: boolean
    status?: boolean
    issuedDate?: boolean
    completedDate?: boolean
    expirationDate?: boolean
    description?: boolean
    contractorName?: boolean
    jurisdiction?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PermitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "permitNumber" | "permitType" | "status" | "issuedDate" | "completedDate" | "expirationDate" | "description" | "contractorName" | "jurisdiction" | "source" | "createdAt" | "updatedAt", ExtArgs["result"]["permit"]>
  export type PermitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PermitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PermitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $PermitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permit"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      permitNumber: string
      permitType: string
      status: string
      issuedDate: Date | null
      completedDate: Date | null
      expirationDate: Date | null
      description: string | null
      contractorName: string | null
      jurisdiction: string
      source: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["permit"]>
    composites: {}
  }

  type PermitGetPayload<S extends boolean | null | undefined | PermitDefaultArgs> = $Result.GetResult<Prisma.$PermitPayload, S>

  type PermitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermitCountAggregateInputType | true
    }

  export interface PermitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permit'], meta: { name: 'Permit' } }
    /**
     * Find zero or one Permit that matches the filter.
     * @param {PermitFindUniqueArgs} args - Arguments to find a Permit
     * @example
     * // Get one Permit
     * const permit = await prisma.permit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermitFindUniqueArgs>(args: SelectSubset<T, PermitFindUniqueArgs<ExtArgs>>): Prisma__PermitClient<$Result.GetResult<Prisma.$PermitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermitFindUniqueOrThrowArgs} args - Arguments to find a Permit
     * @example
     * // Get one Permit
     * const permit = await prisma.permit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermitFindUniqueOrThrowArgs>(args: SelectSubset<T, PermitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermitClient<$Result.GetResult<Prisma.$PermitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermitFindFirstArgs} args - Arguments to find a Permit
     * @example
     * // Get one Permit
     * const permit = await prisma.permit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermitFindFirstArgs>(args?: SelectSubset<T, PermitFindFirstArgs<ExtArgs>>): Prisma__PermitClient<$Result.GetResult<Prisma.$PermitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermitFindFirstOrThrowArgs} args - Arguments to find a Permit
     * @example
     * // Get one Permit
     * const permit = await prisma.permit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermitFindFirstOrThrowArgs>(args?: SelectSubset<T, PermitFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermitClient<$Result.GetResult<Prisma.$PermitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permits
     * const permits = await prisma.permit.findMany()
     * 
     * // Get first 10 Permits
     * const permits = await prisma.permit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permitWithIdOnly = await prisma.permit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermitFindManyArgs>(args?: SelectSubset<T, PermitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permit.
     * @param {PermitCreateArgs} args - Arguments to create a Permit.
     * @example
     * // Create one Permit
     * const Permit = await prisma.permit.create({
     *   data: {
     *     // ... data to create a Permit
     *   }
     * })
     * 
     */
    create<T extends PermitCreateArgs>(args: SelectSubset<T, PermitCreateArgs<ExtArgs>>): Prisma__PermitClient<$Result.GetResult<Prisma.$PermitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permits.
     * @param {PermitCreateManyArgs} args - Arguments to create many Permits.
     * @example
     * // Create many Permits
     * const permit = await prisma.permit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermitCreateManyArgs>(args?: SelectSubset<T, PermitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Permits and returns the data saved in the database.
     * @param {PermitCreateManyAndReturnArgs} args - Arguments to create many Permits.
     * @example
     * // Create many Permits
     * const permit = await prisma.permit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Permits and only return the `id`
     * const permitWithIdOnly = await prisma.permit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermitCreateManyAndReturnArgs>(args?: SelectSubset<T, PermitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Permit.
     * @param {PermitDeleteArgs} args - Arguments to delete one Permit.
     * @example
     * // Delete one Permit
     * const Permit = await prisma.permit.delete({
     *   where: {
     *     // ... filter to delete one Permit
     *   }
     * })
     * 
     */
    delete<T extends PermitDeleteArgs>(args: SelectSubset<T, PermitDeleteArgs<ExtArgs>>): Prisma__PermitClient<$Result.GetResult<Prisma.$PermitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permit.
     * @param {PermitUpdateArgs} args - Arguments to update one Permit.
     * @example
     * // Update one Permit
     * const permit = await prisma.permit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermitUpdateArgs>(args: SelectSubset<T, PermitUpdateArgs<ExtArgs>>): Prisma__PermitClient<$Result.GetResult<Prisma.$PermitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permits.
     * @param {PermitDeleteManyArgs} args - Arguments to filter Permits to delete.
     * @example
     * // Delete a few Permits
     * const { count } = await prisma.permit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermitDeleteManyArgs>(args?: SelectSubset<T, PermitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permits
     * const permit = await prisma.permit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermitUpdateManyArgs>(args: SelectSubset<T, PermitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permits and returns the data updated in the database.
     * @param {PermitUpdateManyAndReturnArgs} args - Arguments to update many Permits.
     * @example
     * // Update many Permits
     * const permit = await prisma.permit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Permits and only return the `id`
     * const permitWithIdOnly = await prisma.permit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PermitUpdateManyAndReturnArgs>(args: SelectSubset<T, PermitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Permit.
     * @param {PermitUpsertArgs} args - Arguments to update or create a Permit.
     * @example
     * // Update or create a Permit
     * const permit = await prisma.permit.upsert({
     *   create: {
     *     // ... data to create a Permit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permit we want to update
     *   }
     * })
     */
    upsert<T extends PermitUpsertArgs>(args: SelectSubset<T, PermitUpsertArgs<ExtArgs>>): Prisma__PermitClient<$Result.GetResult<Prisma.$PermitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermitCountArgs} args - Arguments to filter Permits to count.
     * @example
     * // Count the number of Permits
     * const count = await prisma.permit.count({
     *   where: {
     *     // ... the filter for the Permits we want to count
     *   }
     * })
    **/
    count<T extends PermitCountArgs>(
      args?: Subset<T, PermitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermitAggregateArgs>(args: Subset<T, PermitAggregateArgs>): Prisma.PrismaPromise<GetPermitAggregateType<T>>

    /**
     * Group by Permit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermitGroupByArgs['orderBy'] }
        : { orderBy?: PermitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permit model
   */
  readonly fields: PermitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permit model
   */
  interface PermitFieldRefs {
    readonly id: FieldRef<"Permit", 'String'>
    readonly propertyId: FieldRef<"Permit", 'String'>
    readonly permitNumber: FieldRef<"Permit", 'String'>
    readonly permitType: FieldRef<"Permit", 'String'>
    readonly status: FieldRef<"Permit", 'String'>
    readonly issuedDate: FieldRef<"Permit", 'DateTime'>
    readonly completedDate: FieldRef<"Permit", 'DateTime'>
    readonly expirationDate: FieldRef<"Permit", 'DateTime'>
    readonly description: FieldRef<"Permit", 'String'>
    readonly contractorName: FieldRef<"Permit", 'String'>
    readonly jurisdiction: FieldRef<"Permit", 'String'>
    readonly source: FieldRef<"Permit", 'String'>
    readonly createdAt: FieldRef<"Permit", 'DateTime'>
    readonly updatedAt: FieldRef<"Permit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Permit findUnique
   */
  export type PermitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permit
     */
    select?: PermitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permit
     */
    omit?: PermitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermitInclude<ExtArgs> | null
    /**
     * Filter, which Permit to fetch.
     */
    where: PermitWhereUniqueInput
  }

  /**
   * Permit findUniqueOrThrow
   */
  export type PermitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permit
     */
    select?: PermitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permit
     */
    omit?: PermitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermitInclude<ExtArgs> | null
    /**
     * Filter, which Permit to fetch.
     */
    where: PermitWhereUniqueInput
  }

  /**
   * Permit findFirst
   */
  export type PermitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permit
     */
    select?: PermitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permit
     */
    omit?: PermitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermitInclude<ExtArgs> | null
    /**
     * Filter, which Permit to fetch.
     */
    where?: PermitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permits to fetch.
     */
    orderBy?: PermitOrderByWithRelationInput | PermitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permits.
     */
    cursor?: PermitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permits.
     */
    distinct?: PermitScalarFieldEnum | PermitScalarFieldEnum[]
  }

  /**
   * Permit findFirstOrThrow
   */
  export type PermitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permit
     */
    select?: PermitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permit
     */
    omit?: PermitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermitInclude<ExtArgs> | null
    /**
     * Filter, which Permit to fetch.
     */
    where?: PermitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permits to fetch.
     */
    orderBy?: PermitOrderByWithRelationInput | PermitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permits.
     */
    cursor?: PermitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permits.
     */
    distinct?: PermitScalarFieldEnum | PermitScalarFieldEnum[]
  }

  /**
   * Permit findMany
   */
  export type PermitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permit
     */
    select?: PermitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permit
     */
    omit?: PermitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermitInclude<ExtArgs> | null
    /**
     * Filter, which Permits to fetch.
     */
    where?: PermitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permits to fetch.
     */
    orderBy?: PermitOrderByWithRelationInput | PermitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permits.
     */
    cursor?: PermitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permits.
     */
    skip?: number
    distinct?: PermitScalarFieldEnum | PermitScalarFieldEnum[]
  }

  /**
   * Permit create
   */
  export type PermitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permit
     */
    select?: PermitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permit
     */
    omit?: PermitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermitInclude<ExtArgs> | null
    /**
     * The data needed to create a Permit.
     */
    data: XOR<PermitCreateInput, PermitUncheckedCreateInput>
  }

  /**
   * Permit createMany
   */
  export type PermitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permits.
     */
    data: PermitCreateManyInput | PermitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permit createManyAndReturn
   */
  export type PermitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permit
     */
    select?: PermitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permit
     */
    omit?: PermitOmit<ExtArgs> | null
    /**
     * The data used to create many Permits.
     */
    data: PermitCreateManyInput | PermitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Permit update
   */
  export type PermitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permit
     */
    select?: PermitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permit
     */
    omit?: PermitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermitInclude<ExtArgs> | null
    /**
     * The data needed to update a Permit.
     */
    data: XOR<PermitUpdateInput, PermitUncheckedUpdateInput>
    /**
     * Choose, which Permit to update.
     */
    where: PermitWhereUniqueInput
  }

  /**
   * Permit updateMany
   */
  export type PermitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permits.
     */
    data: XOR<PermitUpdateManyMutationInput, PermitUncheckedUpdateManyInput>
    /**
     * Filter which Permits to update
     */
    where?: PermitWhereInput
    /**
     * Limit how many Permits to update.
     */
    limit?: number
  }

  /**
   * Permit updateManyAndReturn
   */
  export type PermitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permit
     */
    select?: PermitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Permit
     */
    omit?: PermitOmit<ExtArgs> | null
    /**
     * The data used to update Permits.
     */
    data: XOR<PermitUpdateManyMutationInput, PermitUncheckedUpdateManyInput>
    /**
     * Filter which Permits to update
     */
    where?: PermitWhereInput
    /**
     * Limit how many Permits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Permit upsert
   */
  export type PermitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permit
     */
    select?: PermitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permit
     */
    omit?: PermitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermitInclude<ExtArgs> | null
    /**
     * The filter to search for the Permit to update in case it exists.
     */
    where: PermitWhereUniqueInput
    /**
     * In case the Permit found by the `where` argument doesn't exist, create a new Permit with this data.
     */
    create: XOR<PermitCreateInput, PermitUncheckedCreateInput>
    /**
     * In case the Permit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermitUpdateInput, PermitUncheckedUpdateInput>
  }

  /**
   * Permit delete
   */
  export type PermitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permit
     */
    select?: PermitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permit
     */
    omit?: PermitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermitInclude<ExtArgs> | null
    /**
     * Filter which Permit to delete.
     */
    where: PermitWhereUniqueInput
  }

  /**
   * Permit deleteMany
   */
  export type PermitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permits to delete
     */
    where?: PermitWhereInput
    /**
     * Limit how many Permits to delete.
     */
    limit?: number
  }

  /**
   * Permit without action
   */
  export type PermitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permit
     */
    select?: PermitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Permit
     */
    omit?: PermitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermitInclude<ExtArgs> | null
  }


  /**
   * Model ContractorCompany
   */

  export type AggregateContractorCompany = {
    _count: ContractorCompanyCountAggregateOutputType | null
    _avg: ContractorCompanyAvgAggregateOutputType | null
    _sum: ContractorCompanySumAggregateOutputType | null
    _min: ContractorCompanyMinAggregateOutputType | null
    _max: ContractorCompanyMaxAggregateOutputType | null
  }

  export type ContractorCompanyAvgAggregateOutputType = {
    rating: number | null
    totalJobs: number | null
  }

  export type ContractorCompanySumAggregateOutputType = {
    rating: number | null
    totalJobs: number | null
  }

  export type ContractorCompanyMinAggregateOutputType = {
    id: string | null
    name: string | null
    licenseNumber: string | null
    licenseType: string | null
    state: string | null
    verificationStatus: string | null
    phone: string | null
    email: string | null
    website: string | null
    address: string | null
    rating: number | null
    totalJobs: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContractorCompanyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    licenseNumber: string | null
    licenseType: string | null
    state: string | null
    verificationStatus: string | null
    phone: string | null
    email: string | null
    website: string | null
    address: string | null
    rating: number | null
    totalJobs: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContractorCompanyCountAggregateOutputType = {
    id: number
    name: number
    licenseNumber: number
    licenseType: number
    state: number
    verificationStatus: number
    phone: number
    email: number
    website: number
    address: number
    rating: number
    totalJobs: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContractorCompanyAvgAggregateInputType = {
    rating?: true
    totalJobs?: true
  }

  export type ContractorCompanySumAggregateInputType = {
    rating?: true
    totalJobs?: true
  }

  export type ContractorCompanyMinAggregateInputType = {
    id?: true
    name?: true
    licenseNumber?: true
    licenseType?: true
    state?: true
    verificationStatus?: true
    phone?: true
    email?: true
    website?: true
    address?: true
    rating?: true
    totalJobs?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContractorCompanyMaxAggregateInputType = {
    id?: true
    name?: true
    licenseNumber?: true
    licenseType?: true
    state?: true
    verificationStatus?: true
    phone?: true
    email?: true
    website?: true
    address?: true
    rating?: true
    totalJobs?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContractorCompanyCountAggregateInputType = {
    id?: true
    name?: true
    licenseNumber?: true
    licenseType?: true
    state?: true
    verificationStatus?: true
    phone?: true
    email?: true
    website?: true
    address?: true
    rating?: true
    totalJobs?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContractorCompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContractorCompany to aggregate.
     */
    where?: ContractorCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractorCompanies to fetch.
     */
    orderBy?: ContractorCompanyOrderByWithRelationInput | ContractorCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContractorCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractorCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractorCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContractorCompanies
    **/
    _count?: true | ContractorCompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractorCompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractorCompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractorCompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractorCompanyMaxAggregateInputType
  }

  export type GetContractorCompanyAggregateType<T extends ContractorCompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateContractorCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContractorCompany[P]>
      : GetScalarType<T[P], AggregateContractorCompany[P]>
  }




  export type ContractorCompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractorCompanyWhereInput
    orderBy?: ContractorCompanyOrderByWithAggregationInput | ContractorCompanyOrderByWithAggregationInput[]
    by: ContractorCompanyScalarFieldEnum[] | ContractorCompanyScalarFieldEnum
    having?: ContractorCompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractorCompanyCountAggregateInputType | true
    _avg?: ContractorCompanyAvgAggregateInputType
    _sum?: ContractorCompanySumAggregateInputType
    _min?: ContractorCompanyMinAggregateInputType
    _max?: ContractorCompanyMaxAggregateInputType
  }

  export type ContractorCompanyGroupByOutputType = {
    id: string
    name: string
    licenseNumber: string | null
    licenseType: string | null
    state: string
    verificationStatus: string
    phone: string | null
    email: string | null
    website: string | null
    address: string | null
    rating: number | null
    totalJobs: number
    createdAt: Date
    updatedAt: Date
    _count: ContractorCompanyCountAggregateOutputType | null
    _avg: ContractorCompanyAvgAggregateOutputType | null
    _sum: ContractorCompanySumAggregateOutputType | null
    _min: ContractorCompanyMinAggregateOutputType | null
    _max: ContractorCompanyMaxAggregateOutputType | null
  }

  type GetContractorCompanyGroupByPayload<T extends ContractorCompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractorCompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractorCompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractorCompanyGroupByOutputType[P]>
            : GetScalarType<T[P], ContractorCompanyGroupByOutputType[P]>
        }
      >
    >


  export type ContractorCompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    licenseNumber?: boolean
    licenseType?: boolean
    state?: boolean
    verificationStatus?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    address?: boolean
    rating?: boolean
    totalJobs?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workEvents?: boolean | ContractorCompany$workEventsArgs<ExtArgs>
    insuranceClaims?: boolean | ContractorCompany$insuranceClaimsArgs<ExtArgs>
    _count?: boolean | ContractorCompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contractorCompany"]>

  export type ContractorCompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    licenseNumber?: boolean
    licenseType?: boolean
    state?: boolean
    verificationStatus?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    address?: boolean
    rating?: boolean
    totalJobs?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contractorCompany"]>

  export type ContractorCompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    licenseNumber?: boolean
    licenseType?: boolean
    state?: boolean
    verificationStatus?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    address?: boolean
    rating?: boolean
    totalJobs?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["contractorCompany"]>

  export type ContractorCompanySelectScalar = {
    id?: boolean
    name?: boolean
    licenseNumber?: boolean
    licenseType?: boolean
    state?: boolean
    verificationStatus?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    address?: boolean
    rating?: boolean
    totalJobs?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContractorCompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "licenseNumber" | "licenseType" | "state" | "verificationStatus" | "phone" | "email" | "website" | "address" | "rating" | "totalJobs" | "createdAt" | "updatedAt", ExtArgs["result"]["contractorCompany"]>
  export type ContractorCompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workEvents?: boolean | ContractorCompany$workEventsArgs<ExtArgs>
    insuranceClaims?: boolean | ContractorCompany$insuranceClaimsArgs<ExtArgs>
    _count?: boolean | ContractorCompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContractorCompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ContractorCompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ContractorCompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContractorCompany"
    objects: {
      workEvents: Prisma.$WorkEventPayload<ExtArgs>[]
      insuranceClaims: Prisma.$InsuranceClaimPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      licenseNumber: string | null
      licenseType: string | null
      state: string
      verificationStatus: string
      phone: string | null
      email: string | null
      website: string | null
      address: string | null
      rating: number | null
      totalJobs: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contractorCompany"]>
    composites: {}
  }

  type ContractorCompanyGetPayload<S extends boolean | null | undefined | ContractorCompanyDefaultArgs> = $Result.GetResult<Prisma.$ContractorCompanyPayload, S>

  type ContractorCompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContractorCompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContractorCompanyCountAggregateInputType | true
    }

  export interface ContractorCompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContractorCompany'], meta: { name: 'ContractorCompany' } }
    /**
     * Find zero or one ContractorCompany that matches the filter.
     * @param {ContractorCompanyFindUniqueArgs} args - Arguments to find a ContractorCompany
     * @example
     * // Get one ContractorCompany
     * const contractorCompany = await prisma.contractorCompany.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContractorCompanyFindUniqueArgs>(args: SelectSubset<T, ContractorCompanyFindUniqueArgs<ExtArgs>>): Prisma__ContractorCompanyClient<$Result.GetResult<Prisma.$ContractorCompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContractorCompany that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContractorCompanyFindUniqueOrThrowArgs} args - Arguments to find a ContractorCompany
     * @example
     * // Get one ContractorCompany
     * const contractorCompany = await prisma.contractorCompany.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContractorCompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, ContractorCompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContractorCompanyClient<$Result.GetResult<Prisma.$ContractorCompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContractorCompany that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorCompanyFindFirstArgs} args - Arguments to find a ContractorCompany
     * @example
     * // Get one ContractorCompany
     * const contractorCompany = await prisma.contractorCompany.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContractorCompanyFindFirstArgs>(args?: SelectSubset<T, ContractorCompanyFindFirstArgs<ExtArgs>>): Prisma__ContractorCompanyClient<$Result.GetResult<Prisma.$ContractorCompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContractorCompany that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorCompanyFindFirstOrThrowArgs} args - Arguments to find a ContractorCompany
     * @example
     * // Get one ContractorCompany
     * const contractorCompany = await prisma.contractorCompany.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContractorCompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, ContractorCompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContractorCompanyClient<$Result.GetResult<Prisma.$ContractorCompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContractorCompanies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorCompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContractorCompanies
     * const contractorCompanies = await prisma.contractorCompany.findMany()
     * 
     * // Get first 10 ContractorCompanies
     * const contractorCompanies = await prisma.contractorCompany.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractorCompanyWithIdOnly = await prisma.contractorCompany.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContractorCompanyFindManyArgs>(args?: SelectSubset<T, ContractorCompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractorCompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContractorCompany.
     * @param {ContractorCompanyCreateArgs} args - Arguments to create a ContractorCompany.
     * @example
     * // Create one ContractorCompany
     * const ContractorCompany = await prisma.contractorCompany.create({
     *   data: {
     *     // ... data to create a ContractorCompany
     *   }
     * })
     * 
     */
    create<T extends ContractorCompanyCreateArgs>(args: SelectSubset<T, ContractorCompanyCreateArgs<ExtArgs>>): Prisma__ContractorCompanyClient<$Result.GetResult<Prisma.$ContractorCompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContractorCompanies.
     * @param {ContractorCompanyCreateManyArgs} args - Arguments to create many ContractorCompanies.
     * @example
     * // Create many ContractorCompanies
     * const contractorCompany = await prisma.contractorCompany.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContractorCompanyCreateManyArgs>(args?: SelectSubset<T, ContractorCompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContractorCompanies and returns the data saved in the database.
     * @param {ContractorCompanyCreateManyAndReturnArgs} args - Arguments to create many ContractorCompanies.
     * @example
     * // Create many ContractorCompanies
     * const contractorCompany = await prisma.contractorCompany.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContractorCompanies and only return the `id`
     * const contractorCompanyWithIdOnly = await prisma.contractorCompany.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContractorCompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, ContractorCompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractorCompanyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContractorCompany.
     * @param {ContractorCompanyDeleteArgs} args - Arguments to delete one ContractorCompany.
     * @example
     * // Delete one ContractorCompany
     * const ContractorCompany = await prisma.contractorCompany.delete({
     *   where: {
     *     // ... filter to delete one ContractorCompany
     *   }
     * })
     * 
     */
    delete<T extends ContractorCompanyDeleteArgs>(args: SelectSubset<T, ContractorCompanyDeleteArgs<ExtArgs>>): Prisma__ContractorCompanyClient<$Result.GetResult<Prisma.$ContractorCompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContractorCompany.
     * @param {ContractorCompanyUpdateArgs} args - Arguments to update one ContractorCompany.
     * @example
     * // Update one ContractorCompany
     * const contractorCompany = await prisma.contractorCompany.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContractorCompanyUpdateArgs>(args: SelectSubset<T, ContractorCompanyUpdateArgs<ExtArgs>>): Prisma__ContractorCompanyClient<$Result.GetResult<Prisma.$ContractorCompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContractorCompanies.
     * @param {ContractorCompanyDeleteManyArgs} args - Arguments to filter ContractorCompanies to delete.
     * @example
     * // Delete a few ContractorCompanies
     * const { count } = await prisma.contractorCompany.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContractorCompanyDeleteManyArgs>(args?: SelectSubset<T, ContractorCompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContractorCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorCompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContractorCompanies
     * const contractorCompany = await prisma.contractorCompany.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContractorCompanyUpdateManyArgs>(args: SelectSubset<T, ContractorCompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContractorCompanies and returns the data updated in the database.
     * @param {ContractorCompanyUpdateManyAndReturnArgs} args - Arguments to update many ContractorCompanies.
     * @example
     * // Update many ContractorCompanies
     * const contractorCompany = await prisma.contractorCompany.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContractorCompanies and only return the `id`
     * const contractorCompanyWithIdOnly = await prisma.contractorCompany.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContractorCompanyUpdateManyAndReturnArgs>(args: SelectSubset<T, ContractorCompanyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractorCompanyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContractorCompany.
     * @param {ContractorCompanyUpsertArgs} args - Arguments to update or create a ContractorCompany.
     * @example
     * // Update or create a ContractorCompany
     * const contractorCompany = await prisma.contractorCompany.upsert({
     *   create: {
     *     // ... data to create a ContractorCompany
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContractorCompany we want to update
     *   }
     * })
     */
    upsert<T extends ContractorCompanyUpsertArgs>(args: SelectSubset<T, ContractorCompanyUpsertArgs<ExtArgs>>): Prisma__ContractorCompanyClient<$Result.GetResult<Prisma.$ContractorCompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContractorCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorCompanyCountArgs} args - Arguments to filter ContractorCompanies to count.
     * @example
     * // Count the number of ContractorCompanies
     * const count = await prisma.contractorCompany.count({
     *   where: {
     *     // ... the filter for the ContractorCompanies we want to count
     *   }
     * })
    **/
    count<T extends ContractorCompanyCountArgs>(
      args?: Subset<T, ContractorCompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractorCompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContractorCompany.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorCompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractorCompanyAggregateArgs>(args: Subset<T, ContractorCompanyAggregateArgs>): Prisma.PrismaPromise<GetContractorCompanyAggregateType<T>>

    /**
     * Group by ContractorCompany.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractorCompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractorCompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractorCompanyGroupByArgs['orderBy'] }
        : { orderBy?: ContractorCompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractorCompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractorCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContractorCompany model
   */
  readonly fields: ContractorCompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContractorCompany.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContractorCompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workEvents<T extends ContractorCompany$workEventsArgs<ExtArgs> = {}>(args?: Subset<T, ContractorCompany$workEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    insuranceClaims<T extends ContractorCompany$insuranceClaimsArgs<ExtArgs> = {}>(args?: Subset<T, ContractorCompany$insuranceClaimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsuranceClaimPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContractorCompany model
   */
  interface ContractorCompanyFieldRefs {
    readonly id: FieldRef<"ContractorCompany", 'String'>
    readonly name: FieldRef<"ContractorCompany", 'String'>
    readonly licenseNumber: FieldRef<"ContractorCompany", 'String'>
    readonly licenseType: FieldRef<"ContractorCompany", 'String'>
    readonly state: FieldRef<"ContractorCompany", 'String'>
    readonly verificationStatus: FieldRef<"ContractorCompany", 'String'>
    readonly phone: FieldRef<"ContractorCompany", 'String'>
    readonly email: FieldRef<"ContractorCompany", 'String'>
    readonly website: FieldRef<"ContractorCompany", 'String'>
    readonly address: FieldRef<"ContractorCompany", 'String'>
    readonly rating: FieldRef<"ContractorCompany", 'Float'>
    readonly totalJobs: FieldRef<"ContractorCompany", 'Int'>
    readonly createdAt: FieldRef<"ContractorCompany", 'DateTime'>
    readonly updatedAt: FieldRef<"ContractorCompany", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContractorCompany findUnique
   */
  export type ContractorCompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorCompany
     */
    select?: ContractorCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorCompany
     */
    omit?: ContractorCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorCompanyInclude<ExtArgs> | null
    /**
     * Filter, which ContractorCompany to fetch.
     */
    where: ContractorCompanyWhereUniqueInput
  }

  /**
   * ContractorCompany findUniqueOrThrow
   */
  export type ContractorCompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorCompany
     */
    select?: ContractorCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorCompany
     */
    omit?: ContractorCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorCompanyInclude<ExtArgs> | null
    /**
     * Filter, which ContractorCompany to fetch.
     */
    where: ContractorCompanyWhereUniqueInput
  }

  /**
   * ContractorCompany findFirst
   */
  export type ContractorCompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorCompany
     */
    select?: ContractorCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorCompany
     */
    omit?: ContractorCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorCompanyInclude<ExtArgs> | null
    /**
     * Filter, which ContractorCompany to fetch.
     */
    where?: ContractorCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractorCompanies to fetch.
     */
    orderBy?: ContractorCompanyOrderByWithRelationInput | ContractorCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractorCompanies.
     */
    cursor?: ContractorCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractorCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractorCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractorCompanies.
     */
    distinct?: ContractorCompanyScalarFieldEnum | ContractorCompanyScalarFieldEnum[]
  }

  /**
   * ContractorCompany findFirstOrThrow
   */
  export type ContractorCompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorCompany
     */
    select?: ContractorCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorCompany
     */
    omit?: ContractorCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorCompanyInclude<ExtArgs> | null
    /**
     * Filter, which ContractorCompany to fetch.
     */
    where?: ContractorCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractorCompanies to fetch.
     */
    orderBy?: ContractorCompanyOrderByWithRelationInput | ContractorCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractorCompanies.
     */
    cursor?: ContractorCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractorCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractorCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractorCompanies.
     */
    distinct?: ContractorCompanyScalarFieldEnum | ContractorCompanyScalarFieldEnum[]
  }

  /**
   * ContractorCompany findMany
   */
  export type ContractorCompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorCompany
     */
    select?: ContractorCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorCompany
     */
    omit?: ContractorCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorCompanyInclude<ExtArgs> | null
    /**
     * Filter, which ContractorCompanies to fetch.
     */
    where?: ContractorCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractorCompanies to fetch.
     */
    orderBy?: ContractorCompanyOrderByWithRelationInput | ContractorCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContractorCompanies.
     */
    cursor?: ContractorCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractorCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractorCompanies.
     */
    skip?: number
    distinct?: ContractorCompanyScalarFieldEnum | ContractorCompanyScalarFieldEnum[]
  }

  /**
   * ContractorCompany create
   */
  export type ContractorCompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorCompany
     */
    select?: ContractorCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorCompany
     */
    omit?: ContractorCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorCompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a ContractorCompany.
     */
    data: XOR<ContractorCompanyCreateInput, ContractorCompanyUncheckedCreateInput>
  }

  /**
   * ContractorCompany createMany
   */
  export type ContractorCompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContractorCompanies.
     */
    data: ContractorCompanyCreateManyInput | ContractorCompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContractorCompany createManyAndReturn
   */
  export type ContractorCompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorCompany
     */
    select?: ContractorCompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorCompany
     */
    omit?: ContractorCompanyOmit<ExtArgs> | null
    /**
     * The data used to create many ContractorCompanies.
     */
    data: ContractorCompanyCreateManyInput | ContractorCompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContractorCompany update
   */
  export type ContractorCompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorCompany
     */
    select?: ContractorCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorCompany
     */
    omit?: ContractorCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorCompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a ContractorCompany.
     */
    data: XOR<ContractorCompanyUpdateInput, ContractorCompanyUncheckedUpdateInput>
    /**
     * Choose, which ContractorCompany to update.
     */
    where: ContractorCompanyWhereUniqueInput
  }

  /**
   * ContractorCompany updateMany
   */
  export type ContractorCompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContractorCompanies.
     */
    data: XOR<ContractorCompanyUpdateManyMutationInput, ContractorCompanyUncheckedUpdateManyInput>
    /**
     * Filter which ContractorCompanies to update
     */
    where?: ContractorCompanyWhereInput
    /**
     * Limit how many ContractorCompanies to update.
     */
    limit?: number
  }

  /**
   * ContractorCompany updateManyAndReturn
   */
  export type ContractorCompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorCompany
     */
    select?: ContractorCompanySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorCompany
     */
    omit?: ContractorCompanyOmit<ExtArgs> | null
    /**
     * The data used to update ContractorCompanies.
     */
    data: XOR<ContractorCompanyUpdateManyMutationInput, ContractorCompanyUncheckedUpdateManyInput>
    /**
     * Filter which ContractorCompanies to update
     */
    where?: ContractorCompanyWhereInput
    /**
     * Limit how many ContractorCompanies to update.
     */
    limit?: number
  }

  /**
   * ContractorCompany upsert
   */
  export type ContractorCompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorCompany
     */
    select?: ContractorCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorCompany
     */
    omit?: ContractorCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorCompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the ContractorCompany to update in case it exists.
     */
    where: ContractorCompanyWhereUniqueInput
    /**
     * In case the ContractorCompany found by the `where` argument doesn't exist, create a new ContractorCompany with this data.
     */
    create: XOR<ContractorCompanyCreateInput, ContractorCompanyUncheckedCreateInput>
    /**
     * In case the ContractorCompany was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContractorCompanyUpdateInput, ContractorCompanyUncheckedUpdateInput>
  }

  /**
   * ContractorCompany delete
   */
  export type ContractorCompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorCompany
     */
    select?: ContractorCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorCompany
     */
    omit?: ContractorCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorCompanyInclude<ExtArgs> | null
    /**
     * Filter which ContractorCompany to delete.
     */
    where: ContractorCompanyWhereUniqueInput
  }

  /**
   * ContractorCompany deleteMany
   */
  export type ContractorCompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContractorCompanies to delete
     */
    where?: ContractorCompanyWhereInput
    /**
     * Limit how many ContractorCompanies to delete.
     */
    limit?: number
  }

  /**
   * ContractorCompany.workEvents
   */
  export type ContractorCompany$workEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkEvent
     */
    select?: WorkEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkEvent
     */
    omit?: WorkEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkEventInclude<ExtArgs> | null
    where?: WorkEventWhereInput
    orderBy?: WorkEventOrderByWithRelationInput | WorkEventOrderByWithRelationInput[]
    cursor?: WorkEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkEventScalarFieldEnum | WorkEventScalarFieldEnum[]
  }

  /**
   * ContractorCompany.insuranceClaims
   */
  export type ContractorCompany$insuranceClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceClaim
     */
    select?: InsuranceClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceClaim
     */
    omit?: InsuranceClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceClaimInclude<ExtArgs> | null
    where?: InsuranceClaimWhereInput
    orderBy?: InsuranceClaimOrderByWithRelationInput | InsuranceClaimOrderByWithRelationInput[]
    cursor?: InsuranceClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InsuranceClaimScalarFieldEnum | InsuranceClaimScalarFieldEnum[]
  }

  /**
   * ContractorCompany without action
   */
  export type ContractorCompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorCompany
     */
    select?: ContractorCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorCompany
     */
    omit?: ContractorCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorCompanyInclude<ExtArgs> | null
  }


  /**
   * Model WorkEvent
   */

  export type AggregateWorkEvent = {
    _count: WorkEventCountAggregateOutputType | null
    _avg: WorkEventAvgAggregateOutputType | null
    _sum: WorkEventSumAggregateOutputType | null
    _min: WorkEventMinAggregateOutputType | null
    _max: WorkEventMaxAggregateOutputType | null
  }

  export type WorkEventAvgAggregateOutputType = {
    cost: number | null
    warrantyPeriodMonths: number | null
  }

  export type WorkEventSumAggregateOutputType = {
    cost: number | null
    warrantyPeriodMonths: number | null
  }

  export type WorkEventMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    contractorId: string | null
    workType: string | null
    description: string | null
    workDate: Date | null
    cost: number | null
    invoiceNumber: string | null
    documentUrl: string | null
    verificationStatus: string | null
    warrantyPeriodMonths: number | null
    warrantyExpirationDate: Date | null
    warrantyType: string | null
    warrantyDetails: string | null
    insuranceClaimId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkEventMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    contractorId: string | null
    workType: string | null
    description: string | null
    workDate: Date | null
    cost: number | null
    invoiceNumber: string | null
    documentUrl: string | null
    verificationStatus: string | null
    warrantyPeriodMonths: number | null
    warrantyExpirationDate: Date | null
    warrantyType: string | null
    warrantyDetails: string | null
    insuranceClaimId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkEventCountAggregateOutputType = {
    id: number
    propertyId: number
    contractorId: number
    workType: number
    description: number
    workDate: number
    cost: number
    invoiceNumber: number
    documentUrl: number
    verificationStatus: number
    warrantyPeriodMonths: number
    warrantyExpirationDate: number
    warrantyType: number
    warrantyDetails: number
    insuranceClaimId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkEventAvgAggregateInputType = {
    cost?: true
    warrantyPeriodMonths?: true
  }

  export type WorkEventSumAggregateInputType = {
    cost?: true
    warrantyPeriodMonths?: true
  }

  export type WorkEventMinAggregateInputType = {
    id?: true
    propertyId?: true
    contractorId?: true
    workType?: true
    description?: true
    workDate?: true
    cost?: true
    invoiceNumber?: true
    documentUrl?: true
    verificationStatus?: true
    warrantyPeriodMonths?: true
    warrantyExpirationDate?: true
    warrantyType?: true
    warrantyDetails?: true
    insuranceClaimId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkEventMaxAggregateInputType = {
    id?: true
    propertyId?: true
    contractorId?: true
    workType?: true
    description?: true
    workDate?: true
    cost?: true
    invoiceNumber?: true
    documentUrl?: true
    verificationStatus?: true
    warrantyPeriodMonths?: true
    warrantyExpirationDate?: true
    warrantyType?: true
    warrantyDetails?: true
    insuranceClaimId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkEventCountAggregateInputType = {
    id?: true
    propertyId?: true
    contractorId?: true
    workType?: true
    description?: true
    workDate?: true
    cost?: true
    invoiceNumber?: true
    documentUrl?: true
    verificationStatus?: true
    warrantyPeriodMonths?: true
    warrantyExpirationDate?: true
    warrantyType?: true
    warrantyDetails?: true
    insuranceClaimId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkEvent to aggregate.
     */
    where?: WorkEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkEvents to fetch.
     */
    orderBy?: WorkEventOrderByWithRelationInput | WorkEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkEvents
    **/
    _count?: true | WorkEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkEventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkEventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkEventMaxAggregateInputType
  }

  export type GetWorkEventAggregateType<T extends WorkEventAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkEvent[P]>
      : GetScalarType<T[P], AggregateWorkEvent[P]>
  }




  export type WorkEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkEventWhereInput
    orderBy?: WorkEventOrderByWithAggregationInput | WorkEventOrderByWithAggregationInput[]
    by: WorkEventScalarFieldEnum[] | WorkEventScalarFieldEnum
    having?: WorkEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkEventCountAggregateInputType | true
    _avg?: WorkEventAvgAggregateInputType
    _sum?: WorkEventSumAggregateInputType
    _min?: WorkEventMinAggregateInputType
    _max?: WorkEventMaxAggregateInputType
  }

  export type WorkEventGroupByOutputType = {
    id: string
    propertyId: string
    contractorId: string | null
    workType: string
    description: string | null
    workDate: Date
    cost: number | null
    invoiceNumber: string | null
    documentUrl: string | null
    verificationStatus: string
    warrantyPeriodMonths: number | null
    warrantyExpirationDate: Date | null
    warrantyType: string | null
    warrantyDetails: string | null
    insuranceClaimId: string | null
    createdAt: Date
    updatedAt: Date
    _count: WorkEventCountAggregateOutputType | null
    _avg: WorkEventAvgAggregateOutputType | null
    _sum: WorkEventSumAggregateOutputType | null
    _min: WorkEventMinAggregateOutputType | null
    _max: WorkEventMaxAggregateOutputType | null
  }

  type GetWorkEventGroupByPayload<T extends WorkEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkEventGroupByOutputType[P]>
            : GetScalarType<T[P], WorkEventGroupByOutputType[P]>
        }
      >
    >


  export type WorkEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    contractorId?: boolean
    workType?: boolean
    description?: boolean
    workDate?: boolean
    cost?: boolean
    invoiceNumber?: boolean
    documentUrl?: boolean
    verificationStatus?: boolean
    warrantyPeriodMonths?: boolean
    warrantyExpirationDate?: boolean
    warrantyType?: boolean
    warrantyDetails?: boolean
    insuranceClaimId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    contractor?: boolean | WorkEvent$contractorArgs<ExtArgs>
    insuranceClaim?: boolean | WorkEvent$insuranceClaimArgs<ExtArgs>
  }, ExtArgs["result"]["workEvent"]>

  export type WorkEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    contractorId?: boolean
    workType?: boolean
    description?: boolean
    workDate?: boolean
    cost?: boolean
    invoiceNumber?: boolean
    documentUrl?: boolean
    verificationStatus?: boolean
    warrantyPeriodMonths?: boolean
    warrantyExpirationDate?: boolean
    warrantyType?: boolean
    warrantyDetails?: boolean
    insuranceClaimId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    contractor?: boolean | WorkEvent$contractorArgs<ExtArgs>
    insuranceClaim?: boolean | WorkEvent$insuranceClaimArgs<ExtArgs>
  }, ExtArgs["result"]["workEvent"]>

  export type WorkEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    contractorId?: boolean
    workType?: boolean
    description?: boolean
    workDate?: boolean
    cost?: boolean
    invoiceNumber?: boolean
    documentUrl?: boolean
    verificationStatus?: boolean
    warrantyPeriodMonths?: boolean
    warrantyExpirationDate?: boolean
    warrantyType?: boolean
    warrantyDetails?: boolean
    insuranceClaimId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    contractor?: boolean | WorkEvent$contractorArgs<ExtArgs>
    insuranceClaim?: boolean | WorkEvent$insuranceClaimArgs<ExtArgs>
  }, ExtArgs["result"]["workEvent"]>

  export type WorkEventSelectScalar = {
    id?: boolean
    propertyId?: boolean
    contractorId?: boolean
    workType?: boolean
    description?: boolean
    workDate?: boolean
    cost?: boolean
    invoiceNumber?: boolean
    documentUrl?: boolean
    verificationStatus?: boolean
    warrantyPeriodMonths?: boolean
    warrantyExpirationDate?: boolean
    warrantyType?: boolean
    warrantyDetails?: boolean
    insuranceClaimId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "contractorId" | "workType" | "description" | "workDate" | "cost" | "invoiceNumber" | "documentUrl" | "verificationStatus" | "warrantyPeriodMonths" | "warrantyExpirationDate" | "warrantyType" | "warrantyDetails" | "insuranceClaimId" | "createdAt" | "updatedAt", ExtArgs["result"]["workEvent"]>
  export type WorkEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    contractor?: boolean | WorkEvent$contractorArgs<ExtArgs>
    insuranceClaim?: boolean | WorkEvent$insuranceClaimArgs<ExtArgs>
  }
  export type WorkEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    contractor?: boolean | WorkEvent$contractorArgs<ExtArgs>
    insuranceClaim?: boolean | WorkEvent$insuranceClaimArgs<ExtArgs>
  }
  export type WorkEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    contractor?: boolean | WorkEvent$contractorArgs<ExtArgs>
    insuranceClaim?: boolean | WorkEvent$insuranceClaimArgs<ExtArgs>
  }

  export type $WorkEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkEvent"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
      contractor: Prisma.$ContractorCompanyPayload<ExtArgs> | null
      insuranceClaim: Prisma.$InsuranceClaimPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      contractorId: string | null
      workType: string
      description: string | null
      workDate: Date
      cost: number | null
      invoiceNumber: string | null
      documentUrl: string | null
      verificationStatus: string
      warrantyPeriodMonths: number | null
      warrantyExpirationDate: Date | null
      warrantyType: string | null
      warrantyDetails: string | null
      insuranceClaimId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workEvent"]>
    composites: {}
  }

  type WorkEventGetPayload<S extends boolean | null | undefined | WorkEventDefaultArgs> = $Result.GetResult<Prisma.$WorkEventPayload, S>

  type WorkEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkEventCountAggregateInputType | true
    }

  export interface WorkEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkEvent'], meta: { name: 'WorkEvent' } }
    /**
     * Find zero or one WorkEvent that matches the filter.
     * @param {WorkEventFindUniqueArgs} args - Arguments to find a WorkEvent
     * @example
     * // Get one WorkEvent
     * const workEvent = await prisma.workEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkEventFindUniqueArgs>(args: SelectSubset<T, WorkEventFindUniqueArgs<ExtArgs>>): Prisma__WorkEventClient<$Result.GetResult<Prisma.$WorkEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkEventFindUniqueOrThrowArgs} args - Arguments to find a WorkEvent
     * @example
     * // Get one WorkEvent
     * const workEvent = await prisma.workEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkEventFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkEventClient<$Result.GetResult<Prisma.$WorkEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkEventFindFirstArgs} args - Arguments to find a WorkEvent
     * @example
     * // Get one WorkEvent
     * const workEvent = await prisma.workEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkEventFindFirstArgs>(args?: SelectSubset<T, WorkEventFindFirstArgs<ExtArgs>>): Prisma__WorkEventClient<$Result.GetResult<Prisma.$WorkEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkEventFindFirstOrThrowArgs} args - Arguments to find a WorkEvent
     * @example
     * // Get one WorkEvent
     * const workEvent = await prisma.workEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkEventFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkEventClient<$Result.GetResult<Prisma.$WorkEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkEvents
     * const workEvents = await prisma.workEvent.findMany()
     * 
     * // Get first 10 WorkEvents
     * const workEvents = await prisma.workEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workEventWithIdOnly = await prisma.workEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkEventFindManyArgs>(args?: SelectSubset<T, WorkEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkEvent.
     * @param {WorkEventCreateArgs} args - Arguments to create a WorkEvent.
     * @example
     * // Create one WorkEvent
     * const WorkEvent = await prisma.workEvent.create({
     *   data: {
     *     // ... data to create a WorkEvent
     *   }
     * })
     * 
     */
    create<T extends WorkEventCreateArgs>(args: SelectSubset<T, WorkEventCreateArgs<ExtArgs>>): Prisma__WorkEventClient<$Result.GetResult<Prisma.$WorkEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkEvents.
     * @param {WorkEventCreateManyArgs} args - Arguments to create many WorkEvents.
     * @example
     * // Create many WorkEvents
     * const workEvent = await prisma.workEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkEventCreateManyArgs>(args?: SelectSubset<T, WorkEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkEvents and returns the data saved in the database.
     * @param {WorkEventCreateManyAndReturnArgs} args - Arguments to create many WorkEvents.
     * @example
     * // Create many WorkEvents
     * const workEvent = await prisma.workEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkEvents and only return the `id`
     * const workEventWithIdOnly = await prisma.workEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkEventCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkEvent.
     * @param {WorkEventDeleteArgs} args - Arguments to delete one WorkEvent.
     * @example
     * // Delete one WorkEvent
     * const WorkEvent = await prisma.workEvent.delete({
     *   where: {
     *     // ... filter to delete one WorkEvent
     *   }
     * })
     * 
     */
    delete<T extends WorkEventDeleteArgs>(args: SelectSubset<T, WorkEventDeleteArgs<ExtArgs>>): Prisma__WorkEventClient<$Result.GetResult<Prisma.$WorkEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkEvent.
     * @param {WorkEventUpdateArgs} args - Arguments to update one WorkEvent.
     * @example
     * // Update one WorkEvent
     * const workEvent = await prisma.workEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkEventUpdateArgs>(args: SelectSubset<T, WorkEventUpdateArgs<ExtArgs>>): Prisma__WorkEventClient<$Result.GetResult<Prisma.$WorkEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkEvents.
     * @param {WorkEventDeleteManyArgs} args - Arguments to filter WorkEvents to delete.
     * @example
     * // Delete a few WorkEvents
     * const { count } = await prisma.workEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkEventDeleteManyArgs>(args?: SelectSubset<T, WorkEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkEvents
     * const workEvent = await prisma.workEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkEventUpdateManyArgs>(args: SelectSubset<T, WorkEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkEvents and returns the data updated in the database.
     * @param {WorkEventUpdateManyAndReturnArgs} args - Arguments to update many WorkEvents.
     * @example
     * // Update many WorkEvents
     * const workEvent = await prisma.workEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkEvents and only return the `id`
     * const workEventWithIdOnly = await prisma.workEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkEventUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkEvent.
     * @param {WorkEventUpsertArgs} args - Arguments to update or create a WorkEvent.
     * @example
     * // Update or create a WorkEvent
     * const workEvent = await prisma.workEvent.upsert({
     *   create: {
     *     // ... data to create a WorkEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkEvent we want to update
     *   }
     * })
     */
    upsert<T extends WorkEventUpsertArgs>(args: SelectSubset<T, WorkEventUpsertArgs<ExtArgs>>): Prisma__WorkEventClient<$Result.GetResult<Prisma.$WorkEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkEventCountArgs} args - Arguments to filter WorkEvents to count.
     * @example
     * // Count the number of WorkEvents
     * const count = await prisma.workEvent.count({
     *   where: {
     *     // ... the filter for the WorkEvents we want to count
     *   }
     * })
    **/
    count<T extends WorkEventCountArgs>(
      args?: Subset<T, WorkEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkEventAggregateArgs>(args: Subset<T, WorkEventAggregateArgs>): Prisma.PrismaPromise<GetWorkEventAggregateType<T>>

    /**
     * Group by WorkEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkEventGroupByArgs['orderBy'] }
        : { orderBy?: WorkEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkEvent model
   */
  readonly fields: WorkEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contractor<T extends WorkEvent$contractorArgs<ExtArgs> = {}>(args?: Subset<T, WorkEvent$contractorArgs<ExtArgs>>): Prisma__ContractorCompanyClient<$Result.GetResult<Prisma.$ContractorCompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    insuranceClaim<T extends WorkEvent$insuranceClaimArgs<ExtArgs> = {}>(args?: Subset<T, WorkEvent$insuranceClaimArgs<ExtArgs>>): Prisma__InsuranceClaimClient<$Result.GetResult<Prisma.$InsuranceClaimPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkEvent model
   */
  interface WorkEventFieldRefs {
    readonly id: FieldRef<"WorkEvent", 'String'>
    readonly propertyId: FieldRef<"WorkEvent", 'String'>
    readonly contractorId: FieldRef<"WorkEvent", 'String'>
    readonly workType: FieldRef<"WorkEvent", 'String'>
    readonly description: FieldRef<"WorkEvent", 'String'>
    readonly workDate: FieldRef<"WorkEvent", 'DateTime'>
    readonly cost: FieldRef<"WorkEvent", 'Float'>
    readonly invoiceNumber: FieldRef<"WorkEvent", 'String'>
    readonly documentUrl: FieldRef<"WorkEvent", 'String'>
    readonly verificationStatus: FieldRef<"WorkEvent", 'String'>
    readonly warrantyPeriodMonths: FieldRef<"WorkEvent", 'Int'>
    readonly warrantyExpirationDate: FieldRef<"WorkEvent", 'DateTime'>
    readonly warrantyType: FieldRef<"WorkEvent", 'String'>
    readonly warrantyDetails: FieldRef<"WorkEvent", 'String'>
    readonly insuranceClaimId: FieldRef<"WorkEvent", 'String'>
    readonly createdAt: FieldRef<"WorkEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"WorkEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkEvent findUnique
   */
  export type WorkEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkEvent
     */
    select?: WorkEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkEvent
     */
    omit?: WorkEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkEventInclude<ExtArgs> | null
    /**
     * Filter, which WorkEvent to fetch.
     */
    where: WorkEventWhereUniqueInput
  }

  /**
   * WorkEvent findUniqueOrThrow
   */
  export type WorkEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkEvent
     */
    select?: WorkEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkEvent
     */
    omit?: WorkEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkEventInclude<ExtArgs> | null
    /**
     * Filter, which WorkEvent to fetch.
     */
    where: WorkEventWhereUniqueInput
  }

  /**
   * WorkEvent findFirst
   */
  export type WorkEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkEvent
     */
    select?: WorkEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkEvent
     */
    omit?: WorkEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkEventInclude<ExtArgs> | null
    /**
     * Filter, which WorkEvent to fetch.
     */
    where?: WorkEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkEvents to fetch.
     */
    orderBy?: WorkEventOrderByWithRelationInput | WorkEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkEvents.
     */
    cursor?: WorkEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkEvents.
     */
    distinct?: WorkEventScalarFieldEnum | WorkEventScalarFieldEnum[]
  }

  /**
   * WorkEvent findFirstOrThrow
   */
  export type WorkEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkEvent
     */
    select?: WorkEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkEvent
     */
    omit?: WorkEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkEventInclude<ExtArgs> | null
    /**
     * Filter, which WorkEvent to fetch.
     */
    where?: WorkEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkEvents to fetch.
     */
    orderBy?: WorkEventOrderByWithRelationInput | WorkEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkEvents.
     */
    cursor?: WorkEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkEvents.
     */
    distinct?: WorkEventScalarFieldEnum | WorkEventScalarFieldEnum[]
  }

  /**
   * WorkEvent findMany
   */
  export type WorkEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkEvent
     */
    select?: WorkEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkEvent
     */
    omit?: WorkEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkEventInclude<ExtArgs> | null
    /**
     * Filter, which WorkEvents to fetch.
     */
    where?: WorkEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkEvents to fetch.
     */
    orderBy?: WorkEventOrderByWithRelationInput | WorkEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkEvents.
     */
    cursor?: WorkEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkEvents.
     */
    skip?: number
    distinct?: WorkEventScalarFieldEnum | WorkEventScalarFieldEnum[]
  }

  /**
   * WorkEvent create
   */
  export type WorkEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkEvent
     */
    select?: WorkEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkEvent
     */
    omit?: WorkEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkEventInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkEvent.
     */
    data: XOR<WorkEventCreateInput, WorkEventUncheckedCreateInput>
  }

  /**
   * WorkEvent createMany
   */
  export type WorkEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkEvents.
     */
    data: WorkEventCreateManyInput | WorkEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkEvent createManyAndReturn
   */
  export type WorkEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkEvent
     */
    select?: WorkEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkEvent
     */
    omit?: WorkEventOmit<ExtArgs> | null
    /**
     * The data used to create many WorkEvents.
     */
    data: WorkEventCreateManyInput | WorkEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkEvent update
   */
  export type WorkEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkEvent
     */
    select?: WorkEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkEvent
     */
    omit?: WorkEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkEventInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkEvent.
     */
    data: XOR<WorkEventUpdateInput, WorkEventUncheckedUpdateInput>
    /**
     * Choose, which WorkEvent to update.
     */
    where: WorkEventWhereUniqueInput
  }

  /**
   * WorkEvent updateMany
   */
  export type WorkEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkEvents.
     */
    data: XOR<WorkEventUpdateManyMutationInput, WorkEventUncheckedUpdateManyInput>
    /**
     * Filter which WorkEvents to update
     */
    where?: WorkEventWhereInput
    /**
     * Limit how many WorkEvents to update.
     */
    limit?: number
  }

  /**
   * WorkEvent updateManyAndReturn
   */
  export type WorkEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkEvent
     */
    select?: WorkEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkEvent
     */
    omit?: WorkEventOmit<ExtArgs> | null
    /**
     * The data used to update WorkEvents.
     */
    data: XOR<WorkEventUpdateManyMutationInput, WorkEventUncheckedUpdateManyInput>
    /**
     * Filter which WorkEvents to update
     */
    where?: WorkEventWhereInput
    /**
     * Limit how many WorkEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkEvent upsert
   */
  export type WorkEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkEvent
     */
    select?: WorkEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkEvent
     */
    omit?: WorkEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkEventInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkEvent to update in case it exists.
     */
    where: WorkEventWhereUniqueInput
    /**
     * In case the WorkEvent found by the `where` argument doesn't exist, create a new WorkEvent with this data.
     */
    create: XOR<WorkEventCreateInput, WorkEventUncheckedCreateInput>
    /**
     * In case the WorkEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkEventUpdateInput, WorkEventUncheckedUpdateInput>
  }

  /**
   * WorkEvent delete
   */
  export type WorkEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkEvent
     */
    select?: WorkEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkEvent
     */
    omit?: WorkEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkEventInclude<ExtArgs> | null
    /**
     * Filter which WorkEvent to delete.
     */
    where: WorkEventWhereUniqueInput
  }

  /**
   * WorkEvent deleteMany
   */
  export type WorkEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkEvents to delete
     */
    where?: WorkEventWhereInput
    /**
     * Limit how many WorkEvents to delete.
     */
    limit?: number
  }

  /**
   * WorkEvent.contractor
   */
  export type WorkEvent$contractorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorCompany
     */
    select?: ContractorCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorCompany
     */
    omit?: ContractorCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorCompanyInclude<ExtArgs> | null
    where?: ContractorCompanyWhereInput
  }

  /**
   * WorkEvent.insuranceClaim
   */
  export type WorkEvent$insuranceClaimArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceClaim
     */
    select?: InsuranceClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceClaim
     */
    omit?: InsuranceClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceClaimInclude<ExtArgs> | null
    where?: InsuranceClaimWhereInput
  }

  /**
   * WorkEvent without action
   */
  export type WorkEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkEvent
     */
    select?: WorkEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkEvent
     */
    omit?: WorkEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkEventInclude<ExtArgs> | null
  }


  /**
   * Model RentalSignal
   */

  export type AggregateRentalSignal = {
    _count: RentalSignalCountAggregateOutputType | null
    _avg: RentalSignalAvgAggregateOutputType | null
    _sum: RentalSignalSumAggregateOutputType | null
    _min: RentalSignalMinAggregateOutputType | null
    _max: RentalSignalMaxAggregateOutputType | null
  }

  export type RentalSignalAvgAggregateOutputType = {
    confidence: number | null
  }

  export type RentalSignalSumAggregateOutputType = {
    confidence: number | null
  }

  export type RentalSignalMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    source: string | null
    startDate: Date | null
    endDate: Date | null
    confidence: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RentalSignalMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    source: string | null
    startDate: Date | null
    endDate: Date | null
    confidence: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RentalSignalCountAggregateOutputType = {
    id: number
    propertyId: number
    source: number
    startDate: number
    endDate: number
    confidence: number
    evidence: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RentalSignalAvgAggregateInputType = {
    confidence?: true
  }

  export type RentalSignalSumAggregateInputType = {
    confidence?: true
  }

  export type RentalSignalMinAggregateInputType = {
    id?: true
    propertyId?: true
    source?: true
    startDate?: true
    endDate?: true
    confidence?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RentalSignalMaxAggregateInputType = {
    id?: true
    propertyId?: true
    source?: true
    startDate?: true
    endDate?: true
    confidence?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RentalSignalCountAggregateInputType = {
    id?: true
    propertyId?: true
    source?: true
    startDate?: true
    endDate?: true
    confidence?: true
    evidence?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RentalSignalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RentalSignal to aggregate.
     */
    where?: RentalSignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentalSignals to fetch.
     */
    orderBy?: RentalSignalOrderByWithRelationInput | RentalSignalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RentalSignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentalSignals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentalSignals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RentalSignals
    **/
    _count?: true | RentalSignalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RentalSignalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RentalSignalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RentalSignalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RentalSignalMaxAggregateInputType
  }

  export type GetRentalSignalAggregateType<T extends RentalSignalAggregateArgs> = {
        [P in keyof T & keyof AggregateRentalSignal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRentalSignal[P]>
      : GetScalarType<T[P], AggregateRentalSignal[P]>
  }




  export type RentalSignalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RentalSignalWhereInput
    orderBy?: RentalSignalOrderByWithAggregationInput | RentalSignalOrderByWithAggregationInput[]
    by: RentalSignalScalarFieldEnum[] | RentalSignalScalarFieldEnum
    having?: RentalSignalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RentalSignalCountAggregateInputType | true
    _avg?: RentalSignalAvgAggregateInputType
    _sum?: RentalSignalSumAggregateInputType
    _min?: RentalSignalMinAggregateInputType
    _max?: RentalSignalMaxAggregateInputType
  }

  export type RentalSignalGroupByOutputType = {
    id: string
    propertyId: string
    source: string
    startDate: Date | null
    endDate: Date | null
    confidence: number
    evidence: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: RentalSignalCountAggregateOutputType | null
    _avg: RentalSignalAvgAggregateOutputType | null
    _sum: RentalSignalSumAggregateOutputType | null
    _min: RentalSignalMinAggregateOutputType | null
    _max: RentalSignalMaxAggregateOutputType | null
  }

  type GetRentalSignalGroupByPayload<T extends RentalSignalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RentalSignalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RentalSignalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RentalSignalGroupByOutputType[P]>
            : GetScalarType<T[P], RentalSignalGroupByOutputType[P]>
        }
      >
    >


  export type RentalSignalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    source?: boolean
    startDate?: boolean
    endDate?: boolean
    confidence?: boolean
    evidence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rentalSignal"]>

  export type RentalSignalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    source?: boolean
    startDate?: boolean
    endDate?: boolean
    confidence?: boolean
    evidence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rentalSignal"]>

  export type RentalSignalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    source?: boolean
    startDate?: boolean
    endDate?: boolean
    confidence?: boolean
    evidence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rentalSignal"]>

  export type RentalSignalSelectScalar = {
    id?: boolean
    propertyId?: boolean
    source?: boolean
    startDate?: boolean
    endDate?: boolean
    confidence?: boolean
    evidence?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RentalSignalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "source" | "startDate" | "endDate" | "confidence" | "evidence" | "createdAt" | "updatedAt", ExtArgs["result"]["rentalSignal"]>
  export type RentalSignalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type RentalSignalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type RentalSignalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $RentalSignalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RentalSignal"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      source: string
      startDate: Date | null
      endDate: Date | null
      confidence: number
      evidence: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["rentalSignal"]>
    composites: {}
  }

  type RentalSignalGetPayload<S extends boolean | null | undefined | RentalSignalDefaultArgs> = $Result.GetResult<Prisma.$RentalSignalPayload, S>

  type RentalSignalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RentalSignalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RentalSignalCountAggregateInputType | true
    }

  export interface RentalSignalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RentalSignal'], meta: { name: 'RentalSignal' } }
    /**
     * Find zero or one RentalSignal that matches the filter.
     * @param {RentalSignalFindUniqueArgs} args - Arguments to find a RentalSignal
     * @example
     * // Get one RentalSignal
     * const rentalSignal = await prisma.rentalSignal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RentalSignalFindUniqueArgs>(args: SelectSubset<T, RentalSignalFindUniqueArgs<ExtArgs>>): Prisma__RentalSignalClient<$Result.GetResult<Prisma.$RentalSignalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RentalSignal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RentalSignalFindUniqueOrThrowArgs} args - Arguments to find a RentalSignal
     * @example
     * // Get one RentalSignal
     * const rentalSignal = await prisma.rentalSignal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RentalSignalFindUniqueOrThrowArgs>(args: SelectSubset<T, RentalSignalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RentalSignalClient<$Result.GetResult<Prisma.$RentalSignalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RentalSignal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalSignalFindFirstArgs} args - Arguments to find a RentalSignal
     * @example
     * // Get one RentalSignal
     * const rentalSignal = await prisma.rentalSignal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RentalSignalFindFirstArgs>(args?: SelectSubset<T, RentalSignalFindFirstArgs<ExtArgs>>): Prisma__RentalSignalClient<$Result.GetResult<Prisma.$RentalSignalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RentalSignal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalSignalFindFirstOrThrowArgs} args - Arguments to find a RentalSignal
     * @example
     * // Get one RentalSignal
     * const rentalSignal = await prisma.rentalSignal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RentalSignalFindFirstOrThrowArgs>(args?: SelectSubset<T, RentalSignalFindFirstOrThrowArgs<ExtArgs>>): Prisma__RentalSignalClient<$Result.GetResult<Prisma.$RentalSignalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RentalSignals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalSignalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RentalSignals
     * const rentalSignals = await prisma.rentalSignal.findMany()
     * 
     * // Get first 10 RentalSignals
     * const rentalSignals = await prisma.rentalSignal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rentalSignalWithIdOnly = await prisma.rentalSignal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RentalSignalFindManyArgs>(args?: SelectSubset<T, RentalSignalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalSignalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RentalSignal.
     * @param {RentalSignalCreateArgs} args - Arguments to create a RentalSignal.
     * @example
     * // Create one RentalSignal
     * const RentalSignal = await prisma.rentalSignal.create({
     *   data: {
     *     // ... data to create a RentalSignal
     *   }
     * })
     * 
     */
    create<T extends RentalSignalCreateArgs>(args: SelectSubset<T, RentalSignalCreateArgs<ExtArgs>>): Prisma__RentalSignalClient<$Result.GetResult<Prisma.$RentalSignalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RentalSignals.
     * @param {RentalSignalCreateManyArgs} args - Arguments to create many RentalSignals.
     * @example
     * // Create many RentalSignals
     * const rentalSignal = await prisma.rentalSignal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RentalSignalCreateManyArgs>(args?: SelectSubset<T, RentalSignalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RentalSignals and returns the data saved in the database.
     * @param {RentalSignalCreateManyAndReturnArgs} args - Arguments to create many RentalSignals.
     * @example
     * // Create many RentalSignals
     * const rentalSignal = await prisma.rentalSignal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RentalSignals and only return the `id`
     * const rentalSignalWithIdOnly = await prisma.rentalSignal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RentalSignalCreateManyAndReturnArgs>(args?: SelectSubset<T, RentalSignalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalSignalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RentalSignal.
     * @param {RentalSignalDeleteArgs} args - Arguments to delete one RentalSignal.
     * @example
     * // Delete one RentalSignal
     * const RentalSignal = await prisma.rentalSignal.delete({
     *   where: {
     *     // ... filter to delete one RentalSignal
     *   }
     * })
     * 
     */
    delete<T extends RentalSignalDeleteArgs>(args: SelectSubset<T, RentalSignalDeleteArgs<ExtArgs>>): Prisma__RentalSignalClient<$Result.GetResult<Prisma.$RentalSignalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RentalSignal.
     * @param {RentalSignalUpdateArgs} args - Arguments to update one RentalSignal.
     * @example
     * // Update one RentalSignal
     * const rentalSignal = await prisma.rentalSignal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RentalSignalUpdateArgs>(args: SelectSubset<T, RentalSignalUpdateArgs<ExtArgs>>): Prisma__RentalSignalClient<$Result.GetResult<Prisma.$RentalSignalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RentalSignals.
     * @param {RentalSignalDeleteManyArgs} args - Arguments to filter RentalSignals to delete.
     * @example
     * // Delete a few RentalSignals
     * const { count } = await prisma.rentalSignal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RentalSignalDeleteManyArgs>(args?: SelectSubset<T, RentalSignalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RentalSignals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalSignalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RentalSignals
     * const rentalSignal = await prisma.rentalSignal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RentalSignalUpdateManyArgs>(args: SelectSubset<T, RentalSignalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RentalSignals and returns the data updated in the database.
     * @param {RentalSignalUpdateManyAndReturnArgs} args - Arguments to update many RentalSignals.
     * @example
     * // Update many RentalSignals
     * const rentalSignal = await prisma.rentalSignal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RentalSignals and only return the `id`
     * const rentalSignalWithIdOnly = await prisma.rentalSignal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RentalSignalUpdateManyAndReturnArgs>(args: SelectSubset<T, RentalSignalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RentalSignalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RentalSignal.
     * @param {RentalSignalUpsertArgs} args - Arguments to update or create a RentalSignal.
     * @example
     * // Update or create a RentalSignal
     * const rentalSignal = await prisma.rentalSignal.upsert({
     *   create: {
     *     // ... data to create a RentalSignal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RentalSignal we want to update
     *   }
     * })
     */
    upsert<T extends RentalSignalUpsertArgs>(args: SelectSubset<T, RentalSignalUpsertArgs<ExtArgs>>): Prisma__RentalSignalClient<$Result.GetResult<Prisma.$RentalSignalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RentalSignals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalSignalCountArgs} args - Arguments to filter RentalSignals to count.
     * @example
     * // Count the number of RentalSignals
     * const count = await prisma.rentalSignal.count({
     *   where: {
     *     // ... the filter for the RentalSignals we want to count
     *   }
     * })
    **/
    count<T extends RentalSignalCountArgs>(
      args?: Subset<T, RentalSignalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RentalSignalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RentalSignal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalSignalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RentalSignalAggregateArgs>(args: Subset<T, RentalSignalAggregateArgs>): Prisma.PrismaPromise<GetRentalSignalAggregateType<T>>

    /**
     * Group by RentalSignal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RentalSignalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RentalSignalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RentalSignalGroupByArgs['orderBy'] }
        : { orderBy?: RentalSignalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RentalSignalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRentalSignalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RentalSignal model
   */
  readonly fields: RentalSignalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RentalSignal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RentalSignalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RentalSignal model
   */
  interface RentalSignalFieldRefs {
    readonly id: FieldRef<"RentalSignal", 'String'>
    readonly propertyId: FieldRef<"RentalSignal", 'String'>
    readonly source: FieldRef<"RentalSignal", 'String'>
    readonly startDate: FieldRef<"RentalSignal", 'DateTime'>
    readonly endDate: FieldRef<"RentalSignal", 'DateTime'>
    readonly confidence: FieldRef<"RentalSignal", 'Float'>
    readonly evidence: FieldRef<"RentalSignal", 'Json'>
    readonly createdAt: FieldRef<"RentalSignal", 'DateTime'>
    readonly updatedAt: FieldRef<"RentalSignal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RentalSignal findUnique
   */
  export type RentalSignalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalSignal
     */
    select?: RentalSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalSignal
     */
    omit?: RentalSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalSignalInclude<ExtArgs> | null
    /**
     * Filter, which RentalSignal to fetch.
     */
    where: RentalSignalWhereUniqueInput
  }

  /**
   * RentalSignal findUniqueOrThrow
   */
  export type RentalSignalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalSignal
     */
    select?: RentalSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalSignal
     */
    omit?: RentalSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalSignalInclude<ExtArgs> | null
    /**
     * Filter, which RentalSignal to fetch.
     */
    where: RentalSignalWhereUniqueInput
  }

  /**
   * RentalSignal findFirst
   */
  export type RentalSignalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalSignal
     */
    select?: RentalSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalSignal
     */
    omit?: RentalSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalSignalInclude<ExtArgs> | null
    /**
     * Filter, which RentalSignal to fetch.
     */
    where?: RentalSignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentalSignals to fetch.
     */
    orderBy?: RentalSignalOrderByWithRelationInput | RentalSignalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RentalSignals.
     */
    cursor?: RentalSignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentalSignals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentalSignals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RentalSignals.
     */
    distinct?: RentalSignalScalarFieldEnum | RentalSignalScalarFieldEnum[]
  }

  /**
   * RentalSignal findFirstOrThrow
   */
  export type RentalSignalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalSignal
     */
    select?: RentalSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalSignal
     */
    omit?: RentalSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalSignalInclude<ExtArgs> | null
    /**
     * Filter, which RentalSignal to fetch.
     */
    where?: RentalSignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentalSignals to fetch.
     */
    orderBy?: RentalSignalOrderByWithRelationInput | RentalSignalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RentalSignals.
     */
    cursor?: RentalSignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentalSignals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentalSignals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RentalSignals.
     */
    distinct?: RentalSignalScalarFieldEnum | RentalSignalScalarFieldEnum[]
  }

  /**
   * RentalSignal findMany
   */
  export type RentalSignalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalSignal
     */
    select?: RentalSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalSignal
     */
    omit?: RentalSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalSignalInclude<ExtArgs> | null
    /**
     * Filter, which RentalSignals to fetch.
     */
    where?: RentalSignalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RentalSignals to fetch.
     */
    orderBy?: RentalSignalOrderByWithRelationInput | RentalSignalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RentalSignals.
     */
    cursor?: RentalSignalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RentalSignals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RentalSignals.
     */
    skip?: number
    distinct?: RentalSignalScalarFieldEnum | RentalSignalScalarFieldEnum[]
  }

  /**
   * RentalSignal create
   */
  export type RentalSignalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalSignal
     */
    select?: RentalSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalSignal
     */
    omit?: RentalSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalSignalInclude<ExtArgs> | null
    /**
     * The data needed to create a RentalSignal.
     */
    data: XOR<RentalSignalCreateInput, RentalSignalUncheckedCreateInput>
  }

  /**
   * RentalSignal createMany
   */
  export type RentalSignalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RentalSignals.
     */
    data: RentalSignalCreateManyInput | RentalSignalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RentalSignal createManyAndReturn
   */
  export type RentalSignalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalSignal
     */
    select?: RentalSignalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RentalSignal
     */
    omit?: RentalSignalOmit<ExtArgs> | null
    /**
     * The data used to create many RentalSignals.
     */
    data: RentalSignalCreateManyInput | RentalSignalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalSignalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RentalSignal update
   */
  export type RentalSignalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalSignal
     */
    select?: RentalSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalSignal
     */
    omit?: RentalSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalSignalInclude<ExtArgs> | null
    /**
     * The data needed to update a RentalSignal.
     */
    data: XOR<RentalSignalUpdateInput, RentalSignalUncheckedUpdateInput>
    /**
     * Choose, which RentalSignal to update.
     */
    where: RentalSignalWhereUniqueInput
  }

  /**
   * RentalSignal updateMany
   */
  export type RentalSignalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RentalSignals.
     */
    data: XOR<RentalSignalUpdateManyMutationInput, RentalSignalUncheckedUpdateManyInput>
    /**
     * Filter which RentalSignals to update
     */
    where?: RentalSignalWhereInput
    /**
     * Limit how many RentalSignals to update.
     */
    limit?: number
  }

  /**
   * RentalSignal updateManyAndReturn
   */
  export type RentalSignalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalSignal
     */
    select?: RentalSignalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RentalSignal
     */
    omit?: RentalSignalOmit<ExtArgs> | null
    /**
     * The data used to update RentalSignals.
     */
    data: XOR<RentalSignalUpdateManyMutationInput, RentalSignalUncheckedUpdateManyInput>
    /**
     * Filter which RentalSignals to update
     */
    where?: RentalSignalWhereInput
    /**
     * Limit how many RentalSignals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalSignalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RentalSignal upsert
   */
  export type RentalSignalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalSignal
     */
    select?: RentalSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalSignal
     */
    omit?: RentalSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalSignalInclude<ExtArgs> | null
    /**
     * The filter to search for the RentalSignal to update in case it exists.
     */
    where: RentalSignalWhereUniqueInput
    /**
     * In case the RentalSignal found by the `where` argument doesn't exist, create a new RentalSignal with this data.
     */
    create: XOR<RentalSignalCreateInput, RentalSignalUncheckedCreateInput>
    /**
     * In case the RentalSignal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RentalSignalUpdateInput, RentalSignalUncheckedUpdateInput>
  }

  /**
   * RentalSignal delete
   */
  export type RentalSignalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalSignal
     */
    select?: RentalSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalSignal
     */
    omit?: RentalSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalSignalInclude<ExtArgs> | null
    /**
     * Filter which RentalSignal to delete.
     */
    where: RentalSignalWhereUniqueInput
  }

  /**
   * RentalSignal deleteMany
   */
  export type RentalSignalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RentalSignals to delete
     */
    where?: RentalSignalWhereInput
    /**
     * Limit how many RentalSignals to delete.
     */
    limit?: number
  }

  /**
   * RentalSignal without action
   */
  export type RentalSignalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RentalSignal
     */
    select?: RentalSignalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RentalSignal
     */
    omit?: RentalSignalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RentalSignalInclude<ExtArgs> | null
  }


  /**
   * Model InsuranceClaim
   */

  export type AggregateInsuranceClaim = {
    _count: InsuranceClaimCountAggregateOutputType | null
    _avg: InsuranceClaimAvgAggregateOutputType | null
    _sum: InsuranceClaimSumAggregateOutputType | null
    _min: InsuranceClaimMinAggregateOutputType | null
    _max: InsuranceClaimMaxAggregateOutputType | null
  }

  export type InsuranceClaimAvgAggregateOutputType = {
    amount: number | null
  }

  export type InsuranceClaimSumAggregateOutputType = {
    amount: number | null
  }

  export type InsuranceClaimMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    claimType: string | null
    claimDate: Date | null
    amount: number | null
    status: string | null
    submittedBy: string | null
    verificationStatus: string | null
    documentUrl: string | null
    contractorId: string | null
    workDescription: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InsuranceClaimMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    claimType: string | null
    claimDate: Date | null
    amount: number | null
    status: string | null
    submittedBy: string | null
    verificationStatus: string | null
    documentUrl: string | null
    contractorId: string | null
    workDescription: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InsuranceClaimCountAggregateOutputType = {
    id: number
    propertyId: number
    claimType: number
    claimDate: number
    amount: number
    status: number
    submittedBy: number
    verificationStatus: number
    documentUrl: number
    contractorId: number
    workDescription: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InsuranceClaimAvgAggregateInputType = {
    amount?: true
  }

  export type InsuranceClaimSumAggregateInputType = {
    amount?: true
  }

  export type InsuranceClaimMinAggregateInputType = {
    id?: true
    propertyId?: true
    claimType?: true
    claimDate?: true
    amount?: true
    status?: true
    submittedBy?: true
    verificationStatus?: true
    documentUrl?: true
    contractorId?: true
    workDescription?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InsuranceClaimMaxAggregateInputType = {
    id?: true
    propertyId?: true
    claimType?: true
    claimDate?: true
    amount?: true
    status?: true
    submittedBy?: true
    verificationStatus?: true
    documentUrl?: true
    contractorId?: true
    workDescription?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InsuranceClaimCountAggregateInputType = {
    id?: true
    propertyId?: true
    claimType?: true
    claimDate?: true
    amount?: true
    status?: true
    submittedBy?: true
    verificationStatus?: true
    documentUrl?: true
    contractorId?: true
    workDescription?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InsuranceClaimAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InsuranceClaim to aggregate.
     */
    where?: InsuranceClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsuranceClaims to fetch.
     */
    orderBy?: InsuranceClaimOrderByWithRelationInput | InsuranceClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InsuranceClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsuranceClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsuranceClaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InsuranceClaims
    **/
    _count?: true | InsuranceClaimCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InsuranceClaimAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InsuranceClaimSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InsuranceClaimMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InsuranceClaimMaxAggregateInputType
  }

  export type GetInsuranceClaimAggregateType<T extends InsuranceClaimAggregateArgs> = {
        [P in keyof T & keyof AggregateInsuranceClaim]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInsuranceClaim[P]>
      : GetScalarType<T[P], AggregateInsuranceClaim[P]>
  }




  export type InsuranceClaimGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsuranceClaimWhereInput
    orderBy?: InsuranceClaimOrderByWithAggregationInput | InsuranceClaimOrderByWithAggregationInput[]
    by: InsuranceClaimScalarFieldEnum[] | InsuranceClaimScalarFieldEnum
    having?: InsuranceClaimScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InsuranceClaimCountAggregateInputType | true
    _avg?: InsuranceClaimAvgAggregateInputType
    _sum?: InsuranceClaimSumAggregateInputType
    _min?: InsuranceClaimMinAggregateInputType
    _max?: InsuranceClaimMaxAggregateInputType
  }

  export type InsuranceClaimGroupByOutputType = {
    id: string
    propertyId: string
    claimType: string
    claimDate: Date
    amount: number | null
    status: string | null
    submittedBy: string | null
    verificationStatus: string
    documentUrl: string | null
    contractorId: string | null
    workDescription: string | null
    createdAt: Date
    updatedAt: Date
    _count: InsuranceClaimCountAggregateOutputType | null
    _avg: InsuranceClaimAvgAggregateOutputType | null
    _sum: InsuranceClaimSumAggregateOutputType | null
    _min: InsuranceClaimMinAggregateOutputType | null
    _max: InsuranceClaimMaxAggregateOutputType | null
  }

  type GetInsuranceClaimGroupByPayload<T extends InsuranceClaimGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InsuranceClaimGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InsuranceClaimGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InsuranceClaimGroupByOutputType[P]>
            : GetScalarType<T[P], InsuranceClaimGroupByOutputType[P]>
        }
      >
    >


  export type InsuranceClaimSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    claimType?: boolean
    claimDate?: boolean
    amount?: boolean
    status?: boolean
    submittedBy?: boolean
    verificationStatus?: boolean
    documentUrl?: boolean
    contractorId?: boolean
    workDescription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    contractor?: boolean | InsuranceClaim$contractorArgs<ExtArgs>
    workEvents?: boolean | InsuranceClaim$workEventsArgs<ExtArgs>
    _count?: boolean | InsuranceClaimCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insuranceClaim"]>

  export type InsuranceClaimSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    claimType?: boolean
    claimDate?: boolean
    amount?: boolean
    status?: boolean
    submittedBy?: boolean
    verificationStatus?: boolean
    documentUrl?: boolean
    contractorId?: boolean
    workDescription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    contractor?: boolean | InsuranceClaim$contractorArgs<ExtArgs>
  }, ExtArgs["result"]["insuranceClaim"]>

  export type InsuranceClaimSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    claimType?: boolean
    claimDate?: boolean
    amount?: boolean
    status?: boolean
    submittedBy?: boolean
    verificationStatus?: boolean
    documentUrl?: boolean
    contractorId?: boolean
    workDescription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    contractor?: boolean | InsuranceClaim$contractorArgs<ExtArgs>
  }, ExtArgs["result"]["insuranceClaim"]>

  export type InsuranceClaimSelectScalar = {
    id?: boolean
    propertyId?: boolean
    claimType?: boolean
    claimDate?: boolean
    amount?: boolean
    status?: boolean
    submittedBy?: boolean
    verificationStatus?: boolean
    documentUrl?: boolean
    contractorId?: boolean
    workDescription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InsuranceClaimOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "claimType" | "claimDate" | "amount" | "status" | "submittedBy" | "verificationStatus" | "documentUrl" | "contractorId" | "workDescription" | "createdAt" | "updatedAt", ExtArgs["result"]["insuranceClaim"]>
  export type InsuranceClaimInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    contractor?: boolean | InsuranceClaim$contractorArgs<ExtArgs>
    workEvents?: boolean | InsuranceClaim$workEventsArgs<ExtArgs>
    _count?: boolean | InsuranceClaimCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InsuranceClaimIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    contractor?: boolean | InsuranceClaim$contractorArgs<ExtArgs>
  }
  export type InsuranceClaimIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    contractor?: boolean | InsuranceClaim$contractorArgs<ExtArgs>
  }

  export type $InsuranceClaimPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InsuranceClaim"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
      contractor: Prisma.$ContractorCompanyPayload<ExtArgs> | null
      workEvents: Prisma.$WorkEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      claimType: string
      claimDate: Date
      amount: number | null
      status: string | null
      submittedBy: string | null
      verificationStatus: string
      documentUrl: string | null
      contractorId: string | null
      workDescription: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["insuranceClaim"]>
    composites: {}
  }

  type InsuranceClaimGetPayload<S extends boolean | null | undefined | InsuranceClaimDefaultArgs> = $Result.GetResult<Prisma.$InsuranceClaimPayload, S>

  type InsuranceClaimCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InsuranceClaimFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InsuranceClaimCountAggregateInputType | true
    }

  export interface InsuranceClaimDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InsuranceClaim'], meta: { name: 'InsuranceClaim' } }
    /**
     * Find zero or one InsuranceClaim that matches the filter.
     * @param {InsuranceClaimFindUniqueArgs} args - Arguments to find a InsuranceClaim
     * @example
     * // Get one InsuranceClaim
     * const insuranceClaim = await prisma.insuranceClaim.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InsuranceClaimFindUniqueArgs>(args: SelectSubset<T, InsuranceClaimFindUniqueArgs<ExtArgs>>): Prisma__InsuranceClaimClient<$Result.GetResult<Prisma.$InsuranceClaimPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InsuranceClaim that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InsuranceClaimFindUniqueOrThrowArgs} args - Arguments to find a InsuranceClaim
     * @example
     * // Get one InsuranceClaim
     * const insuranceClaim = await prisma.insuranceClaim.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InsuranceClaimFindUniqueOrThrowArgs>(args: SelectSubset<T, InsuranceClaimFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InsuranceClaimClient<$Result.GetResult<Prisma.$InsuranceClaimPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InsuranceClaim that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceClaimFindFirstArgs} args - Arguments to find a InsuranceClaim
     * @example
     * // Get one InsuranceClaim
     * const insuranceClaim = await prisma.insuranceClaim.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InsuranceClaimFindFirstArgs>(args?: SelectSubset<T, InsuranceClaimFindFirstArgs<ExtArgs>>): Prisma__InsuranceClaimClient<$Result.GetResult<Prisma.$InsuranceClaimPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InsuranceClaim that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceClaimFindFirstOrThrowArgs} args - Arguments to find a InsuranceClaim
     * @example
     * // Get one InsuranceClaim
     * const insuranceClaim = await prisma.insuranceClaim.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InsuranceClaimFindFirstOrThrowArgs>(args?: SelectSubset<T, InsuranceClaimFindFirstOrThrowArgs<ExtArgs>>): Prisma__InsuranceClaimClient<$Result.GetResult<Prisma.$InsuranceClaimPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InsuranceClaims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceClaimFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InsuranceClaims
     * const insuranceClaims = await prisma.insuranceClaim.findMany()
     * 
     * // Get first 10 InsuranceClaims
     * const insuranceClaims = await prisma.insuranceClaim.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const insuranceClaimWithIdOnly = await prisma.insuranceClaim.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InsuranceClaimFindManyArgs>(args?: SelectSubset<T, InsuranceClaimFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsuranceClaimPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InsuranceClaim.
     * @param {InsuranceClaimCreateArgs} args - Arguments to create a InsuranceClaim.
     * @example
     * // Create one InsuranceClaim
     * const InsuranceClaim = await prisma.insuranceClaim.create({
     *   data: {
     *     // ... data to create a InsuranceClaim
     *   }
     * })
     * 
     */
    create<T extends InsuranceClaimCreateArgs>(args: SelectSubset<T, InsuranceClaimCreateArgs<ExtArgs>>): Prisma__InsuranceClaimClient<$Result.GetResult<Prisma.$InsuranceClaimPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InsuranceClaims.
     * @param {InsuranceClaimCreateManyArgs} args - Arguments to create many InsuranceClaims.
     * @example
     * // Create many InsuranceClaims
     * const insuranceClaim = await prisma.insuranceClaim.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InsuranceClaimCreateManyArgs>(args?: SelectSubset<T, InsuranceClaimCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InsuranceClaims and returns the data saved in the database.
     * @param {InsuranceClaimCreateManyAndReturnArgs} args - Arguments to create many InsuranceClaims.
     * @example
     * // Create many InsuranceClaims
     * const insuranceClaim = await prisma.insuranceClaim.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InsuranceClaims and only return the `id`
     * const insuranceClaimWithIdOnly = await prisma.insuranceClaim.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InsuranceClaimCreateManyAndReturnArgs>(args?: SelectSubset<T, InsuranceClaimCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsuranceClaimPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InsuranceClaim.
     * @param {InsuranceClaimDeleteArgs} args - Arguments to delete one InsuranceClaim.
     * @example
     * // Delete one InsuranceClaim
     * const InsuranceClaim = await prisma.insuranceClaim.delete({
     *   where: {
     *     // ... filter to delete one InsuranceClaim
     *   }
     * })
     * 
     */
    delete<T extends InsuranceClaimDeleteArgs>(args: SelectSubset<T, InsuranceClaimDeleteArgs<ExtArgs>>): Prisma__InsuranceClaimClient<$Result.GetResult<Prisma.$InsuranceClaimPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InsuranceClaim.
     * @param {InsuranceClaimUpdateArgs} args - Arguments to update one InsuranceClaim.
     * @example
     * // Update one InsuranceClaim
     * const insuranceClaim = await prisma.insuranceClaim.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InsuranceClaimUpdateArgs>(args: SelectSubset<T, InsuranceClaimUpdateArgs<ExtArgs>>): Prisma__InsuranceClaimClient<$Result.GetResult<Prisma.$InsuranceClaimPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InsuranceClaims.
     * @param {InsuranceClaimDeleteManyArgs} args - Arguments to filter InsuranceClaims to delete.
     * @example
     * // Delete a few InsuranceClaims
     * const { count } = await prisma.insuranceClaim.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InsuranceClaimDeleteManyArgs>(args?: SelectSubset<T, InsuranceClaimDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InsuranceClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceClaimUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InsuranceClaims
     * const insuranceClaim = await prisma.insuranceClaim.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InsuranceClaimUpdateManyArgs>(args: SelectSubset<T, InsuranceClaimUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InsuranceClaims and returns the data updated in the database.
     * @param {InsuranceClaimUpdateManyAndReturnArgs} args - Arguments to update many InsuranceClaims.
     * @example
     * // Update many InsuranceClaims
     * const insuranceClaim = await prisma.insuranceClaim.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InsuranceClaims and only return the `id`
     * const insuranceClaimWithIdOnly = await prisma.insuranceClaim.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InsuranceClaimUpdateManyAndReturnArgs>(args: SelectSubset<T, InsuranceClaimUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsuranceClaimPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InsuranceClaim.
     * @param {InsuranceClaimUpsertArgs} args - Arguments to update or create a InsuranceClaim.
     * @example
     * // Update or create a InsuranceClaim
     * const insuranceClaim = await prisma.insuranceClaim.upsert({
     *   create: {
     *     // ... data to create a InsuranceClaim
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InsuranceClaim we want to update
     *   }
     * })
     */
    upsert<T extends InsuranceClaimUpsertArgs>(args: SelectSubset<T, InsuranceClaimUpsertArgs<ExtArgs>>): Prisma__InsuranceClaimClient<$Result.GetResult<Prisma.$InsuranceClaimPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InsuranceClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceClaimCountArgs} args - Arguments to filter InsuranceClaims to count.
     * @example
     * // Count the number of InsuranceClaims
     * const count = await prisma.insuranceClaim.count({
     *   where: {
     *     // ... the filter for the InsuranceClaims we want to count
     *   }
     * })
    **/
    count<T extends InsuranceClaimCountArgs>(
      args?: Subset<T, InsuranceClaimCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InsuranceClaimCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InsuranceClaim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceClaimAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InsuranceClaimAggregateArgs>(args: Subset<T, InsuranceClaimAggregateArgs>): Prisma.PrismaPromise<GetInsuranceClaimAggregateType<T>>

    /**
     * Group by InsuranceClaim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceClaimGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InsuranceClaimGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InsuranceClaimGroupByArgs['orderBy'] }
        : { orderBy?: InsuranceClaimGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InsuranceClaimGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInsuranceClaimGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InsuranceClaim model
   */
  readonly fields: InsuranceClaimFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InsuranceClaim.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InsuranceClaimClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contractor<T extends InsuranceClaim$contractorArgs<ExtArgs> = {}>(args?: Subset<T, InsuranceClaim$contractorArgs<ExtArgs>>): Prisma__ContractorCompanyClient<$Result.GetResult<Prisma.$ContractorCompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    workEvents<T extends InsuranceClaim$workEventsArgs<ExtArgs> = {}>(args?: Subset<T, InsuranceClaim$workEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InsuranceClaim model
   */
  interface InsuranceClaimFieldRefs {
    readonly id: FieldRef<"InsuranceClaim", 'String'>
    readonly propertyId: FieldRef<"InsuranceClaim", 'String'>
    readonly claimType: FieldRef<"InsuranceClaim", 'String'>
    readonly claimDate: FieldRef<"InsuranceClaim", 'DateTime'>
    readonly amount: FieldRef<"InsuranceClaim", 'Float'>
    readonly status: FieldRef<"InsuranceClaim", 'String'>
    readonly submittedBy: FieldRef<"InsuranceClaim", 'String'>
    readonly verificationStatus: FieldRef<"InsuranceClaim", 'String'>
    readonly documentUrl: FieldRef<"InsuranceClaim", 'String'>
    readonly contractorId: FieldRef<"InsuranceClaim", 'String'>
    readonly workDescription: FieldRef<"InsuranceClaim", 'String'>
    readonly createdAt: FieldRef<"InsuranceClaim", 'DateTime'>
    readonly updatedAt: FieldRef<"InsuranceClaim", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InsuranceClaim findUnique
   */
  export type InsuranceClaimFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceClaim
     */
    select?: InsuranceClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceClaim
     */
    omit?: InsuranceClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceClaimInclude<ExtArgs> | null
    /**
     * Filter, which InsuranceClaim to fetch.
     */
    where: InsuranceClaimWhereUniqueInput
  }

  /**
   * InsuranceClaim findUniqueOrThrow
   */
  export type InsuranceClaimFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceClaim
     */
    select?: InsuranceClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceClaim
     */
    omit?: InsuranceClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceClaimInclude<ExtArgs> | null
    /**
     * Filter, which InsuranceClaim to fetch.
     */
    where: InsuranceClaimWhereUniqueInput
  }

  /**
   * InsuranceClaim findFirst
   */
  export type InsuranceClaimFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceClaim
     */
    select?: InsuranceClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceClaim
     */
    omit?: InsuranceClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceClaimInclude<ExtArgs> | null
    /**
     * Filter, which InsuranceClaim to fetch.
     */
    where?: InsuranceClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsuranceClaims to fetch.
     */
    orderBy?: InsuranceClaimOrderByWithRelationInput | InsuranceClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InsuranceClaims.
     */
    cursor?: InsuranceClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsuranceClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsuranceClaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InsuranceClaims.
     */
    distinct?: InsuranceClaimScalarFieldEnum | InsuranceClaimScalarFieldEnum[]
  }

  /**
   * InsuranceClaim findFirstOrThrow
   */
  export type InsuranceClaimFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceClaim
     */
    select?: InsuranceClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceClaim
     */
    omit?: InsuranceClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceClaimInclude<ExtArgs> | null
    /**
     * Filter, which InsuranceClaim to fetch.
     */
    where?: InsuranceClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsuranceClaims to fetch.
     */
    orderBy?: InsuranceClaimOrderByWithRelationInput | InsuranceClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InsuranceClaims.
     */
    cursor?: InsuranceClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsuranceClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsuranceClaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InsuranceClaims.
     */
    distinct?: InsuranceClaimScalarFieldEnum | InsuranceClaimScalarFieldEnum[]
  }

  /**
   * InsuranceClaim findMany
   */
  export type InsuranceClaimFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceClaim
     */
    select?: InsuranceClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceClaim
     */
    omit?: InsuranceClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceClaimInclude<ExtArgs> | null
    /**
     * Filter, which InsuranceClaims to fetch.
     */
    where?: InsuranceClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsuranceClaims to fetch.
     */
    orderBy?: InsuranceClaimOrderByWithRelationInput | InsuranceClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InsuranceClaims.
     */
    cursor?: InsuranceClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsuranceClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsuranceClaims.
     */
    skip?: number
    distinct?: InsuranceClaimScalarFieldEnum | InsuranceClaimScalarFieldEnum[]
  }

  /**
   * InsuranceClaim create
   */
  export type InsuranceClaimCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceClaim
     */
    select?: InsuranceClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceClaim
     */
    omit?: InsuranceClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceClaimInclude<ExtArgs> | null
    /**
     * The data needed to create a InsuranceClaim.
     */
    data: XOR<InsuranceClaimCreateInput, InsuranceClaimUncheckedCreateInput>
  }

  /**
   * InsuranceClaim createMany
   */
  export type InsuranceClaimCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InsuranceClaims.
     */
    data: InsuranceClaimCreateManyInput | InsuranceClaimCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InsuranceClaim createManyAndReturn
   */
  export type InsuranceClaimCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceClaim
     */
    select?: InsuranceClaimSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceClaim
     */
    omit?: InsuranceClaimOmit<ExtArgs> | null
    /**
     * The data used to create many InsuranceClaims.
     */
    data: InsuranceClaimCreateManyInput | InsuranceClaimCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceClaimIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InsuranceClaim update
   */
  export type InsuranceClaimUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceClaim
     */
    select?: InsuranceClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceClaim
     */
    omit?: InsuranceClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceClaimInclude<ExtArgs> | null
    /**
     * The data needed to update a InsuranceClaim.
     */
    data: XOR<InsuranceClaimUpdateInput, InsuranceClaimUncheckedUpdateInput>
    /**
     * Choose, which InsuranceClaim to update.
     */
    where: InsuranceClaimWhereUniqueInput
  }

  /**
   * InsuranceClaim updateMany
   */
  export type InsuranceClaimUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InsuranceClaims.
     */
    data: XOR<InsuranceClaimUpdateManyMutationInput, InsuranceClaimUncheckedUpdateManyInput>
    /**
     * Filter which InsuranceClaims to update
     */
    where?: InsuranceClaimWhereInput
    /**
     * Limit how many InsuranceClaims to update.
     */
    limit?: number
  }

  /**
   * InsuranceClaim updateManyAndReturn
   */
  export type InsuranceClaimUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceClaim
     */
    select?: InsuranceClaimSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceClaim
     */
    omit?: InsuranceClaimOmit<ExtArgs> | null
    /**
     * The data used to update InsuranceClaims.
     */
    data: XOR<InsuranceClaimUpdateManyMutationInput, InsuranceClaimUncheckedUpdateManyInput>
    /**
     * Filter which InsuranceClaims to update
     */
    where?: InsuranceClaimWhereInput
    /**
     * Limit how many InsuranceClaims to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceClaimIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InsuranceClaim upsert
   */
  export type InsuranceClaimUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceClaim
     */
    select?: InsuranceClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceClaim
     */
    omit?: InsuranceClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceClaimInclude<ExtArgs> | null
    /**
     * The filter to search for the InsuranceClaim to update in case it exists.
     */
    where: InsuranceClaimWhereUniqueInput
    /**
     * In case the InsuranceClaim found by the `where` argument doesn't exist, create a new InsuranceClaim with this data.
     */
    create: XOR<InsuranceClaimCreateInput, InsuranceClaimUncheckedCreateInput>
    /**
     * In case the InsuranceClaim was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InsuranceClaimUpdateInput, InsuranceClaimUncheckedUpdateInput>
  }

  /**
   * InsuranceClaim delete
   */
  export type InsuranceClaimDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceClaim
     */
    select?: InsuranceClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceClaim
     */
    omit?: InsuranceClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceClaimInclude<ExtArgs> | null
    /**
     * Filter which InsuranceClaim to delete.
     */
    where: InsuranceClaimWhereUniqueInput
  }

  /**
   * InsuranceClaim deleteMany
   */
  export type InsuranceClaimDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InsuranceClaims to delete
     */
    where?: InsuranceClaimWhereInput
    /**
     * Limit how many InsuranceClaims to delete.
     */
    limit?: number
  }

  /**
   * InsuranceClaim.contractor
   */
  export type InsuranceClaim$contractorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractorCompany
     */
    select?: ContractorCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractorCompany
     */
    omit?: ContractorCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractorCompanyInclude<ExtArgs> | null
    where?: ContractorCompanyWhereInput
  }

  /**
   * InsuranceClaim.workEvents
   */
  export type InsuranceClaim$workEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkEvent
     */
    select?: WorkEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkEvent
     */
    omit?: WorkEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkEventInclude<ExtArgs> | null
    where?: WorkEventWhereInput
    orderBy?: WorkEventOrderByWithRelationInput | WorkEventOrderByWithRelationInput[]
    cursor?: WorkEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkEventScalarFieldEnum | WorkEventScalarFieldEnum[]
  }

  /**
   * InsuranceClaim without action
   */
  export type InsuranceClaimDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceClaim
     */
    select?: InsuranceClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceClaim
     */
    omit?: InsuranceClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceClaimInclude<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportAvgAggregateOutputType = {
    version: number | null
  }

  export type ReportSumAggregateOutputType = {
    version: number | null
  }

  export type ReportMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    version: number | null
    generatedAt: Date | null
    shareToken: string | null
    createdAt: Date | null
  }

  export type ReportMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    version: number | null
    generatedAt: Date | null
    shareToken: string | null
    createdAt: Date | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    propertyId: number
    version: number
    generatedAt: number
    snapshot: number
    shareToken: number
    createdAt: number
    _all: number
  }


  export type ReportAvgAggregateInputType = {
    version?: true
  }

  export type ReportSumAggregateInputType = {
    version?: true
  }

  export type ReportMinAggregateInputType = {
    id?: true
    propertyId?: true
    version?: true
    generatedAt?: true
    shareToken?: true
    createdAt?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    propertyId?: true
    version?: true
    generatedAt?: true
    shareToken?: true
    createdAt?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    propertyId?: true
    version?: true
    generatedAt?: true
    snapshot?: true
    shareToken?: true
    createdAt?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _avg?: ReportAvgAggregateInputType
    _sum?: ReportSumAggregateInputType
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: string
    propertyId: string
    version: number
    generatedAt: Date
    snapshot: JsonValue
    shareToken: string | null
    createdAt: Date
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    version?: boolean
    generatedAt?: boolean
    snapshot?: boolean
    shareToken?: boolean
    createdAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    version?: boolean
    generatedAt?: boolean
    snapshot?: boolean
    shareToken?: boolean
    createdAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    version?: boolean
    generatedAt?: boolean
    snapshot?: boolean
    shareToken?: boolean
    createdAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    id?: boolean
    propertyId?: boolean
    version?: boolean
    generatedAt?: boolean
    snapshot?: boolean
    shareToken?: boolean
    createdAt?: boolean
  }

  export type ReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "version" | "generatedAt" | "snapshot" | "shareToken" | "createdAt", ExtArgs["result"]["report"]>
  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type ReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type ReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      version: number
      generatedAt: Date
      snapshot: Prisma.JsonValue
      shareToken: string | null
      createdAt: Date
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportFindManyArgs>(args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends ReportCreateArgs>(args: SelectSubset<T, ReportCreateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCreateManyArgs>(args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reports and returns the data saved in the database.
     * @param {ReportCreateManyAndReturnArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends ReportDeleteArgs>(args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUpdateArgs>(args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDeleteManyArgs>(args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUpdateManyArgs>(args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports and returns the data updated in the database.
     * @param {ReportUpdateManyAndReturnArgs} args - Arguments to update many Reports.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Report model
   */
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'String'>
    readonly propertyId: FieldRef<"Report", 'String'>
    readonly version: FieldRef<"Report", 'Int'>
    readonly generatedAt: FieldRef<"Report", 'DateTime'>
    readonly snapshot: FieldRef<"Report", 'Json'>
    readonly shareToken: FieldRef<"Report", 'String'>
    readonly createdAt: FieldRef<"Report", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report createManyAndReturn
   */
  export type ReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to update.
     */
    limit?: number
  }

  /**
   * Report updateManyAndReturn
   */
  export type ReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to delete.
     */
    limit?: number
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    role: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      notifications: Prisma.$NotificationSubscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      role: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSubscription
     */
    select?: NotificationSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSubscription
     */
    omit?: NotificationSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSubscriptionInclude<ExtArgs> | null
    where?: NotificationSubscriptionWhereInput
    orderBy?: NotificationSubscriptionOrderByWithRelationInput | NotificationSubscriptionOrderByWithRelationInput[]
    cursor?: NotificationSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationSubscriptionScalarFieldEnum | NotificationSubscriptionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model NotificationSubscription
   */

  export type AggregateNotificationSubscription = {
    _count: NotificationSubscriptionCountAggregateOutputType | null
    _min: NotificationSubscriptionMinAggregateOutputType | null
    _max: NotificationSubscriptionMaxAggregateOutputType | null
  }

  export type NotificationSubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    propertyId: string | null
    eventType: string | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationSubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    propertyId: string | null
    eventType: string | null
    enabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationSubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    propertyId: number
    eventType: number
    enabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationSubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    propertyId?: true
    eventType?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationSubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    propertyId?: true
    eventType?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationSubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    propertyId?: true
    eventType?: true
    enabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationSubscription to aggregate.
     */
    where?: NotificationSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSubscriptions to fetch.
     */
    orderBy?: NotificationSubscriptionOrderByWithRelationInput | NotificationSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationSubscriptions
    **/
    _count?: true | NotificationSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationSubscriptionMaxAggregateInputType
  }

  export type GetNotificationSubscriptionAggregateType<T extends NotificationSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationSubscription[P]>
      : GetScalarType<T[P], AggregateNotificationSubscription[P]>
  }




  export type NotificationSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationSubscriptionWhereInput
    orderBy?: NotificationSubscriptionOrderByWithAggregationInput | NotificationSubscriptionOrderByWithAggregationInput[]
    by: NotificationSubscriptionScalarFieldEnum[] | NotificationSubscriptionScalarFieldEnum
    having?: NotificationSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationSubscriptionCountAggregateInputType | true
    _min?: NotificationSubscriptionMinAggregateInputType
    _max?: NotificationSubscriptionMaxAggregateInputType
  }

  export type NotificationSubscriptionGroupByOutputType = {
    id: string
    userId: string
    propertyId: string
    eventType: string
    enabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: NotificationSubscriptionCountAggregateOutputType | null
    _min: NotificationSubscriptionMinAggregateOutputType | null
    _max: NotificationSubscriptionMaxAggregateOutputType | null
  }

  type GetNotificationSubscriptionGroupByPayload<T extends NotificationSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    propertyId?: boolean
    eventType?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationSubscription"]>

  export type NotificationSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    propertyId?: boolean
    eventType?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationSubscription"]>

  export type NotificationSubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    propertyId?: boolean
    eventType?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationSubscription"]>

  export type NotificationSubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    propertyId?: boolean
    eventType?: boolean
    enabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationSubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "propertyId" | "eventType" | "enabled" | "createdAt" | "updatedAt", ExtArgs["result"]["notificationSubscription"]>
  export type NotificationSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type NotificationSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type NotificationSubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $NotificationSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationSubscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      propertyId: string
      eventType: string
      enabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationSubscription"]>
    composites: {}
  }

  type NotificationSubscriptionGetPayload<S extends boolean | null | undefined | NotificationSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$NotificationSubscriptionPayload, S>

  type NotificationSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationSubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationSubscriptionCountAggregateInputType | true
    }

  export interface NotificationSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationSubscription'], meta: { name: 'NotificationSubscription' } }
    /**
     * Find zero or one NotificationSubscription that matches the filter.
     * @param {NotificationSubscriptionFindUniqueArgs} args - Arguments to find a NotificationSubscription
     * @example
     * // Get one NotificationSubscription
     * const notificationSubscription = await prisma.notificationSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationSubscriptionFindUniqueArgs>(args: SelectSubset<T, NotificationSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__NotificationSubscriptionClient<$Result.GetResult<Prisma.$NotificationSubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationSubscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a NotificationSubscription
     * @example
     * // Get one NotificationSubscription
     * const notificationSubscription = await prisma.notificationSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationSubscriptionClient<$Result.GetResult<Prisma.$NotificationSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSubscriptionFindFirstArgs} args - Arguments to find a NotificationSubscription
     * @example
     * // Get one NotificationSubscription
     * const notificationSubscription = await prisma.notificationSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationSubscriptionFindFirstArgs>(args?: SelectSubset<T, NotificationSubscriptionFindFirstArgs<ExtArgs>>): Prisma__NotificationSubscriptionClient<$Result.GetResult<Prisma.$NotificationSubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSubscriptionFindFirstOrThrowArgs} args - Arguments to find a NotificationSubscription
     * @example
     * // Get one NotificationSubscription
     * const notificationSubscription = await prisma.notificationSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationSubscriptionClient<$Result.GetResult<Prisma.$NotificationSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationSubscriptions
     * const notificationSubscriptions = await prisma.notificationSubscription.findMany()
     * 
     * // Get first 10 NotificationSubscriptions
     * const notificationSubscriptions = await prisma.notificationSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationSubscriptionWithIdOnly = await prisma.notificationSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationSubscriptionFindManyArgs>(args?: SelectSubset<T, NotificationSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationSubscription.
     * @param {NotificationSubscriptionCreateArgs} args - Arguments to create a NotificationSubscription.
     * @example
     * // Create one NotificationSubscription
     * const NotificationSubscription = await prisma.notificationSubscription.create({
     *   data: {
     *     // ... data to create a NotificationSubscription
     *   }
     * })
     * 
     */
    create<T extends NotificationSubscriptionCreateArgs>(args: SelectSubset<T, NotificationSubscriptionCreateArgs<ExtArgs>>): Prisma__NotificationSubscriptionClient<$Result.GetResult<Prisma.$NotificationSubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationSubscriptions.
     * @param {NotificationSubscriptionCreateManyArgs} args - Arguments to create many NotificationSubscriptions.
     * @example
     * // Create many NotificationSubscriptions
     * const notificationSubscription = await prisma.notificationSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationSubscriptionCreateManyArgs>(args?: SelectSubset<T, NotificationSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationSubscriptions and returns the data saved in the database.
     * @param {NotificationSubscriptionCreateManyAndReturnArgs} args - Arguments to create many NotificationSubscriptions.
     * @example
     * // Create many NotificationSubscriptions
     * const notificationSubscription = await prisma.notificationSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationSubscriptions and only return the `id`
     * const notificationSubscriptionWithIdOnly = await prisma.notificationSubscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationSubscription.
     * @param {NotificationSubscriptionDeleteArgs} args - Arguments to delete one NotificationSubscription.
     * @example
     * // Delete one NotificationSubscription
     * const NotificationSubscription = await prisma.notificationSubscription.delete({
     *   where: {
     *     // ... filter to delete one NotificationSubscription
     *   }
     * })
     * 
     */
    delete<T extends NotificationSubscriptionDeleteArgs>(args: SelectSubset<T, NotificationSubscriptionDeleteArgs<ExtArgs>>): Prisma__NotificationSubscriptionClient<$Result.GetResult<Prisma.$NotificationSubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationSubscription.
     * @param {NotificationSubscriptionUpdateArgs} args - Arguments to update one NotificationSubscription.
     * @example
     * // Update one NotificationSubscription
     * const notificationSubscription = await prisma.notificationSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationSubscriptionUpdateArgs>(args: SelectSubset<T, NotificationSubscriptionUpdateArgs<ExtArgs>>): Prisma__NotificationSubscriptionClient<$Result.GetResult<Prisma.$NotificationSubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationSubscriptions.
     * @param {NotificationSubscriptionDeleteManyArgs} args - Arguments to filter NotificationSubscriptions to delete.
     * @example
     * // Delete a few NotificationSubscriptions
     * const { count } = await prisma.notificationSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationSubscriptionDeleteManyArgs>(args?: SelectSubset<T, NotificationSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationSubscriptions
     * const notificationSubscription = await prisma.notificationSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationSubscriptionUpdateManyArgs>(args: SelectSubset<T, NotificationSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationSubscriptions and returns the data updated in the database.
     * @param {NotificationSubscriptionUpdateManyAndReturnArgs} args - Arguments to update many NotificationSubscriptions.
     * @example
     * // Update many NotificationSubscriptions
     * const notificationSubscription = await prisma.notificationSubscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationSubscriptions and only return the `id`
     * const notificationSubscriptionWithIdOnly = await prisma.notificationSubscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationSubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationSubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationSubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationSubscription.
     * @param {NotificationSubscriptionUpsertArgs} args - Arguments to update or create a NotificationSubscription.
     * @example
     * // Update or create a NotificationSubscription
     * const notificationSubscription = await prisma.notificationSubscription.upsert({
     *   create: {
     *     // ... data to create a NotificationSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationSubscription we want to update
     *   }
     * })
     */
    upsert<T extends NotificationSubscriptionUpsertArgs>(args: SelectSubset<T, NotificationSubscriptionUpsertArgs<ExtArgs>>): Prisma__NotificationSubscriptionClient<$Result.GetResult<Prisma.$NotificationSubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSubscriptionCountArgs} args - Arguments to filter NotificationSubscriptions to count.
     * @example
     * // Count the number of NotificationSubscriptions
     * const count = await prisma.notificationSubscription.count({
     *   where: {
     *     // ... the filter for the NotificationSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends NotificationSubscriptionCountArgs>(
      args?: Subset<T, NotificationSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationSubscriptionAggregateArgs>(args: Subset<T, NotificationSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetNotificationSubscriptionAggregateType<T>>

    /**
     * Group by NotificationSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: NotificationSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationSubscription model
   */
  readonly fields: NotificationSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationSubscription model
   */
  interface NotificationSubscriptionFieldRefs {
    readonly id: FieldRef<"NotificationSubscription", 'String'>
    readonly userId: FieldRef<"NotificationSubscription", 'String'>
    readonly propertyId: FieldRef<"NotificationSubscription", 'String'>
    readonly eventType: FieldRef<"NotificationSubscription", 'String'>
    readonly enabled: FieldRef<"NotificationSubscription", 'Boolean'>
    readonly createdAt: FieldRef<"NotificationSubscription", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationSubscription findUnique
   */
  export type NotificationSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSubscription
     */
    select?: NotificationSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSubscription
     */
    omit?: NotificationSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSubscription to fetch.
     */
    where: NotificationSubscriptionWhereUniqueInput
  }

  /**
   * NotificationSubscription findUniqueOrThrow
   */
  export type NotificationSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSubscription
     */
    select?: NotificationSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSubscription
     */
    omit?: NotificationSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSubscription to fetch.
     */
    where: NotificationSubscriptionWhereUniqueInput
  }

  /**
   * NotificationSubscription findFirst
   */
  export type NotificationSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSubscription
     */
    select?: NotificationSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSubscription
     */
    omit?: NotificationSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSubscription to fetch.
     */
    where?: NotificationSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSubscriptions to fetch.
     */
    orderBy?: NotificationSubscriptionOrderByWithRelationInput | NotificationSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationSubscriptions.
     */
    cursor?: NotificationSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationSubscriptions.
     */
    distinct?: NotificationSubscriptionScalarFieldEnum | NotificationSubscriptionScalarFieldEnum[]
  }

  /**
   * NotificationSubscription findFirstOrThrow
   */
  export type NotificationSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSubscription
     */
    select?: NotificationSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSubscription
     */
    omit?: NotificationSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSubscription to fetch.
     */
    where?: NotificationSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSubscriptions to fetch.
     */
    orderBy?: NotificationSubscriptionOrderByWithRelationInput | NotificationSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationSubscriptions.
     */
    cursor?: NotificationSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationSubscriptions.
     */
    distinct?: NotificationSubscriptionScalarFieldEnum | NotificationSubscriptionScalarFieldEnum[]
  }

  /**
   * NotificationSubscription findMany
   */
  export type NotificationSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSubscription
     */
    select?: NotificationSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSubscription
     */
    omit?: NotificationSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which NotificationSubscriptions to fetch.
     */
    where?: NotificationSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationSubscriptions to fetch.
     */
    orderBy?: NotificationSubscriptionOrderByWithRelationInput | NotificationSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationSubscriptions.
     */
    cursor?: NotificationSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationSubscriptions.
     */
    skip?: number
    distinct?: NotificationSubscriptionScalarFieldEnum | NotificationSubscriptionScalarFieldEnum[]
  }

  /**
   * NotificationSubscription create
   */
  export type NotificationSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSubscription
     */
    select?: NotificationSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSubscription
     */
    omit?: NotificationSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationSubscription.
     */
    data: XOR<NotificationSubscriptionCreateInput, NotificationSubscriptionUncheckedCreateInput>
  }

  /**
   * NotificationSubscription createMany
   */
  export type NotificationSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationSubscriptions.
     */
    data: NotificationSubscriptionCreateManyInput | NotificationSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationSubscription createManyAndReturn
   */
  export type NotificationSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSubscription
     */
    select?: NotificationSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSubscription
     */
    omit?: NotificationSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationSubscriptions.
     */
    data: NotificationSubscriptionCreateManyInput | NotificationSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationSubscription update
   */
  export type NotificationSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSubscription
     */
    select?: NotificationSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSubscription
     */
    omit?: NotificationSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationSubscription.
     */
    data: XOR<NotificationSubscriptionUpdateInput, NotificationSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which NotificationSubscription to update.
     */
    where: NotificationSubscriptionWhereUniqueInput
  }

  /**
   * NotificationSubscription updateMany
   */
  export type NotificationSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationSubscriptions.
     */
    data: XOR<NotificationSubscriptionUpdateManyMutationInput, NotificationSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which NotificationSubscriptions to update
     */
    where?: NotificationSubscriptionWhereInput
    /**
     * Limit how many NotificationSubscriptions to update.
     */
    limit?: number
  }

  /**
   * NotificationSubscription updateManyAndReturn
   */
  export type NotificationSubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSubscription
     */
    select?: NotificationSubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSubscription
     */
    omit?: NotificationSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update NotificationSubscriptions.
     */
    data: XOR<NotificationSubscriptionUpdateManyMutationInput, NotificationSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which NotificationSubscriptions to update
     */
    where?: NotificationSubscriptionWhereInput
    /**
     * Limit how many NotificationSubscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationSubscription upsert
   */
  export type NotificationSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSubscription
     */
    select?: NotificationSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSubscription
     */
    omit?: NotificationSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationSubscription to update in case it exists.
     */
    where: NotificationSubscriptionWhereUniqueInput
    /**
     * In case the NotificationSubscription found by the `where` argument doesn't exist, create a new NotificationSubscription with this data.
     */
    create: XOR<NotificationSubscriptionCreateInput, NotificationSubscriptionUncheckedCreateInput>
    /**
     * In case the NotificationSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationSubscriptionUpdateInput, NotificationSubscriptionUncheckedUpdateInput>
  }

  /**
   * NotificationSubscription delete
   */
  export type NotificationSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSubscription
     */
    select?: NotificationSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSubscription
     */
    omit?: NotificationSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which NotificationSubscription to delete.
     */
    where: NotificationSubscriptionWhereUniqueInput
  }

  /**
   * NotificationSubscription deleteMany
   */
  export type NotificationSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationSubscriptions to delete
     */
    where?: NotificationSubscriptionWhereInput
    /**
     * Limit how many NotificationSubscriptions to delete.
     */
    limit?: number
  }

  /**
   * NotificationSubscription without action
   */
  export type NotificationSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationSubscription
     */
    select?: NotificationSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationSubscription
     */
    omit?: NotificationSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const PropertyScalarFieldEnum: {
    id: 'id',
    apn: 'apn',
    address: 'address',
    addressLine2: 'addressLine2',
    city: 'city',
    state: 'state',
    zipCode: 'zipCode',
    county: 'county',
    latitude: 'latitude',
    longitude: 'longitude',
    lotSize: 'lotSize',
    livingArea: 'livingArea',
    bedrooms: 'bedrooms',
    bathrooms: 'bathrooms',
    yearBuilt: 'yearBuilt',
    propertyType: 'propertyType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PropertyScalarFieldEnum = (typeof PropertyScalarFieldEnum)[keyof typeof PropertyScalarFieldEnum]


  export const SourceRecordScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    source: 'source',
    sourceId: 'sourceId',
    rawPayload: 'rawPayload',
    ingestedAt: 'ingestedAt',
    version: 'version'
  };

  export type SourceRecordScalarFieldEnum = (typeof SourceRecordScalarFieldEnum)[keyof typeof SourceRecordScalarFieldEnum]


  export const OwnershipEventScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    ownerName: 'ownerName',
    ownerType: 'ownerType',
    fromDate: 'fromDate',
    toDate: 'toDate',
    isCurrent: 'isCurrent',
    documentRef: 'documentRef',
    source: 'source',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OwnershipEventScalarFieldEnum = (typeof OwnershipEventScalarFieldEnum)[keyof typeof OwnershipEventScalarFieldEnum]


  export const SaleScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    saleDate: 'saleDate',
    salePrice: 'salePrice',
    saleType: 'saleType',
    buyerName: 'buyerName',
    sellerName: 'sellerName',
    documentRef: 'documentRef',
    source: 'source',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SaleScalarFieldEnum = (typeof SaleScalarFieldEnum)[keyof typeof SaleScalarFieldEnum]


  export const PermitScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    permitNumber: 'permitNumber',
    permitType: 'permitType',
    status: 'status',
    issuedDate: 'issuedDate',
    completedDate: 'completedDate',
    expirationDate: 'expirationDate',
    description: 'description',
    contractorName: 'contractorName',
    jurisdiction: 'jurisdiction',
    source: 'source',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PermitScalarFieldEnum = (typeof PermitScalarFieldEnum)[keyof typeof PermitScalarFieldEnum]


  export const ContractorCompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    licenseNumber: 'licenseNumber',
    licenseType: 'licenseType',
    state: 'state',
    verificationStatus: 'verificationStatus',
    phone: 'phone',
    email: 'email',
    website: 'website',
    address: 'address',
    rating: 'rating',
    totalJobs: 'totalJobs',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContractorCompanyScalarFieldEnum = (typeof ContractorCompanyScalarFieldEnum)[keyof typeof ContractorCompanyScalarFieldEnum]


  export const WorkEventScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    contractorId: 'contractorId',
    workType: 'workType',
    description: 'description',
    workDate: 'workDate',
    cost: 'cost',
    invoiceNumber: 'invoiceNumber',
    documentUrl: 'documentUrl',
    verificationStatus: 'verificationStatus',
    warrantyPeriodMonths: 'warrantyPeriodMonths',
    warrantyExpirationDate: 'warrantyExpirationDate',
    warrantyType: 'warrantyType',
    warrantyDetails: 'warrantyDetails',
    insuranceClaimId: 'insuranceClaimId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkEventScalarFieldEnum = (typeof WorkEventScalarFieldEnum)[keyof typeof WorkEventScalarFieldEnum]


  export const RentalSignalScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    source: 'source',
    startDate: 'startDate',
    endDate: 'endDate',
    confidence: 'confidence',
    evidence: 'evidence',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RentalSignalScalarFieldEnum = (typeof RentalSignalScalarFieldEnum)[keyof typeof RentalSignalScalarFieldEnum]


  export const InsuranceClaimScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    claimType: 'claimType',
    claimDate: 'claimDate',
    amount: 'amount',
    status: 'status',
    submittedBy: 'submittedBy',
    verificationStatus: 'verificationStatus',
    documentUrl: 'documentUrl',
    contractorId: 'contractorId',
    workDescription: 'workDescription',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InsuranceClaimScalarFieldEnum = (typeof InsuranceClaimScalarFieldEnum)[keyof typeof InsuranceClaimScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    version: 'version',
    generatedAt: 'generatedAt',
    snapshot: 'snapshot',
    shareToken: 'shareToken',
    createdAt: 'createdAt'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const NotificationSubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    propertyId: 'propertyId',
    eventType: 'eventType',
    enabled: 'enabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationSubscriptionScalarFieldEnum = (typeof NotificationSubscriptionScalarFieldEnum)[keyof typeof NotificationSubscriptionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type PropertyWhereInput = {
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    id?: StringFilter<"Property"> | string
    apn?: StringNullableFilter<"Property"> | string | null
    address?: StringFilter<"Property"> | string
    addressLine2?: StringNullableFilter<"Property"> | string | null
    city?: StringFilter<"Property"> | string
    state?: StringFilter<"Property"> | string
    zipCode?: StringFilter<"Property"> | string
    county?: StringFilter<"Property"> | string
    latitude?: FloatNullableFilter<"Property"> | number | null
    longitude?: FloatNullableFilter<"Property"> | number | null
    lotSize?: FloatNullableFilter<"Property"> | number | null
    livingArea?: FloatNullableFilter<"Property"> | number | null
    bedrooms?: IntNullableFilter<"Property"> | number | null
    bathrooms?: FloatNullableFilter<"Property"> | number | null
    yearBuilt?: IntNullableFilter<"Property"> | number | null
    propertyType?: StringNullableFilter<"Property"> | string | null
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    sourceRecords?: SourceRecordListRelationFilter
    ownershipEvents?: OwnershipEventListRelationFilter
    sales?: SaleListRelationFilter
    permits?: PermitListRelationFilter
    workEvents?: WorkEventListRelationFilter
    rentalSignals?: RentalSignalListRelationFilter
    insuranceClaims?: InsuranceClaimListRelationFilter
    reports?: ReportListRelationFilter
    notifications?: NotificationSubscriptionListRelationFilter
  }

  export type PropertyOrderByWithRelationInput = {
    id?: SortOrder
    apn?: SortOrderInput | SortOrder
    address?: SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    county?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    lotSize?: SortOrderInput | SortOrder
    livingArea?: SortOrderInput | SortOrder
    bedrooms?: SortOrderInput | SortOrder
    bathrooms?: SortOrderInput | SortOrder
    yearBuilt?: SortOrderInput | SortOrder
    propertyType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sourceRecords?: SourceRecordOrderByRelationAggregateInput
    ownershipEvents?: OwnershipEventOrderByRelationAggregateInput
    sales?: SaleOrderByRelationAggregateInput
    permits?: PermitOrderByRelationAggregateInput
    workEvents?: WorkEventOrderByRelationAggregateInput
    rentalSignals?: RentalSignalOrderByRelationAggregateInput
    insuranceClaims?: InsuranceClaimOrderByRelationAggregateInput
    reports?: ReportOrderByRelationAggregateInput
    notifications?: NotificationSubscriptionOrderByRelationAggregateInput
  }

  export type PropertyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    apn?: string
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    address?: StringFilter<"Property"> | string
    addressLine2?: StringNullableFilter<"Property"> | string | null
    city?: StringFilter<"Property"> | string
    state?: StringFilter<"Property"> | string
    zipCode?: StringFilter<"Property"> | string
    county?: StringFilter<"Property"> | string
    latitude?: FloatNullableFilter<"Property"> | number | null
    longitude?: FloatNullableFilter<"Property"> | number | null
    lotSize?: FloatNullableFilter<"Property"> | number | null
    livingArea?: FloatNullableFilter<"Property"> | number | null
    bedrooms?: IntNullableFilter<"Property"> | number | null
    bathrooms?: FloatNullableFilter<"Property"> | number | null
    yearBuilt?: IntNullableFilter<"Property"> | number | null
    propertyType?: StringNullableFilter<"Property"> | string | null
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    sourceRecords?: SourceRecordListRelationFilter
    ownershipEvents?: OwnershipEventListRelationFilter
    sales?: SaleListRelationFilter
    permits?: PermitListRelationFilter
    workEvents?: WorkEventListRelationFilter
    rentalSignals?: RentalSignalListRelationFilter
    insuranceClaims?: InsuranceClaimListRelationFilter
    reports?: ReportListRelationFilter
    notifications?: NotificationSubscriptionListRelationFilter
  }, "id" | "apn">

  export type PropertyOrderByWithAggregationInput = {
    id?: SortOrder
    apn?: SortOrderInput | SortOrder
    address?: SortOrder
    addressLine2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    county?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    lotSize?: SortOrderInput | SortOrder
    livingArea?: SortOrderInput | SortOrder
    bedrooms?: SortOrderInput | SortOrder
    bathrooms?: SortOrderInput | SortOrder
    yearBuilt?: SortOrderInput | SortOrder
    propertyType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PropertyCountOrderByAggregateInput
    _avg?: PropertyAvgOrderByAggregateInput
    _max?: PropertyMaxOrderByAggregateInput
    _min?: PropertyMinOrderByAggregateInput
    _sum?: PropertySumOrderByAggregateInput
  }

  export type PropertyScalarWhereWithAggregatesInput = {
    AND?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    OR?: PropertyScalarWhereWithAggregatesInput[]
    NOT?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Property"> | string
    apn?: StringNullableWithAggregatesFilter<"Property"> | string | null
    address?: StringWithAggregatesFilter<"Property"> | string
    addressLine2?: StringNullableWithAggregatesFilter<"Property"> | string | null
    city?: StringWithAggregatesFilter<"Property"> | string
    state?: StringWithAggregatesFilter<"Property"> | string
    zipCode?: StringWithAggregatesFilter<"Property"> | string
    county?: StringWithAggregatesFilter<"Property"> | string
    latitude?: FloatNullableWithAggregatesFilter<"Property"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Property"> | number | null
    lotSize?: FloatNullableWithAggregatesFilter<"Property"> | number | null
    livingArea?: FloatNullableWithAggregatesFilter<"Property"> | number | null
    bedrooms?: IntNullableWithAggregatesFilter<"Property"> | number | null
    bathrooms?: FloatNullableWithAggregatesFilter<"Property"> | number | null
    yearBuilt?: IntNullableWithAggregatesFilter<"Property"> | number | null
    propertyType?: StringNullableWithAggregatesFilter<"Property"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Property"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Property"> | Date | string
  }

  export type SourceRecordWhereInput = {
    AND?: SourceRecordWhereInput | SourceRecordWhereInput[]
    OR?: SourceRecordWhereInput[]
    NOT?: SourceRecordWhereInput | SourceRecordWhereInput[]
    id?: StringFilter<"SourceRecord"> | string
    propertyId?: StringFilter<"SourceRecord"> | string
    source?: StringFilter<"SourceRecord"> | string
    sourceId?: StringNullableFilter<"SourceRecord"> | string | null
    rawPayload?: JsonNullableFilter<"SourceRecord">
    ingestedAt?: DateTimeFilter<"SourceRecord"> | Date | string
    version?: IntFilter<"SourceRecord"> | number
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type SourceRecordOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    source?: SortOrder
    sourceId?: SortOrderInput | SortOrder
    rawPayload?: SortOrderInput | SortOrder
    ingestedAt?: SortOrder
    version?: SortOrder
    property?: PropertyOrderByWithRelationInput
  }

  export type SourceRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SourceRecordWhereInput | SourceRecordWhereInput[]
    OR?: SourceRecordWhereInput[]
    NOT?: SourceRecordWhereInput | SourceRecordWhereInput[]
    propertyId?: StringFilter<"SourceRecord"> | string
    source?: StringFilter<"SourceRecord"> | string
    sourceId?: StringNullableFilter<"SourceRecord"> | string | null
    rawPayload?: JsonNullableFilter<"SourceRecord">
    ingestedAt?: DateTimeFilter<"SourceRecord"> | Date | string
    version?: IntFilter<"SourceRecord"> | number
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id">

  export type SourceRecordOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    source?: SortOrder
    sourceId?: SortOrderInput | SortOrder
    rawPayload?: SortOrderInput | SortOrder
    ingestedAt?: SortOrder
    version?: SortOrder
    _count?: SourceRecordCountOrderByAggregateInput
    _avg?: SourceRecordAvgOrderByAggregateInput
    _max?: SourceRecordMaxOrderByAggregateInput
    _min?: SourceRecordMinOrderByAggregateInput
    _sum?: SourceRecordSumOrderByAggregateInput
  }

  export type SourceRecordScalarWhereWithAggregatesInput = {
    AND?: SourceRecordScalarWhereWithAggregatesInput | SourceRecordScalarWhereWithAggregatesInput[]
    OR?: SourceRecordScalarWhereWithAggregatesInput[]
    NOT?: SourceRecordScalarWhereWithAggregatesInput | SourceRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SourceRecord"> | string
    propertyId?: StringWithAggregatesFilter<"SourceRecord"> | string
    source?: StringWithAggregatesFilter<"SourceRecord"> | string
    sourceId?: StringNullableWithAggregatesFilter<"SourceRecord"> | string | null
    rawPayload?: JsonNullableWithAggregatesFilter<"SourceRecord">
    ingestedAt?: DateTimeWithAggregatesFilter<"SourceRecord"> | Date | string
    version?: IntWithAggregatesFilter<"SourceRecord"> | number
  }

  export type OwnershipEventWhereInput = {
    AND?: OwnershipEventWhereInput | OwnershipEventWhereInput[]
    OR?: OwnershipEventWhereInput[]
    NOT?: OwnershipEventWhereInput | OwnershipEventWhereInput[]
    id?: StringFilter<"OwnershipEvent"> | string
    propertyId?: StringFilter<"OwnershipEvent"> | string
    ownerName?: StringFilter<"OwnershipEvent"> | string
    ownerType?: StringNullableFilter<"OwnershipEvent"> | string | null
    fromDate?: DateTimeFilter<"OwnershipEvent"> | Date | string
    toDate?: DateTimeNullableFilter<"OwnershipEvent"> | Date | string | null
    isCurrent?: BoolFilter<"OwnershipEvent"> | boolean
    documentRef?: StringNullableFilter<"OwnershipEvent"> | string | null
    source?: StringFilter<"OwnershipEvent"> | string
    createdAt?: DateTimeFilter<"OwnershipEvent"> | Date | string
    updatedAt?: DateTimeFilter<"OwnershipEvent"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type OwnershipEventOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    ownerName?: SortOrder
    ownerType?: SortOrderInput | SortOrder
    fromDate?: SortOrder
    toDate?: SortOrderInput | SortOrder
    isCurrent?: SortOrder
    documentRef?: SortOrderInput | SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
  }

  export type OwnershipEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OwnershipEventWhereInput | OwnershipEventWhereInput[]
    OR?: OwnershipEventWhereInput[]
    NOT?: OwnershipEventWhereInput | OwnershipEventWhereInput[]
    propertyId?: StringFilter<"OwnershipEvent"> | string
    ownerName?: StringFilter<"OwnershipEvent"> | string
    ownerType?: StringNullableFilter<"OwnershipEvent"> | string | null
    fromDate?: DateTimeFilter<"OwnershipEvent"> | Date | string
    toDate?: DateTimeNullableFilter<"OwnershipEvent"> | Date | string | null
    isCurrent?: BoolFilter<"OwnershipEvent"> | boolean
    documentRef?: StringNullableFilter<"OwnershipEvent"> | string | null
    source?: StringFilter<"OwnershipEvent"> | string
    createdAt?: DateTimeFilter<"OwnershipEvent"> | Date | string
    updatedAt?: DateTimeFilter<"OwnershipEvent"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id">

  export type OwnershipEventOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    ownerName?: SortOrder
    ownerType?: SortOrderInput | SortOrder
    fromDate?: SortOrder
    toDate?: SortOrderInput | SortOrder
    isCurrent?: SortOrder
    documentRef?: SortOrderInput | SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OwnershipEventCountOrderByAggregateInput
    _max?: OwnershipEventMaxOrderByAggregateInput
    _min?: OwnershipEventMinOrderByAggregateInput
  }

  export type OwnershipEventScalarWhereWithAggregatesInput = {
    AND?: OwnershipEventScalarWhereWithAggregatesInput | OwnershipEventScalarWhereWithAggregatesInput[]
    OR?: OwnershipEventScalarWhereWithAggregatesInput[]
    NOT?: OwnershipEventScalarWhereWithAggregatesInput | OwnershipEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OwnershipEvent"> | string
    propertyId?: StringWithAggregatesFilter<"OwnershipEvent"> | string
    ownerName?: StringWithAggregatesFilter<"OwnershipEvent"> | string
    ownerType?: StringNullableWithAggregatesFilter<"OwnershipEvent"> | string | null
    fromDate?: DateTimeWithAggregatesFilter<"OwnershipEvent"> | Date | string
    toDate?: DateTimeNullableWithAggregatesFilter<"OwnershipEvent"> | Date | string | null
    isCurrent?: BoolWithAggregatesFilter<"OwnershipEvent"> | boolean
    documentRef?: StringNullableWithAggregatesFilter<"OwnershipEvent"> | string | null
    source?: StringWithAggregatesFilter<"OwnershipEvent"> | string
    createdAt?: DateTimeWithAggregatesFilter<"OwnershipEvent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OwnershipEvent"> | Date | string
  }

  export type SaleWhereInput = {
    AND?: SaleWhereInput | SaleWhereInput[]
    OR?: SaleWhereInput[]
    NOT?: SaleWhereInput | SaleWhereInput[]
    id?: StringFilter<"Sale"> | string
    propertyId?: StringFilter<"Sale"> | string
    saleDate?: DateTimeFilter<"Sale"> | Date | string
    salePrice?: FloatFilter<"Sale"> | number
    saleType?: StringNullableFilter<"Sale"> | string | null
    buyerName?: StringNullableFilter<"Sale"> | string | null
    sellerName?: StringNullableFilter<"Sale"> | string | null
    documentRef?: StringNullableFilter<"Sale"> | string | null
    source?: StringFilter<"Sale"> | string
    createdAt?: DateTimeFilter<"Sale"> | Date | string
    updatedAt?: DateTimeFilter<"Sale"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type SaleOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    saleDate?: SortOrder
    salePrice?: SortOrder
    saleType?: SortOrderInput | SortOrder
    buyerName?: SortOrderInput | SortOrder
    sellerName?: SortOrderInput | SortOrder
    documentRef?: SortOrderInput | SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
  }

  export type SaleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SaleWhereInput | SaleWhereInput[]
    OR?: SaleWhereInput[]
    NOT?: SaleWhereInput | SaleWhereInput[]
    propertyId?: StringFilter<"Sale"> | string
    saleDate?: DateTimeFilter<"Sale"> | Date | string
    salePrice?: FloatFilter<"Sale"> | number
    saleType?: StringNullableFilter<"Sale"> | string | null
    buyerName?: StringNullableFilter<"Sale"> | string | null
    sellerName?: StringNullableFilter<"Sale"> | string | null
    documentRef?: StringNullableFilter<"Sale"> | string | null
    source?: StringFilter<"Sale"> | string
    createdAt?: DateTimeFilter<"Sale"> | Date | string
    updatedAt?: DateTimeFilter<"Sale"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id">

  export type SaleOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    saleDate?: SortOrder
    salePrice?: SortOrder
    saleType?: SortOrderInput | SortOrder
    buyerName?: SortOrderInput | SortOrder
    sellerName?: SortOrderInput | SortOrder
    documentRef?: SortOrderInput | SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SaleCountOrderByAggregateInput
    _avg?: SaleAvgOrderByAggregateInput
    _max?: SaleMaxOrderByAggregateInput
    _min?: SaleMinOrderByAggregateInput
    _sum?: SaleSumOrderByAggregateInput
  }

  export type SaleScalarWhereWithAggregatesInput = {
    AND?: SaleScalarWhereWithAggregatesInput | SaleScalarWhereWithAggregatesInput[]
    OR?: SaleScalarWhereWithAggregatesInput[]
    NOT?: SaleScalarWhereWithAggregatesInput | SaleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sale"> | string
    propertyId?: StringWithAggregatesFilter<"Sale"> | string
    saleDate?: DateTimeWithAggregatesFilter<"Sale"> | Date | string
    salePrice?: FloatWithAggregatesFilter<"Sale"> | number
    saleType?: StringNullableWithAggregatesFilter<"Sale"> | string | null
    buyerName?: StringNullableWithAggregatesFilter<"Sale"> | string | null
    sellerName?: StringNullableWithAggregatesFilter<"Sale"> | string | null
    documentRef?: StringNullableWithAggregatesFilter<"Sale"> | string | null
    source?: StringWithAggregatesFilter<"Sale"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Sale"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Sale"> | Date | string
  }

  export type PermitWhereInput = {
    AND?: PermitWhereInput | PermitWhereInput[]
    OR?: PermitWhereInput[]
    NOT?: PermitWhereInput | PermitWhereInput[]
    id?: StringFilter<"Permit"> | string
    propertyId?: StringFilter<"Permit"> | string
    permitNumber?: StringFilter<"Permit"> | string
    permitType?: StringFilter<"Permit"> | string
    status?: StringFilter<"Permit"> | string
    issuedDate?: DateTimeNullableFilter<"Permit"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"Permit"> | Date | string | null
    expirationDate?: DateTimeNullableFilter<"Permit"> | Date | string | null
    description?: StringNullableFilter<"Permit"> | string | null
    contractorName?: StringNullableFilter<"Permit"> | string | null
    jurisdiction?: StringFilter<"Permit"> | string
    source?: StringFilter<"Permit"> | string
    createdAt?: DateTimeFilter<"Permit"> | Date | string
    updatedAt?: DateTimeFilter<"Permit"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type PermitOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    permitNumber?: SortOrder
    permitType?: SortOrder
    status?: SortOrder
    issuedDate?: SortOrderInput | SortOrder
    completedDate?: SortOrderInput | SortOrder
    expirationDate?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    contractorName?: SortOrderInput | SortOrder
    jurisdiction?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
  }

  export type PermitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PermitWhereInput | PermitWhereInput[]
    OR?: PermitWhereInput[]
    NOT?: PermitWhereInput | PermitWhereInput[]
    propertyId?: StringFilter<"Permit"> | string
    permitNumber?: StringFilter<"Permit"> | string
    permitType?: StringFilter<"Permit"> | string
    status?: StringFilter<"Permit"> | string
    issuedDate?: DateTimeNullableFilter<"Permit"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"Permit"> | Date | string | null
    expirationDate?: DateTimeNullableFilter<"Permit"> | Date | string | null
    description?: StringNullableFilter<"Permit"> | string | null
    contractorName?: StringNullableFilter<"Permit"> | string | null
    jurisdiction?: StringFilter<"Permit"> | string
    source?: StringFilter<"Permit"> | string
    createdAt?: DateTimeFilter<"Permit"> | Date | string
    updatedAt?: DateTimeFilter<"Permit"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id">

  export type PermitOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    permitNumber?: SortOrder
    permitType?: SortOrder
    status?: SortOrder
    issuedDate?: SortOrderInput | SortOrder
    completedDate?: SortOrderInput | SortOrder
    expirationDate?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    contractorName?: SortOrderInput | SortOrder
    jurisdiction?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PermitCountOrderByAggregateInput
    _max?: PermitMaxOrderByAggregateInput
    _min?: PermitMinOrderByAggregateInput
  }

  export type PermitScalarWhereWithAggregatesInput = {
    AND?: PermitScalarWhereWithAggregatesInput | PermitScalarWhereWithAggregatesInput[]
    OR?: PermitScalarWhereWithAggregatesInput[]
    NOT?: PermitScalarWhereWithAggregatesInput | PermitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Permit"> | string
    propertyId?: StringWithAggregatesFilter<"Permit"> | string
    permitNumber?: StringWithAggregatesFilter<"Permit"> | string
    permitType?: StringWithAggregatesFilter<"Permit"> | string
    status?: StringWithAggregatesFilter<"Permit"> | string
    issuedDate?: DateTimeNullableWithAggregatesFilter<"Permit"> | Date | string | null
    completedDate?: DateTimeNullableWithAggregatesFilter<"Permit"> | Date | string | null
    expirationDate?: DateTimeNullableWithAggregatesFilter<"Permit"> | Date | string | null
    description?: StringNullableWithAggregatesFilter<"Permit"> | string | null
    contractorName?: StringNullableWithAggregatesFilter<"Permit"> | string | null
    jurisdiction?: StringWithAggregatesFilter<"Permit"> | string
    source?: StringWithAggregatesFilter<"Permit"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Permit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Permit"> | Date | string
  }

  export type ContractorCompanyWhereInput = {
    AND?: ContractorCompanyWhereInput | ContractorCompanyWhereInput[]
    OR?: ContractorCompanyWhereInput[]
    NOT?: ContractorCompanyWhereInput | ContractorCompanyWhereInput[]
    id?: StringFilter<"ContractorCompany"> | string
    name?: StringFilter<"ContractorCompany"> | string
    licenseNumber?: StringNullableFilter<"ContractorCompany"> | string | null
    licenseType?: StringNullableFilter<"ContractorCompany"> | string | null
    state?: StringFilter<"ContractorCompany"> | string
    verificationStatus?: StringFilter<"ContractorCompany"> | string
    phone?: StringNullableFilter<"ContractorCompany"> | string | null
    email?: StringNullableFilter<"ContractorCompany"> | string | null
    website?: StringNullableFilter<"ContractorCompany"> | string | null
    address?: StringNullableFilter<"ContractorCompany"> | string | null
    rating?: FloatNullableFilter<"ContractorCompany"> | number | null
    totalJobs?: IntFilter<"ContractorCompany"> | number
    createdAt?: DateTimeFilter<"ContractorCompany"> | Date | string
    updatedAt?: DateTimeFilter<"ContractorCompany"> | Date | string
    workEvents?: WorkEventListRelationFilter
    insuranceClaims?: InsuranceClaimListRelationFilter
  }

  export type ContractorCompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    licenseNumber?: SortOrderInput | SortOrder
    licenseType?: SortOrderInput | SortOrder
    state?: SortOrder
    verificationStatus?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    totalJobs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workEvents?: WorkEventOrderByRelationAggregateInput
    insuranceClaims?: InsuranceClaimOrderByRelationAggregateInput
  }

  export type ContractorCompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContractorCompanyWhereInput | ContractorCompanyWhereInput[]
    OR?: ContractorCompanyWhereInput[]
    NOT?: ContractorCompanyWhereInput | ContractorCompanyWhereInput[]
    name?: StringFilter<"ContractorCompany"> | string
    licenseNumber?: StringNullableFilter<"ContractorCompany"> | string | null
    licenseType?: StringNullableFilter<"ContractorCompany"> | string | null
    state?: StringFilter<"ContractorCompany"> | string
    verificationStatus?: StringFilter<"ContractorCompany"> | string
    phone?: StringNullableFilter<"ContractorCompany"> | string | null
    email?: StringNullableFilter<"ContractorCompany"> | string | null
    website?: StringNullableFilter<"ContractorCompany"> | string | null
    address?: StringNullableFilter<"ContractorCompany"> | string | null
    rating?: FloatNullableFilter<"ContractorCompany"> | number | null
    totalJobs?: IntFilter<"ContractorCompany"> | number
    createdAt?: DateTimeFilter<"ContractorCompany"> | Date | string
    updatedAt?: DateTimeFilter<"ContractorCompany"> | Date | string
    workEvents?: WorkEventListRelationFilter
    insuranceClaims?: InsuranceClaimListRelationFilter
  }, "id">

  export type ContractorCompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    licenseNumber?: SortOrderInput | SortOrder
    licenseType?: SortOrderInput | SortOrder
    state?: SortOrder
    verificationStatus?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    totalJobs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContractorCompanyCountOrderByAggregateInput
    _avg?: ContractorCompanyAvgOrderByAggregateInput
    _max?: ContractorCompanyMaxOrderByAggregateInput
    _min?: ContractorCompanyMinOrderByAggregateInput
    _sum?: ContractorCompanySumOrderByAggregateInput
  }

  export type ContractorCompanyScalarWhereWithAggregatesInput = {
    AND?: ContractorCompanyScalarWhereWithAggregatesInput | ContractorCompanyScalarWhereWithAggregatesInput[]
    OR?: ContractorCompanyScalarWhereWithAggregatesInput[]
    NOT?: ContractorCompanyScalarWhereWithAggregatesInput | ContractorCompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContractorCompany"> | string
    name?: StringWithAggregatesFilter<"ContractorCompany"> | string
    licenseNumber?: StringNullableWithAggregatesFilter<"ContractorCompany"> | string | null
    licenseType?: StringNullableWithAggregatesFilter<"ContractorCompany"> | string | null
    state?: StringWithAggregatesFilter<"ContractorCompany"> | string
    verificationStatus?: StringWithAggregatesFilter<"ContractorCompany"> | string
    phone?: StringNullableWithAggregatesFilter<"ContractorCompany"> | string | null
    email?: StringNullableWithAggregatesFilter<"ContractorCompany"> | string | null
    website?: StringNullableWithAggregatesFilter<"ContractorCompany"> | string | null
    address?: StringNullableWithAggregatesFilter<"ContractorCompany"> | string | null
    rating?: FloatNullableWithAggregatesFilter<"ContractorCompany"> | number | null
    totalJobs?: IntWithAggregatesFilter<"ContractorCompany"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ContractorCompany"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContractorCompany"> | Date | string
  }

  export type WorkEventWhereInput = {
    AND?: WorkEventWhereInput | WorkEventWhereInput[]
    OR?: WorkEventWhereInput[]
    NOT?: WorkEventWhereInput | WorkEventWhereInput[]
    id?: StringFilter<"WorkEvent"> | string
    propertyId?: StringFilter<"WorkEvent"> | string
    contractorId?: StringNullableFilter<"WorkEvent"> | string | null
    workType?: StringFilter<"WorkEvent"> | string
    description?: StringNullableFilter<"WorkEvent"> | string | null
    workDate?: DateTimeFilter<"WorkEvent"> | Date | string
    cost?: FloatNullableFilter<"WorkEvent"> | number | null
    invoiceNumber?: StringNullableFilter<"WorkEvent"> | string | null
    documentUrl?: StringNullableFilter<"WorkEvent"> | string | null
    verificationStatus?: StringFilter<"WorkEvent"> | string
    warrantyPeriodMonths?: IntNullableFilter<"WorkEvent"> | number | null
    warrantyExpirationDate?: DateTimeNullableFilter<"WorkEvent"> | Date | string | null
    warrantyType?: StringNullableFilter<"WorkEvent"> | string | null
    warrantyDetails?: StringNullableFilter<"WorkEvent"> | string | null
    insuranceClaimId?: StringNullableFilter<"WorkEvent"> | string | null
    createdAt?: DateTimeFilter<"WorkEvent"> | Date | string
    updatedAt?: DateTimeFilter<"WorkEvent"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    contractor?: XOR<ContractorCompanyNullableScalarRelationFilter, ContractorCompanyWhereInput> | null
    insuranceClaim?: XOR<InsuranceClaimNullableScalarRelationFilter, InsuranceClaimWhereInput> | null
  }

  export type WorkEventOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    contractorId?: SortOrderInput | SortOrder
    workType?: SortOrder
    description?: SortOrderInput | SortOrder
    workDate?: SortOrder
    cost?: SortOrderInput | SortOrder
    invoiceNumber?: SortOrderInput | SortOrder
    documentUrl?: SortOrderInput | SortOrder
    verificationStatus?: SortOrder
    warrantyPeriodMonths?: SortOrderInput | SortOrder
    warrantyExpirationDate?: SortOrderInput | SortOrder
    warrantyType?: SortOrderInput | SortOrder
    warrantyDetails?: SortOrderInput | SortOrder
    insuranceClaimId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
    contractor?: ContractorCompanyOrderByWithRelationInput
    insuranceClaim?: InsuranceClaimOrderByWithRelationInput
  }

  export type WorkEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkEventWhereInput | WorkEventWhereInput[]
    OR?: WorkEventWhereInput[]
    NOT?: WorkEventWhereInput | WorkEventWhereInput[]
    propertyId?: StringFilter<"WorkEvent"> | string
    contractorId?: StringNullableFilter<"WorkEvent"> | string | null
    workType?: StringFilter<"WorkEvent"> | string
    description?: StringNullableFilter<"WorkEvent"> | string | null
    workDate?: DateTimeFilter<"WorkEvent"> | Date | string
    cost?: FloatNullableFilter<"WorkEvent"> | number | null
    invoiceNumber?: StringNullableFilter<"WorkEvent"> | string | null
    documentUrl?: StringNullableFilter<"WorkEvent"> | string | null
    verificationStatus?: StringFilter<"WorkEvent"> | string
    warrantyPeriodMonths?: IntNullableFilter<"WorkEvent"> | number | null
    warrantyExpirationDate?: DateTimeNullableFilter<"WorkEvent"> | Date | string | null
    warrantyType?: StringNullableFilter<"WorkEvent"> | string | null
    warrantyDetails?: StringNullableFilter<"WorkEvent"> | string | null
    insuranceClaimId?: StringNullableFilter<"WorkEvent"> | string | null
    createdAt?: DateTimeFilter<"WorkEvent"> | Date | string
    updatedAt?: DateTimeFilter<"WorkEvent"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    contractor?: XOR<ContractorCompanyNullableScalarRelationFilter, ContractorCompanyWhereInput> | null
    insuranceClaim?: XOR<InsuranceClaimNullableScalarRelationFilter, InsuranceClaimWhereInput> | null
  }, "id">

  export type WorkEventOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    contractorId?: SortOrderInput | SortOrder
    workType?: SortOrder
    description?: SortOrderInput | SortOrder
    workDate?: SortOrder
    cost?: SortOrderInput | SortOrder
    invoiceNumber?: SortOrderInput | SortOrder
    documentUrl?: SortOrderInput | SortOrder
    verificationStatus?: SortOrder
    warrantyPeriodMonths?: SortOrderInput | SortOrder
    warrantyExpirationDate?: SortOrderInput | SortOrder
    warrantyType?: SortOrderInput | SortOrder
    warrantyDetails?: SortOrderInput | SortOrder
    insuranceClaimId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkEventCountOrderByAggregateInput
    _avg?: WorkEventAvgOrderByAggregateInput
    _max?: WorkEventMaxOrderByAggregateInput
    _min?: WorkEventMinOrderByAggregateInput
    _sum?: WorkEventSumOrderByAggregateInput
  }

  export type WorkEventScalarWhereWithAggregatesInput = {
    AND?: WorkEventScalarWhereWithAggregatesInput | WorkEventScalarWhereWithAggregatesInput[]
    OR?: WorkEventScalarWhereWithAggregatesInput[]
    NOT?: WorkEventScalarWhereWithAggregatesInput | WorkEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkEvent"> | string
    propertyId?: StringWithAggregatesFilter<"WorkEvent"> | string
    contractorId?: StringNullableWithAggregatesFilter<"WorkEvent"> | string | null
    workType?: StringWithAggregatesFilter<"WorkEvent"> | string
    description?: StringNullableWithAggregatesFilter<"WorkEvent"> | string | null
    workDate?: DateTimeWithAggregatesFilter<"WorkEvent"> | Date | string
    cost?: FloatNullableWithAggregatesFilter<"WorkEvent"> | number | null
    invoiceNumber?: StringNullableWithAggregatesFilter<"WorkEvent"> | string | null
    documentUrl?: StringNullableWithAggregatesFilter<"WorkEvent"> | string | null
    verificationStatus?: StringWithAggregatesFilter<"WorkEvent"> | string
    warrantyPeriodMonths?: IntNullableWithAggregatesFilter<"WorkEvent"> | number | null
    warrantyExpirationDate?: DateTimeNullableWithAggregatesFilter<"WorkEvent"> | Date | string | null
    warrantyType?: StringNullableWithAggregatesFilter<"WorkEvent"> | string | null
    warrantyDetails?: StringNullableWithAggregatesFilter<"WorkEvent"> | string | null
    insuranceClaimId?: StringNullableWithAggregatesFilter<"WorkEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WorkEvent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WorkEvent"> | Date | string
  }

  export type RentalSignalWhereInput = {
    AND?: RentalSignalWhereInput | RentalSignalWhereInput[]
    OR?: RentalSignalWhereInput[]
    NOT?: RentalSignalWhereInput | RentalSignalWhereInput[]
    id?: StringFilter<"RentalSignal"> | string
    propertyId?: StringFilter<"RentalSignal"> | string
    source?: StringFilter<"RentalSignal"> | string
    startDate?: DateTimeNullableFilter<"RentalSignal"> | Date | string | null
    endDate?: DateTimeNullableFilter<"RentalSignal"> | Date | string | null
    confidence?: FloatFilter<"RentalSignal"> | number
    evidence?: JsonNullableFilter<"RentalSignal">
    createdAt?: DateTimeFilter<"RentalSignal"> | Date | string
    updatedAt?: DateTimeFilter<"RentalSignal"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type RentalSignalOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    source?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    confidence?: SortOrder
    evidence?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
  }

  export type RentalSignalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RentalSignalWhereInput | RentalSignalWhereInput[]
    OR?: RentalSignalWhereInput[]
    NOT?: RentalSignalWhereInput | RentalSignalWhereInput[]
    propertyId?: StringFilter<"RentalSignal"> | string
    source?: StringFilter<"RentalSignal"> | string
    startDate?: DateTimeNullableFilter<"RentalSignal"> | Date | string | null
    endDate?: DateTimeNullableFilter<"RentalSignal"> | Date | string | null
    confidence?: FloatFilter<"RentalSignal"> | number
    evidence?: JsonNullableFilter<"RentalSignal">
    createdAt?: DateTimeFilter<"RentalSignal"> | Date | string
    updatedAt?: DateTimeFilter<"RentalSignal"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id">

  export type RentalSignalOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    source?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    confidence?: SortOrder
    evidence?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RentalSignalCountOrderByAggregateInput
    _avg?: RentalSignalAvgOrderByAggregateInput
    _max?: RentalSignalMaxOrderByAggregateInput
    _min?: RentalSignalMinOrderByAggregateInput
    _sum?: RentalSignalSumOrderByAggregateInput
  }

  export type RentalSignalScalarWhereWithAggregatesInput = {
    AND?: RentalSignalScalarWhereWithAggregatesInput | RentalSignalScalarWhereWithAggregatesInput[]
    OR?: RentalSignalScalarWhereWithAggregatesInput[]
    NOT?: RentalSignalScalarWhereWithAggregatesInput | RentalSignalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RentalSignal"> | string
    propertyId?: StringWithAggregatesFilter<"RentalSignal"> | string
    source?: StringWithAggregatesFilter<"RentalSignal"> | string
    startDate?: DateTimeNullableWithAggregatesFilter<"RentalSignal"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"RentalSignal"> | Date | string | null
    confidence?: FloatWithAggregatesFilter<"RentalSignal"> | number
    evidence?: JsonNullableWithAggregatesFilter<"RentalSignal">
    createdAt?: DateTimeWithAggregatesFilter<"RentalSignal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RentalSignal"> | Date | string
  }

  export type InsuranceClaimWhereInput = {
    AND?: InsuranceClaimWhereInput | InsuranceClaimWhereInput[]
    OR?: InsuranceClaimWhereInput[]
    NOT?: InsuranceClaimWhereInput | InsuranceClaimWhereInput[]
    id?: StringFilter<"InsuranceClaim"> | string
    propertyId?: StringFilter<"InsuranceClaim"> | string
    claimType?: StringFilter<"InsuranceClaim"> | string
    claimDate?: DateTimeFilter<"InsuranceClaim"> | Date | string
    amount?: FloatNullableFilter<"InsuranceClaim"> | number | null
    status?: StringNullableFilter<"InsuranceClaim"> | string | null
    submittedBy?: StringNullableFilter<"InsuranceClaim"> | string | null
    verificationStatus?: StringFilter<"InsuranceClaim"> | string
    documentUrl?: StringNullableFilter<"InsuranceClaim"> | string | null
    contractorId?: StringNullableFilter<"InsuranceClaim"> | string | null
    workDescription?: StringNullableFilter<"InsuranceClaim"> | string | null
    createdAt?: DateTimeFilter<"InsuranceClaim"> | Date | string
    updatedAt?: DateTimeFilter<"InsuranceClaim"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    contractor?: XOR<ContractorCompanyNullableScalarRelationFilter, ContractorCompanyWhereInput> | null
    workEvents?: WorkEventListRelationFilter
  }

  export type InsuranceClaimOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    claimType?: SortOrder
    claimDate?: SortOrder
    amount?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    submittedBy?: SortOrderInput | SortOrder
    verificationStatus?: SortOrder
    documentUrl?: SortOrderInput | SortOrder
    contractorId?: SortOrderInput | SortOrder
    workDescription?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
    contractor?: ContractorCompanyOrderByWithRelationInput
    workEvents?: WorkEventOrderByRelationAggregateInput
  }

  export type InsuranceClaimWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InsuranceClaimWhereInput | InsuranceClaimWhereInput[]
    OR?: InsuranceClaimWhereInput[]
    NOT?: InsuranceClaimWhereInput | InsuranceClaimWhereInput[]
    propertyId?: StringFilter<"InsuranceClaim"> | string
    claimType?: StringFilter<"InsuranceClaim"> | string
    claimDate?: DateTimeFilter<"InsuranceClaim"> | Date | string
    amount?: FloatNullableFilter<"InsuranceClaim"> | number | null
    status?: StringNullableFilter<"InsuranceClaim"> | string | null
    submittedBy?: StringNullableFilter<"InsuranceClaim"> | string | null
    verificationStatus?: StringFilter<"InsuranceClaim"> | string
    documentUrl?: StringNullableFilter<"InsuranceClaim"> | string | null
    contractorId?: StringNullableFilter<"InsuranceClaim"> | string | null
    workDescription?: StringNullableFilter<"InsuranceClaim"> | string | null
    createdAt?: DateTimeFilter<"InsuranceClaim"> | Date | string
    updatedAt?: DateTimeFilter<"InsuranceClaim"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    contractor?: XOR<ContractorCompanyNullableScalarRelationFilter, ContractorCompanyWhereInput> | null
    workEvents?: WorkEventListRelationFilter
  }, "id">

  export type InsuranceClaimOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    claimType?: SortOrder
    claimDate?: SortOrder
    amount?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    submittedBy?: SortOrderInput | SortOrder
    verificationStatus?: SortOrder
    documentUrl?: SortOrderInput | SortOrder
    contractorId?: SortOrderInput | SortOrder
    workDescription?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InsuranceClaimCountOrderByAggregateInput
    _avg?: InsuranceClaimAvgOrderByAggregateInput
    _max?: InsuranceClaimMaxOrderByAggregateInput
    _min?: InsuranceClaimMinOrderByAggregateInput
    _sum?: InsuranceClaimSumOrderByAggregateInput
  }

  export type InsuranceClaimScalarWhereWithAggregatesInput = {
    AND?: InsuranceClaimScalarWhereWithAggregatesInput | InsuranceClaimScalarWhereWithAggregatesInput[]
    OR?: InsuranceClaimScalarWhereWithAggregatesInput[]
    NOT?: InsuranceClaimScalarWhereWithAggregatesInput | InsuranceClaimScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InsuranceClaim"> | string
    propertyId?: StringWithAggregatesFilter<"InsuranceClaim"> | string
    claimType?: StringWithAggregatesFilter<"InsuranceClaim"> | string
    claimDate?: DateTimeWithAggregatesFilter<"InsuranceClaim"> | Date | string
    amount?: FloatNullableWithAggregatesFilter<"InsuranceClaim"> | number | null
    status?: StringNullableWithAggregatesFilter<"InsuranceClaim"> | string | null
    submittedBy?: StringNullableWithAggregatesFilter<"InsuranceClaim"> | string | null
    verificationStatus?: StringWithAggregatesFilter<"InsuranceClaim"> | string
    documentUrl?: StringNullableWithAggregatesFilter<"InsuranceClaim"> | string | null
    contractorId?: StringNullableWithAggregatesFilter<"InsuranceClaim"> | string | null
    workDescription?: StringNullableWithAggregatesFilter<"InsuranceClaim"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InsuranceClaim"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InsuranceClaim"> | Date | string
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: StringFilter<"Report"> | string
    propertyId?: StringFilter<"Report"> | string
    version?: IntFilter<"Report"> | number
    generatedAt?: DateTimeFilter<"Report"> | Date | string
    snapshot?: JsonFilter<"Report">
    shareToken?: StringNullableFilter<"Report"> | string | null
    createdAt?: DateTimeFilter<"Report"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    version?: SortOrder
    generatedAt?: SortOrder
    snapshot?: SortOrder
    shareToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    shareToken?: string
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    propertyId?: StringFilter<"Report"> | string
    version?: IntFilter<"Report"> | number
    generatedAt?: DateTimeFilter<"Report"> | Date | string
    snapshot?: JsonFilter<"Report">
    createdAt?: DateTimeFilter<"Report"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id" | "shareToken">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    version?: SortOrder
    generatedAt?: SortOrder
    snapshot?: SortOrder
    shareToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ReportCountOrderByAggregateInput
    _avg?: ReportAvgOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
    _sum?: ReportSumOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Report"> | string
    propertyId?: StringWithAggregatesFilter<"Report"> | string
    version?: IntWithAggregatesFilter<"Report"> | number
    generatedAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    snapshot?: JsonWithAggregatesFilter<"Report">
    shareToken?: StringNullableWithAggregatesFilter<"Report"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    notifications?: NotificationSubscriptionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notifications?: NotificationSubscriptionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    notifications?: NotificationSubscriptionListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type NotificationSubscriptionWhereInput = {
    AND?: NotificationSubscriptionWhereInput | NotificationSubscriptionWhereInput[]
    OR?: NotificationSubscriptionWhereInput[]
    NOT?: NotificationSubscriptionWhereInput | NotificationSubscriptionWhereInput[]
    id?: StringFilter<"NotificationSubscription"> | string
    userId?: StringFilter<"NotificationSubscription"> | string
    propertyId?: StringFilter<"NotificationSubscription"> | string
    eventType?: StringFilter<"NotificationSubscription"> | string
    enabled?: BoolFilter<"NotificationSubscription"> | boolean
    createdAt?: DateTimeFilter<"NotificationSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationSubscription"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type NotificationSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
    eventType?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    property?: PropertyOrderByWithRelationInput
  }

  export type NotificationSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_propertyId_eventType?: NotificationSubscriptionUserIdPropertyIdEventTypeCompoundUniqueInput
    AND?: NotificationSubscriptionWhereInput | NotificationSubscriptionWhereInput[]
    OR?: NotificationSubscriptionWhereInput[]
    NOT?: NotificationSubscriptionWhereInput | NotificationSubscriptionWhereInput[]
    userId?: StringFilter<"NotificationSubscription"> | string
    propertyId?: StringFilter<"NotificationSubscription"> | string
    eventType?: StringFilter<"NotificationSubscription"> | string
    enabled?: BoolFilter<"NotificationSubscription"> | boolean
    createdAt?: DateTimeFilter<"NotificationSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationSubscription"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id" | "userId_propertyId_eventType">

  export type NotificationSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
    eventType?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationSubscriptionCountOrderByAggregateInput
    _max?: NotificationSubscriptionMaxOrderByAggregateInput
    _min?: NotificationSubscriptionMinOrderByAggregateInput
  }

  export type NotificationSubscriptionScalarWhereWithAggregatesInput = {
    AND?: NotificationSubscriptionScalarWhereWithAggregatesInput | NotificationSubscriptionScalarWhereWithAggregatesInput[]
    OR?: NotificationSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: NotificationSubscriptionScalarWhereWithAggregatesInput | NotificationSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationSubscription"> | string
    userId?: StringWithAggregatesFilter<"NotificationSubscription"> | string
    propertyId?: StringWithAggregatesFilter<"NotificationSubscription"> | string
    eventType?: StringWithAggregatesFilter<"NotificationSubscription"> | string
    enabled?: BoolWithAggregatesFilter<"NotificationSubscription"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"NotificationSubscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationSubscription"> | Date | string
  }

  export type PropertyCreateInput = {
    id?: string
    apn?: string | null
    address: string
    addressLine2?: string | null
    city: string
    state?: string
    zipCode: string
    county?: string
    latitude?: number | null
    longitude?: number | null
    lotSize?: number | null
    livingArea?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    propertyType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceRecords?: SourceRecordCreateNestedManyWithoutPropertyInput
    ownershipEvents?: OwnershipEventCreateNestedManyWithoutPropertyInput
    sales?: SaleCreateNestedManyWithoutPropertyInput
    permits?: PermitCreateNestedManyWithoutPropertyInput
    workEvents?: WorkEventCreateNestedManyWithoutPropertyInput
    rentalSignals?: RentalSignalCreateNestedManyWithoutPropertyInput
    insuranceClaims?: InsuranceClaimCreateNestedManyWithoutPropertyInput
    reports?: ReportCreateNestedManyWithoutPropertyInput
    notifications?: NotificationSubscriptionCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateInput = {
    id?: string
    apn?: string | null
    address: string
    addressLine2?: string | null
    city: string
    state?: string
    zipCode: string
    county?: string
    latitude?: number | null
    longitude?: number | null
    lotSize?: number | null
    livingArea?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    propertyType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceRecords?: SourceRecordUncheckedCreateNestedManyWithoutPropertyInput
    ownershipEvents?: OwnershipEventUncheckedCreateNestedManyWithoutPropertyInput
    sales?: SaleUncheckedCreateNestedManyWithoutPropertyInput
    permits?: PermitUncheckedCreateNestedManyWithoutPropertyInput
    workEvents?: WorkEventUncheckedCreateNestedManyWithoutPropertyInput
    rentalSignals?: RentalSignalUncheckedCreateNestedManyWithoutPropertyInput
    insuranceClaims?: InsuranceClaimUncheckedCreateNestedManyWithoutPropertyInput
    reports?: ReportUncheckedCreateNestedManyWithoutPropertyInput
    notifications?: NotificationSubscriptionUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    apn?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    livingArea?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceRecords?: SourceRecordUpdateManyWithoutPropertyNestedInput
    ownershipEvents?: OwnershipEventUpdateManyWithoutPropertyNestedInput
    sales?: SaleUpdateManyWithoutPropertyNestedInput
    permits?: PermitUpdateManyWithoutPropertyNestedInput
    workEvents?: WorkEventUpdateManyWithoutPropertyNestedInput
    rentalSignals?: RentalSignalUpdateManyWithoutPropertyNestedInput
    insuranceClaims?: InsuranceClaimUpdateManyWithoutPropertyNestedInput
    reports?: ReportUpdateManyWithoutPropertyNestedInput
    notifications?: NotificationSubscriptionUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    apn?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    livingArea?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceRecords?: SourceRecordUncheckedUpdateManyWithoutPropertyNestedInput
    ownershipEvents?: OwnershipEventUncheckedUpdateManyWithoutPropertyNestedInput
    sales?: SaleUncheckedUpdateManyWithoutPropertyNestedInput
    permits?: PermitUncheckedUpdateManyWithoutPropertyNestedInput
    workEvents?: WorkEventUncheckedUpdateManyWithoutPropertyNestedInput
    rentalSignals?: RentalSignalUncheckedUpdateManyWithoutPropertyNestedInput
    insuranceClaims?: InsuranceClaimUncheckedUpdateManyWithoutPropertyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutPropertyNestedInput
    notifications?: NotificationSubscriptionUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateManyInput = {
    id?: string
    apn?: string | null
    address: string
    addressLine2?: string | null
    city: string
    state?: string
    zipCode: string
    county?: string
    latitude?: number | null
    longitude?: number | null
    lotSize?: number | null
    livingArea?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    propertyType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    apn?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    livingArea?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    apn?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    livingArea?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SourceRecordCreateInput = {
    id?: string
    source: string
    sourceId?: string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    ingestedAt?: Date | string
    version?: number
    property: PropertyCreateNestedOneWithoutSourceRecordsInput
  }

  export type SourceRecordUncheckedCreateInput = {
    id?: string
    propertyId: string
    source: string
    sourceId?: string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    ingestedAt?: Date | string
    version?: number
  }

  export type SourceRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    ingestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
    property?: PropertyUpdateOneRequiredWithoutSourceRecordsNestedInput
  }

  export type SourceRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    ingestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
  }

  export type SourceRecordCreateManyInput = {
    id?: string
    propertyId: string
    source: string
    sourceId?: string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    ingestedAt?: Date | string
    version?: number
  }

  export type SourceRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    ingestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
  }

  export type SourceRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    ingestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
  }

  export type OwnershipEventCreateInput = {
    id?: string
    ownerName: string
    ownerType?: string | null
    fromDate: Date | string
    toDate?: Date | string | null
    isCurrent?: boolean
    documentRef?: string | null
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutOwnershipEventsInput
  }

  export type OwnershipEventUncheckedCreateInput = {
    id?: string
    propertyId: string
    ownerName: string
    ownerType?: string | null
    fromDate: Date | string
    toDate?: Date | string | null
    isCurrent?: boolean
    documentRef?: string | null
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OwnershipEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerName?: StringFieldUpdateOperationsInput | string
    ownerType?: NullableStringFieldUpdateOperationsInput | string | null
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    documentRef?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutOwnershipEventsNestedInput
  }

  export type OwnershipEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    ownerName?: StringFieldUpdateOperationsInput | string
    ownerType?: NullableStringFieldUpdateOperationsInput | string | null
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    documentRef?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnershipEventCreateManyInput = {
    id?: string
    propertyId: string
    ownerName: string
    ownerType?: string | null
    fromDate: Date | string
    toDate?: Date | string | null
    isCurrent?: boolean
    documentRef?: string | null
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OwnershipEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerName?: StringFieldUpdateOperationsInput | string
    ownerType?: NullableStringFieldUpdateOperationsInput | string | null
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    documentRef?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnershipEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    ownerName?: StringFieldUpdateOperationsInput | string
    ownerType?: NullableStringFieldUpdateOperationsInput | string | null
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    documentRef?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleCreateInput = {
    id?: string
    saleDate: Date | string
    salePrice: number
    saleType?: string | null
    buyerName?: string | null
    sellerName?: string | null
    documentRef?: string | null
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutSalesInput
  }

  export type SaleUncheckedCreateInput = {
    id?: string
    propertyId: string
    saleDate: Date | string
    salePrice: number
    saleType?: string | null
    buyerName?: string | null
    sellerName?: string | null
    documentRef?: string | null
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salePrice?: FloatFieldUpdateOperationsInput | number
    saleType?: NullableStringFieldUpdateOperationsInput | string | null
    buyerName?: NullableStringFieldUpdateOperationsInput | string | null
    sellerName?: NullableStringFieldUpdateOperationsInput | string | null
    documentRef?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutSalesNestedInput
  }

  export type SaleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salePrice?: FloatFieldUpdateOperationsInput | number
    saleType?: NullableStringFieldUpdateOperationsInput | string | null
    buyerName?: NullableStringFieldUpdateOperationsInput | string | null
    sellerName?: NullableStringFieldUpdateOperationsInput | string | null
    documentRef?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleCreateManyInput = {
    id?: string
    propertyId: string
    saleDate: Date | string
    salePrice: number
    saleType?: string | null
    buyerName?: string | null
    sellerName?: string | null
    documentRef?: string | null
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salePrice?: FloatFieldUpdateOperationsInput | number
    saleType?: NullableStringFieldUpdateOperationsInput | string | null
    buyerName?: NullableStringFieldUpdateOperationsInput | string | null
    sellerName?: NullableStringFieldUpdateOperationsInput | string | null
    documentRef?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salePrice?: FloatFieldUpdateOperationsInput | number
    saleType?: NullableStringFieldUpdateOperationsInput | string | null
    buyerName?: NullableStringFieldUpdateOperationsInput | string | null
    sellerName?: NullableStringFieldUpdateOperationsInput | string | null
    documentRef?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermitCreateInput = {
    id?: string
    permitNumber: string
    permitType: string
    status: string
    issuedDate?: Date | string | null
    completedDate?: Date | string | null
    expirationDate?: Date | string | null
    description?: string | null
    contractorName?: string | null
    jurisdiction: string
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutPermitsInput
  }

  export type PermitUncheckedCreateInput = {
    id?: string
    propertyId: string
    permitNumber: string
    permitType: string
    status: string
    issuedDate?: Date | string | null
    completedDate?: Date | string | null
    expirationDate?: Date | string | null
    description?: string | null
    contractorName?: string | null
    jurisdiction: string
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    permitNumber?: StringFieldUpdateOperationsInput | string
    permitType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contractorName?: NullableStringFieldUpdateOperationsInput | string | null
    jurisdiction?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutPermitsNestedInput
  }

  export type PermitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    permitNumber?: StringFieldUpdateOperationsInput | string
    permitType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contractorName?: NullableStringFieldUpdateOperationsInput | string | null
    jurisdiction?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermitCreateManyInput = {
    id?: string
    propertyId: string
    permitNumber: string
    permitType: string
    status: string
    issuedDate?: Date | string | null
    completedDate?: Date | string | null
    expirationDate?: Date | string | null
    description?: string | null
    contractorName?: string | null
    jurisdiction: string
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    permitNumber?: StringFieldUpdateOperationsInput | string
    permitType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contractorName?: NullableStringFieldUpdateOperationsInput | string | null
    jurisdiction?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    permitNumber?: StringFieldUpdateOperationsInput | string
    permitType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contractorName?: NullableStringFieldUpdateOperationsInput | string | null
    jurisdiction?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractorCompanyCreateInput = {
    id?: string
    name: string
    licenseNumber?: string | null
    licenseType?: string | null
    state?: string
    verificationStatus?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    address?: string | null
    rating?: number | null
    totalJobs?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workEvents?: WorkEventCreateNestedManyWithoutContractorInput
    insuranceClaims?: InsuranceClaimCreateNestedManyWithoutContractorInput
  }

  export type ContractorCompanyUncheckedCreateInput = {
    id?: string
    name: string
    licenseNumber?: string | null
    licenseType?: string | null
    state?: string
    verificationStatus?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    address?: string | null
    rating?: number | null
    totalJobs?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workEvents?: WorkEventUncheckedCreateNestedManyWithoutContractorInput
    insuranceClaims?: InsuranceClaimUncheckedCreateNestedManyWithoutContractorInput
  }

  export type ContractorCompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseType?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    verificationStatus?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalJobs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workEvents?: WorkEventUpdateManyWithoutContractorNestedInput
    insuranceClaims?: InsuranceClaimUpdateManyWithoutContractorNestedInput
  }

  export type ContractorCompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseType?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    verificationStatus?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalJobs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workEvents?: WorkEventUncheckedUpdateManyWithoutContractorNestedInput
    insuranceClaims?: InsuranceClaimUncheckedUpdateManyWithoutContractorNestedInput
  }

  export type ContractorCompanyCreateManyInput = {
    id?: string
    name: string
    licenseNumber?: string | null
    licenseType?: string | null
    state?: string
    verificationStatus?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    address?: string | null
    rating?: number | null
    totalJobs?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractorCompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseType?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    verificationStatus?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalJobs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractorCompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseType?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    verificationStatus?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalJobs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkEventCreateInput = {
    id?: string
    workType: string
    description?: string | null
    workDate: Date | string
    cost?: number | null
    invoiceNumber?: string | null
    documentUrl?: string | null
    verificationStatus?: string
    warrantyPeriodMonths?: number | null
    warrantyExpirationDate?: Date | string | null
    warrantyType?: string | null
    warrantyDetails?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutWorkEventsInput
    contractor?: ContractorCompanyCreateNestedOneWithoutWorkEventsInput
    insuranceClaim?: InsuranceClaimCreateNestedOneWithoutWorkEventsInput
  }

  export type WorkEventUncheckedCreateInput = {
    id?: string
    propertyId: string
    contractorId?: string | null
    workType: string
    description?: string | null
    workDate: Date | string
    cost?: number | null
    invoiceNumber?: string | null
    documentUrl?: string | null
    verificationStatus?: string
    warrantyPeriodMonths?: number | null
    warrantyExpirationDate?: Date | string | null
    warrantyType?: string | null
    warrantyDetails?: string | null
    insuranceClaimId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    workDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    warrantyPeriodMonths?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyExpirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyType?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyDetails?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutWorkEventsNestedInput
    contractor?: ContractorCompanyUpdateOneWithoutWorkEventsNestedInput
    insuranceClaim?: InsuranceClaimUpdateOneWithoutWorkEventsNestedInput
  }

  export type WorkEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    contractorId?: NullableStringFieldUpdateOperationsInput | string | null
    workType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    workDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    warrantyPeriodMonths?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyExpirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyType?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyDetails?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceClaimId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkEventCreateManyInput = {
    id?: string
    propertyId: string
    contractorId?: string | null
    workType: string
    description?: string | null
    workDate: Date | string
    cost?: number | null
    invoiceNumber?: string | null
    documentUrl?: string | null
    verificationStatus?: string
    warrantyPeriodMonths?: number | null
    warrantyExpirationDate?: Date | string | null
    warrantyType?: string | null
    warrantyDetails?: string | null
    insuranceClaimId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    workType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    workDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    warrantyPeriodMonths?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyExpirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyType?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyDetails?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    contractorId?: NullableStringFieldUpdateOperationsInput | string | null
    workType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    workDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    warrantyPeriodMonths?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyExpirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyType?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyDetails?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceClaimId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RentalSignalCreateInput = {
    id?: string
    source: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    confidence?: number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutRentalSignalsInput
  }

  export type RentalSignalUncheckedCreateInput = {
    id?: string
    propertyId: string
    source: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    confidence?: number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RentalSignalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confidence?: FloatFieldUpdateOperationsInput | number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutRentalSignalsNestedInput
  }

  export type RentalSignalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confidence?: FloatFieldUpdateOperationsInput | number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RentalSignalCreateManyInput = {
    id?: string
    propertyId: string
    source: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    confidence?: number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RentalSignalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confidence?: FloatFieldUpdateOperationsInput | number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RentalSignalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confidence?: FloatFieldUpdateOperationsInput | number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsuranceClaimCreateInput = {
    id?: string
    claimType: string
    claimDate: Date | string
    amount?: number | null
    status?: string | null
    submittedBy?: string | null
    verificationStatus?: string
    documentUrl?: string | null
    workDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutInsuranceClaimsInput
    contractor?: ContractorCompanyCreateNestedOneWithoutInsuranceClaimsInput
    workEvents?: WorkEventCreateNestedManyWithoutInsuranceClaimInput
  }

  export type InsuranceClaimUncheckedCreateInput = {
    id?: string
    propertyId: string
    claimType: string
    claimDate: Date | string
    amount?: number | null
    status?: string | null
    submittedBy?: string | null
    verificationStatus?: string
    documentUrl?: string | null
    contractorId?: string | null
    workDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workEvents?: WorkEventUncheckedCreateNestedManyWithoutInsuranceClaimInput
  }

  export type InsuranceClaimUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    claimType?: StringFieldUpdateOperationsInput | string
    claimDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutInsuranceClaimsNestedInput
    contractor?: ContractorCompanyUpdateOneWithoutInsuranceClaimsNestedInput
    workEvents?: WorkEventUpdateManyWithoutInsuranceClaimNestedInput
  }

  export type InsuranceClaimUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    claimType?: StringFieldUpdateOperationsInput | string
    claimDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contractorId?: NullableStringFieldUpdateOperationsInput | string | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workEvents?: WorkEventUncheckedUpdateManyWithoutInsuranceClaimNestedInput
  }

  export type InsuranceClaimCreateManyInput = {
    id?: string
    propertyId: string
    claimType: string
    claimDate: Date | string
    amount?: number | null
    status?: string | null
    submittedBy?: string | null
    verificationStatus?: string
    documentUrl?: string | null
    contractorId?: string | null
    workDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InsuranceClaimUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    claimType?: StringFieldUpdateOperationsInput | string
    claimDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsuranceClaimUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    claimType?: StringFieldUpdateOperationsInput | string
    claimDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contractorId?: NullableStringFieldUpdateOperationsInput | string | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateInput = {
    id?: string
    version?: number
    generatedAt?: Date | string
    snapshot: JsonNullValueInput | InputJsonValue
    shareToken?: string | null
    createdAt?: Date | string
    property: PropertyCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateInput = {
    id?: string
    propertyId: string
    version?: number
    generatedAt?: Date | string
    snapshot: JsonNullValueInput | InputJsonValue
    shareToken?: string | null
    createdAt?: Date | string
  }

  export type ReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshot?: JsonNullValueInput | InputJsonValue
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshot?: JsonNullValueInput | InputJsonValue
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateManyInput = {
    id?: string
    propertyId: string
    version?: number
    generatedAt?: Date | string
    snapshot: JsonNullValueInput | InputJsonValue
    shareToken?: string | null
    createdAt?: Date | string
  }

  export type ReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshot?: JsonNullValueInput | InputJsonValue
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshot?: JsonNullValueInput | InputJsonValue
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationSubscriptionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationSubscriptionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationSubscriptionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationSubscriptionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSubscriptionCreateInput = {
    id?: string
    eventType: string
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
    property: PropertyCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationSubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    propertyId: string
    eventType: string
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    property?: PropertyUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSubscriptionCreateManyInput = {
    id?: string
    userId: string
    propertyId: string
    eventType: string
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SourceRecordListRelationFilter = {
    every?: SourceRecordWhereInput
    some?: SourceRecordWhereInput
    none?: SourceRecordWhereInput
  }

  export type OwnershipEventListRelationFilter = {
    every?: OwnershipEventWhereInput
    some?: OwnershipEventWhereInput
    none?: OwnershipEventWhereInput
  }

  export type SaleListRelationFilter = {
    every?: SaleWhereInput
    some?: SaleWhereInput
    none?: SaleWhereInput
  }

  export type PermitListRelationFilter = {
    every?: PermitWhereInput
    some?: PermitWhereInput
    none?: PermitWhereInput
  }

  export type WorkEventListRelationFilter = {
    every?: WorkEventWhereInput
    some?: WorkEventWhereInput
    none?: WorkEventWhereInput
  }

  export type RentalSignalListRelationFilter = {
    every?: RentalSignalWhereInput
    some?: RentalSignalWhereInput
    none?: RentalSignalWhereInput
  }

  export type InsuranceClaimListRelationFilter = {
    every?: InsuranceClaimWhereInput
    some?: InsuranceClaimWhereInput
    none?: InsuranceClaimWhereInput
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type NotificationSubscriptionListRelationFilter = {
    every?: NotificationSubscriptionWhereInput
    some?: NotificationSubscriptionWhereInput
    none?: NotificationSubscriptionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SourceRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OwnershipEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PermitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RentalSignalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InsuranceClaimOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyCountOrderByAggregateInput = {
    id?: SortOrder
    apn?: SortOrder
    address?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    county?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    lotSize?: SortOrder
    livingArea?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    yearBuilt?: SortOrder
    propertyType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    lotSize?: SortOrder
    livingArea?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    yearBuilt?: SortOrder
  }

  export type PropertyMaxOrderByAggregateInput = {
    id?: SortOrder
    apn?: SortOrder
    address?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    county?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    lotSize?: SortOrder
    livingArea?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    yearBuilt?: SortOrder
    propertyType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyMinOrderByAggregateInput = {
    id?: SortOrder
    apn?: SortOrder
    address?: SortOrder
    addressLine2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zipCode?: SortOrder
    county?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    lotSize?: SortOrder
    livingArea?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    yearBuilt?: SortOrder
    propertyType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertySumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    lotSize?: SortOrder
    livingArea?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    yearBuilt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type PropertyScalarRelationFilter = {
    is?: PropertyWhereInput
    isNot?: PropertyWhereInput
  }

  export type SourceRecordCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    source?: SortOrder
    sourceId?: SortOrder
    rawPayload?: SortOrder
    ingestedAt?: SortOrder
    version?: SortOrder
  }

  export type SourceRecordAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type SourceRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    source?: SortOrder
    sourceId?: SortOrder
    ingestedAt?: SortOrder
    version?: SortOrder
  }

  export type SourceRecordMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    source?: SortOrder
    sourceId?: SortOrder
    ingestedAt?: SortOrder
    version?: SortOrder
  }

  export type SourceRecordSumOrderByAggregateInput = {
    version?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type OwnershipEventCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    ownerName?: SortOrder
    ownerType?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    isCurrent?: SortOrder
    documentRef?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OwnershipEventMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    ownerName?: SortOrder
    ownerType?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    isCurrent?: SortOrder
    documentRef?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OwnershipEventMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    ownerName?: SortOrder
    ownerType?: SortOrder
    fromDate?: SortOrder
    toDate?: SortOrder
    isCurrent?: SortOrder
    documentRef?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type SaleCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    saleDate?: SortOrder
    salePrice?: SortOrder
    saleType?: SortOrder
    buyerName?: SortOrder
    sellerName?: SortOrder
    documentRef?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleAvgOrderByAggregateInput = {
    salePrice?: SortOrder
  }

  export type SaleMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    saleDate?: SortOrder
    salePrice?: SortOrder
    saleType?: SortOrder
    buyerName?: SortOrder
    sellerName?: SortOrder
    documentRef?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    saleDate?: SortOrder
    salePrice?: SortOrder
    saleType?: SortOrder
    buyerName?: SortOrder
    sellerName?: SortOrder
    documentRef?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SaleSumOrderByAggregateInput = {
    salePrice?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type PermitCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    permitNumber?: SortOrder
    permitType?: SortOrder
    status?: SortOrder
    issuedDate?: SortOrder
    completedDate?: SortOrder
    expirationDate?: SortOrder
    description?: SortOrder
    contractorName?: SortOrder
    jurisdiction?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermitMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    permitNumber?: SortOrder
    permitType?: SortOrder
    status?: SortOrder
    issuedDate?: SortOrder
    completedDate?: SortOrder
    expirationDate?: SortOrder
    description?: SortOrder
    contractorName?: SortOrder
    jurisdiction?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PermitMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    permitNumber?: SortOrder
    permitType?: SortOrder
    status?: SortOrder
    issuedDate?: SortOrder
    completedDate?: SortOrder
    expirationDate?: SortOrder
    description?: SortOrder
    contractorName?: SortOrder
    jurisdiction?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractorCompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    licenseNumber?: SortOrder
    licenseType?: SortOrder
    state?: SortOrder
    verificationStatus?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    address?: SortOrder
    rating?: SortOrder
    totalJobs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractorCompanyAvgOrderByAggregateInput = {
    rating?: SortOrder
    totalJobs?: SortOrder
  }

  export type ContractorCompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    licenseNumber?: SortOrder
    licenseType?: SortOrder
    state?: SortOrder
    verificationStatus?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    address?: SortOrder
    rating?: SortOrder
    totalJobs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractorCompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    licenseNumber?: SortOrder
    licenseType?: SortOrder
    state?: SortOrder
    verificationStatus?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    address?: SortOrder
    rating?: SortOrder
    totalJobs?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractorCompanySumOrderByAggregateInput = {
    rating?: SortOrder
    totalJobs?: SortOrder
  }

  export type ContractorCompanyNullableScalarRelationFilter = {
    is?: ContractorCompanyWhereInput | null
    isNot?: ContractorCompanyWhereInput | null
  }

  export type InsuranceClaimNullableScalarRelationFilter = {
    is?: InsuranceClaimWhereInput | null
    isNot?: InsuranceClaimWhereInput | null
  }

  export type WorkEventCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    contractorId?: SortOrder
    workType?: SortOrder
    description?: SortOrder
    workDate?: SortOrder
    cost?: SortOrder
    invoiceNumber?: SortOrder
    documentUrl?: SortOrder
    verificationStatus?: SortOrder
    warrantyPeriodMonths?: SortOrder
    warrantyExpirationDate?: SortOrder
    warrantyType?: SortOrder
    warrantyDetails?: SortOrder
    insuranceClaimId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkEventAvgOrderByAggregateInput = {
    cost?: SortOrder
    warrantyPeriodMonths?: SortOrder
  }

  export type WorkEventMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    contractorId?: SortOrder
    workType?: SortOrder
    description?: SortOrder
    workDate?: SortOrder
    cost?: SortOrder
    invoiceNumber?: SortOrder
    documentUrl?: SortOrder
    verificationStatus?: SortOrder
    warrantyPeriodMonths?: SortOrder
    warrantyExpirationDate?: SortOrder
    warrantyType?: SortOrder
    warrantyDetails?: SortOrder
    insuranceClaimId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkEventMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    contractorId?: SortOrder
    workType?: SortOrder
    description?: SortOrder
    workDate?: SortOrder
    cost?: SortOrder
    invoiceNumber?: SortOrder
    documentUrl?: SortOrder
    verificationStatus?: SortOrder
    warrantyPeriodMonths?: SortOrder
    warrantyExpirationDate?: SortOrder
    warrantyType?: SortOrder
    warrantyDetails?: SortOrder
    insuranceClaimId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkEventSumOrderByAggregateInput = {
    cost?: SortOrder
    warrantyPeriodMonths?: SortOrder
  }

  export type RentalSignalCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    source?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    confidence?: SortOrder
    evidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RentalSignalAvgOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type RentalSignalMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    source?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RentalSignalMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    source?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RentalSignalSumOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type InsuranceClaimCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    claimType?: SortOrder
    claimDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    submittedBy?: SortOrder
    verificationStatus?: SortOrder
    documentUrl?: SortOrder
    contractorId?: SortOrder
    workDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InsuranceClaimAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InsuranceClaimMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    claimType?: SortOrder
    claimDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    submittedBy?: SortOrder
    verificationStatus?: SortOrder
    documentUrl?: SortOrder
    contractorId?: SortOrder
    workDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InsuranceClaimMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    claimType?: SortOrder
    claimDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    submittedBy?: SortOrder
    verificationStatus?: SortOrder
    documentUrl?: SortOrder
    contractorId?: SortOrder
    workDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InsuranceClaimSumOrderByAggregateInput = {
    amount?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    version?: SortOrder
    generatedAt?: SortOrder
    snapshot?: SortOrder
    shareToken?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    version?: SortOrder
    generatedAt?: SortOrder
    shareToken?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    version?: SortOrder
    generatedAt?: SortOrder
    shareToken?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportSumOrderByAggregateInput = {
    version?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type NotificationSubscriptionUserIdPropertyIdEventTypeCompoundUniqueInput = {
    userId: string
    propertyId: string
    eventType: string
  }

  export type NotificationSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
    eventType?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
    eventType?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    propertyId?: SortOrder
    eventType?: SortOrder
    enabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SourceRecordCreateNestedManyWithoutPropertyInput = {
    create?: XOR<SourceRecordCreateWithoutPropertyInput, SourceRecordUncheckedCreateWithoutPropertyInput> | SourceRecordCreateWithoutPropertyInput[] | SourceRecordUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: SourceRecordCreateOrConnectWithoutPropertyInput | SourceRecordCreateOrConnectWithoutPropertyInput[]
    createMany?: SourceRecordCreateManyPropertyInputEnvelope
    connect?: SourceRecordWhereUniqueInput | SourceRecordWhereUniqueInput[]
  }

  export type OwnershipEventCreateNestedManyWithoutPropertyInput = {
    create?: XOR<OwnershipEventCreateWithoutPropertyInput, OwnershipEventUncheckedCreateWithoutPropertyInput> | OwnershipEventCreateWithoutPropertyInput[] | OwnershipEventUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: OwnershipEventCreateOrConnectWithoutPropertyInput | OwnershipEventCreateOrConnectWithoutPropertyInput[]
    createMany?: OwnershipEventCreateManyPropertyInputEnvelope
    connect?: OwnershipEventWhereUniqueInput | OwnershipEventWhereUniqueInput[]
  }

  export type SaleCreateNestedManyWithoutPropertyInput = {
    create?: XOR<SaleCreateWithoutPropertyInput, SaleUncheckedCreateWithoutPropertyInput> | SaleCreateWithoutPropertyInput[] | SaleUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutPropertyInput | SaleCreateOrConnectWithoutPropertyInput[]
    createMany?: SaleCreateManyPropertyInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type PermitCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PermitCreateWithoutPropertyInput, PermitUncheckedCreateWithoutPropertyInput> | PermitCreateWithoutPropertyInput[] | PermitUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PermitCreateOrConnectWithoutPropertyInput | PermitCreateOrConnectWithoutPropertyInput[]
    createMany?: PermitCreateManyPropertyInputEnvelope
    connect?: PermitWhereUniqueInput | PermitWhereUniqueInput[]
  }

  export type WorkEventCreateNestedManyWithoutPropertyInput = {
    create?: XOR<WorkEventCreateWithoutPropertyInput, WorkEventUncheckedCreateWithoutPropertyInput> | WorkEventCreateWithoutPropertyInput[] | WorkEventUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: WorkEventCreateOrConnectWithoutPropertyInput | WorkEventCreateOrConnectWithoutPropertyInput[]
    createMany?: WorkEventCreateManyPropertyInputEnvelope
    connect?: WorkEventWhereUniqueInput | WorkEventWhereUniqueInput[]
  }

  export type RentalSignalCreateNestedManyWithoutPropertyInput = {
    create?: XOR<RentalSignalCreateWithoutPropertyInput, RentalSignalUncheckedCreateWithoutPropertyInput> | RentalSignalCreateWithoutPropertyInput[] | RentalSignalUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: RentalSignalCreateOrConnectWithoutPropertyInput | RentalSignalCreateOrConnectWithoutPropertyInput[]
    createMany?: RentalSignalCreateManyPropertyInputEnvelope
    connect?: RentalSignalWhereUniqueInput | RentalSignalWhereUniqueInput[]
  }

  export type InsuranceClaimCreateNestedManyWithoutPropertyInput = {
    create?: XOR<InsuranceClaimCreateWithoutPropertyInput, InsuranceClaimUncheckedCreateWithoutPropertyInput> | InsuranceClaimCreateWithoutPropertyInput[] | InsuranceClaimUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: InsuranceClaimCreateOrConnectWithoutPropertyInput | InsuranceClaimCreateOrConnectWithoutPropertyInput[]
    createMany?: InsuranceClaimCreateManyPropertyInputEnvelope
    connect?: InsuranceClaimWhereUniqueInput | InsuranceClaimWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutPropertyInput = {
    create?: XOR<ReportCreateWithoutPropertyInput, ReportUncheckedCreateWithoutPropertyInput> | ReportCreateWithoutPropertyInput[] | ReportUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutPropertyInput | ReportCreateOrConnectWithoutPropertyInput[]
    createMany?: ReportCreateManyPropertyInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type NotificationSubscriptionCreateNestedManyWithoutPropertyInput = {
    create?: XOR<NotificationSubscriptionCreateWithoutPropertyInput, NotificationSubscriptionUncheckedCreateWithoutPropertyInput> | NotificationSubscriptionCreateWithoutPropertyInput[] | NotificationSubscriptionUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: NotificationSubscriptionCreateOrConnectWithoutPropertyInput | NotificationSubscriptionCreateOrConnectWithoutPropertyInput[]
    createMany?: NotificationSubscriptionCreateManyPropertyInputEnvelope
    connect?: NotificationSubscriptionWhereUniqueInput | NotificationSubscriptionWhereUniqueInput[]
  }

  export type SourceRecordUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<SourceRecordCreateWithoutPropertyInput, SourceRecordUncheckedCreateWithoutPropertyInput> | SourceRecordCreateWithoutPropertyInput[] | SourceRecordUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: SourceRecordCreateOrConnectWithoutPropertyInput | SourceRecordCreateOrConnectWithoutPropertyInput[]
    createMany?: SourceRecordCreateManyPropertyInputEnvelope
    connect?: SourceRecordWhereUniqueInput | SourceRecordWhereUniqueInput[]
  }

  export type OwnershipEventUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<OwnershipEventCreateWithoutPropertyInput, OwnershipEventUncheckedCreateWithoutPropertyInput> | OwnershipEventCreateWithoutPropertyInput[] | OwnershipEventUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: OwnershipEventCreateOrConnectWithoutPropertyInput | OwnershipEventCreateOrConnectWithoutPropertyInput[]
    createMany?: OwnershipEventCreateManyPropertyInputEnvelope
    connect?: OwnershipEventWhereUniqueInput | OwnershipEventWhereUniqueInput[]
  }

  export type SaleUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<SaleCreateWithoutPropertyInput, SaleUncheckedCreateWithoutPropertyInput> | SaleCreateWithoutPropertyInput[] | SaleUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutPropertyInput | SaleCreateOrConnectWithoutPropertyInput[]
    createMany?: SaleCreateManyPropertyInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type PermitUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PermitCreateWithoutPropertyInput, PermitUncheckedCreateWithoutPropertyInput> | PermitCreateWithoutPropertyInput[] | PermitUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PermitCreateOrConnectWithoutPropertyInput | PermitCreateOrConnectWithoutPropertyInput[]
    createMany?: PermitCreateManyPropertyInputEnvelope
    connect?: PermitWhereUniqueInput | PermitWhereUniqueInput[]
  }

  export type WorkEventUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<WorkEventCreateWithoutPropertyInput, WorkEventUncheckedCreateWithoutPropertyInput> | WorkEventCreateWithoutPropertyInput[] | WorkEventUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: WorkEventCreateOrConnectWithoutPropertyInput | WorkEventCreateOrConnectWithoutPropertyInput[]
    createMany?: WorkEventCreateManyPropertyInputEnvelope
    connect?: WorkEventWhereUniqueInput | WorkEventWhereUniqueInput[]
  }

  export type RentalSignalUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<RentalSignalCreateWithoutPropertyInput, RentalSignalUncheckedCreateWithoutPropertyInput> | RentalSignalCreateWithoutPropertyInput[] | RentalSignalUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: RentalSignalCreateOrConnectWithoutPropertyInput | RentalSignalCreateOrConnectWithoutPropertyInput[]
    createMany?: RentalSignalCreateManyPropertyInputEnvelope
    connect?: RentalSignalWhereUniqueInput | RentalSignalWhereUniqueInput[]
  }

  export type InsuranceClaimUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<InsuranceClaimCreateWithoutPropertyInput, InsuranceClaimUncheckedCreateWithoutPropertyInput> | InsuranceClaimCreateWithoutPropertyInput[] | InsuranceClaimUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: InsuranceClaimCreateOrConnectWithoutPropertyInput | InsuranceClaimCreateOrConnectWithoutPropertyInput[]
    createMany?: InsuranceClaimCreateManyPropertyInputEnvelope
    connect?: InsuranceClaimWhereUniqueInput | InsuranceClaimWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<ReportCreateWithoutPropertyInput, ReportUncheckedCreateWithoutPropertyInput> | ReportCreateWithoutPropertyInput[] | ReportUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutPropertyInput | ReportCreateOrConnectWithoutPropertyInput[]
    createMany?: ReportCreateManyPropertyInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type NotificationSubscriptionUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<NotificationSubscriptionCreateWithoutPropertyInput, NotificationSubscriptionUncheckedCreateWithoutPropertyInput> | NotificationSubscriptionCreateWithoutPropertyInput[] | NotificationSubscriptionUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: NotificationSubscriptionCreateOrConnectWithoutPropertyInput | NotificationSubscriptionCreateOrConnectWithoutPropertyInput[]
    createMany?: NotificationSubscriptionCreateManyPropertyInputEnvelope
    connect?: NotificationSubscriptionWhereUniqueInput | NotificationSubscriptionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SourceRecordUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<SourceRecordCreateWithoutPropertyInput, SourceRecordUncheckedCreateWithoutPropertyInput> | SourceRecordCreateWithoutPropertyInput[] | SourceRecordUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: SourceRecordCreateOrConnectWithoutPropertyInput | SourceRecordCreateOrConnectWithoutPropertyInput[]
    upsert?: SourceRecordUpsertWithWhereUniqueWithoutPropertyInput | SourceRecordUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: SourceRecordCreateManyPropertyInputEnvelope
    set?: SourceRecordWhereUniqueInput | SourceRecordWhereUniqueInput[]
    disconnect?: SourceRecordWhereUniqueInput | SourceRecordWhereUniqueInput[]
    delete?: SourceRecordWhereUniqueInput | SourceRecordWhereUniqueInput[]
    connect?: SourceRecordWhereUniqueInput | SourceRecordWhereUniqueInput[]
    update?: SourceRecordUpdateWithWhereUniqueWithoutPropertyInput | SourceRecordUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: SourceRecordUpdateManyWithWhereWithoutPropertyInput | SourceRecordUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: SourceRecordScalarWhereInput | SourceRecordScalarWhereInput[]
  }

  export type OwnershipEventUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<OwnershipEventCreateWithoutPropertyInput, OwnershipEventUncheckedCreateWithoutPropertyInput> | OwnershipEventCreateWithoutPropertyInput[] | OwnershipEventUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: OwnershipEventCreateOrConnectWithoutPropertyInput | OwnershipEventCreateOrConnectWithoutPropertyInput[]
    upsert?: OwnershipEventUpsertWithWhereUniqueWithoutPropertyInput | OwnershipEventUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: OwnershipEventCreateManyPropertyInputEnvelope
    set?: OwnershipEventWhereUniqueInput | OwnershipEventWhereUniqueInput[]
    disconnect?: OwnershipEventWhereUniqueInput | OwnershipEventWhereUniqueInput[]
    delete?: OwnershipEventWhereUniqueInput | OwnershipEventWhereUniqueInput[]
    connect?: OwnershipEventWhereUniqueInput | OwnershipEventWhereUniqueInput[]
    update?: OwnershipEventUpdateWithWhereUniqueWithoutPropertyInput | OwnershipEventUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: OwnershipEventUpdateManyWithWhereWithoutPropertyInput | OwnershipEventUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: OwnershipEventScalarWhereInput | OwnershipEventScalarWhereInput[]
  }

  export type SaleUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<SaleCreateWithoutPropertyInput, SaleUncheckedCreateWithoutPropertyInput> | SaleCreateWithoutPropertyInput[] | SaleUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutPropertyInput | SaleCreateOrConnectWithoutPropertyInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutPropertyInput | SaleUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: SaleCreateManyPropertyInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutPropertyInput | SaleUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutPropertyInput | SaleUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type PermitUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PermitCreateWithoutPropertyInput, PermitUncheckedCreateWithoutPropertyInput> | PermitCreateWithoutPropertyInput[] | PermitUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PermitCreateOrConnectWithoutPropertyInput | PermitCreateOrConnectWithoutPropertyInput[]
    upsert?: PermitUpsertWithWhereUniqueWithoutPropertyInput | PermitUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PermitCreateManyPropertyInputEnvelope
    set?: PermitWhereUniqueInput | PermitWhereUniqueInput[]
    disconnect?: PermitWhereUniqueInput | PermitWhereUniqueInput[]
    delete?: PermitWhereUniqueInput | PermitWhereUniqueInput[]
    connect?: PermitWhereUniqueInput | PermitWhereUniqueInput[]
    update?: PermitUpdateWithWhereUniqueWithoutPropertyInput | PermitUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PermitUpdateManyWithWhereWithoutPropertyInput | PermitUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PermitScalarWhereInput | PermitScalarWhereInput[]
  }

  export type WorkEventUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<WorkEventCreateWithoutPropertyInput, WorkEventUncheckedCreateWithoutPropertyInput> | WorkEventCreateWithoutPropertyInput[] | WorkEventUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: WorkEventCreateOrConnectWithoutPropertyInput | WorkEventCreateOrConnectWithoutPropertyInput[]
    upsert?: WorkEventUpsertWithWhereUniqueWithoutPropertyInput | WorkEventUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: WorkEventCreateManyPropertyInputEnvelope
    set?: WorkEventWhereUniqueInput | WorkEventWhereUniqueInput[]
    disconnect?: WorkEventWhereUniqueInput | WorkEventWhereUniqueInput[]
    delete?: WorkEventWhereUniqueInput | WorkEventWhereUniqueInput[]
    connect?: WorkEventWhereUniqueInput | WorkEventWhereUniqueInput[]
    update?: WorkEventUpdateWithWhereUniqueWithoutPropertyInput | WorkEventUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: WorkEventUpdateManyWithWhereWithoutPropertyInput | WorkEventUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: WorkEventScalarWhereInput | WorkEventScalarWhereInput[]
  }

  export type RentalSignalUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<RentalSignalCreateWithoutPropertyInput, RentalSignalUncheckedCreateWithoutPropertyInput> | RentalSignalCreateWithoutPropertyInput[] | RentalSignalUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: RentalSignalCreateOrConnectWithoutPropertyInput | RentalSignalCreateOrConnectWithoutPropertyInput[]
    upsert?: RentalSignalUpsertWithWhereUniqueWithoutPropertyInput | RentalSignalUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: RentalSignalCreateManyPropertyInputEnvelope
    set?: RentalSignalWhereUniqueInput | RentalSignalWhereUniqueInput[]
    disconnect?: RentalSignalWhereUniqueInput | RentalSignalWhereUniqueInput[]
    delete?: RentalSignalWhereUniqueInput | RentalSignalWhereUniqueInput[]
    connect?: RentalSignalWhereUniqueInput | RentalSignalWhereUniqueInput[]
    update?: RentalSignalUpdateWithWhereUniqueWithoutPropertyInput | RentalSignalUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: RentalSignalUpdateManyWithWhereWithoutPropertyInput | RentalSignalUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: RentalSignalScalarWhereInput | RentalSignalScalarWhereInput[]
  }

  export type InsuranceClaimUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<InsuranceClaimCreateWithoutPropertyInput, InsuranceClaimUncheckedCreateWithoutPropertyInput> | InsuranceClaimCreateWithoutPropertyInput[] | InsuranceClaimUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: InsuranceClaimCreateOrConnectWithoutPropertyInput | InsuranceClaimCreateOrConnectWithoutPropertyInput[]
    upsert?: InsuranceClaimUpsertWithWhereUniqueWithoutPropertyInput | InsuranceClaimUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: InsuranceClaimCreateManyPropertyInputEnvelope
    set?: InsuranceClaimWhereUniqueInput | InsuranceClaimWhereUniqueInput[]
    disconnect?: InsuranceClaimWhereUniqueInput | InsuranceClaimWhereUniqueInput[]
    delete?: InsuranceClaimWhereUniqueInput | InsuranceClaimWhereUniqueInput[]
    connect?: InsuranceClaimWhereUniqueInput | InsuranceClaimWhereUniqueInput[]
    update?: InsuranceClaimUpdateWithWhereUniqueWithoutPropertyInput | InsuranceClaimUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: InsuranceClaimUpdateManyWithWhereWithoutPropertyInput | InsuranceClaimUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: InsuranceClaimScalarWhereInput | InsuranceClaimScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<ReportCreateWithoutPropertyInput, ReportUncheckedCreateWithoutPropertyInput> | ReportCreateWithoutPropertyInput[] | ReportUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutPropertyInput | ReportCreateOrConnectWithoutPropertyInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutPropertyInput | ReportUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: ReportCreateManyPropertyInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutPropertyInput | ReportUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutPropertyInput | ReportUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type NotificationSubscriptionUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<NotificationSubscriptionCreateWithoutPropertyInput, NotificationSubscriptionUncheckedCreateWithoutPropertyInput> | NotificationSubscriptionCreateWithoutPropertyInput[] | NotificationSubscriptionUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: NotificationSubscriptionCreateOrConnectWithoutPropertyInput | NotificationSubscriptionCreateOrConnectWithoutPropertyInput[]
    upsert?: NotificationSubscriptionUpsertWithWhereUniqueWithoutPropertyInput | NotificationSubscriptionUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: NotificationSubscriptionCreateManyPropertyInputEnvelope
    set?: NotificationSubscriptionWhereUniqueInput | NotificationSubscriptionWhereUniqueInput[]
    disconnect?: NotificationSubscriptionWhereUniqueInput | NotificationSubscriptionWhereUniqueInput[]
    delete?: NotificationSubscriptionWhereUniqueInput | NotificationSubscriptionWhereUniqueInput[]
    connect?: NotificationSubscriptionWhereUniqueInput | NotificationSubscriptionWhereUniqueInput[]
    update?: NotificationSubscriptionUpdateWithWhereUniqueWithoutPropertyInput | NotificationSubscriptionUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: NotificationSubscriptionUpdateManyWithWhereWithoutPropertyInput | NotificationSubscriptionUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: NotificationSubscriptionScalarWhereInput | NotificationSubscriptionScalarWhereInput[]
  }

  export type SourceRecordUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<SourceRecordCreateWithoutPropertyInput, SourceRecordUncheckedCreateWithoutPropertyInput> | SourceRecordCreateWithoutPropertyInput[] | SourceRecordUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: SourceRecordCreateOrConnectWithoutPropertyInput | SourceRecordCreateOrConnectWithoutPropertyInput[]
    upsert?: SourceRecordUpsertWithWhereUniqueWithoutPropertyInput | SourceRecordUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: SourceRecordCreateManyPropertyInputEnvelope
    set?: SourceRecordWhereUniqueInput | SourceRecordWhereUniqueInput[]
    disconnect?: SourceRecordWhereUniqueInput | SourceRecordWhereUniqueInput[]
    delete?: SourceRecordWhereUniqueInput | SourceRecordWhereUniqueInput[]
    connect?: SourceRecordWhereUniqueInput | SourceRecordWhereUniqueInput[]
    update?: SourceRecordUpdateWithWhereUniqueWithoutPropertyInput | SourceRecordUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: SourceRecordUpdateManyWithWhereWithoutPropertyInput | SourceRecordUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: SourceRecordScalarWhereInput | SourceRecordScalarWhereInput[]
  }

  export type OwnershipEventUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<OwnershipEventCreateWithoutPropertyInput, OwnershipEventUncheckedCreateWithoutPropertyInput> | OwnershipEventCreateWithoutPropertyInput[] | OwnershipEventUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: OwnershipEventCreateOrConnectWithoutPropertyInput | OwnershipEventCreateOrConnectWithoutPropertyInput[]
    upsert?: OwnershipEventUpsertWithWhereUniqueWithoutPropertyInput | OwnershipEventUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: OwnershipEventCreateManyPropertyInputEnvelope
    set?: OwnershipEventWhereUniqueInput | OwnershipEventWhereUniqueInput[]
    disconnect?: OwnershipEventWhereUniqueInput | OwnershipEventWhereUniqueInput[]
    delete?: OwnershipEventWhereUniqueInput | OwnershipEventWhereUniqueInput[]
    connect?: OwnershipEventWhereUniqueInput | OwnershipEventWhereUniqueInput[]
    update?: OwnershipEventUpdateWithWhereUniqueWithoutPropertyInput | OwnershipEventUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: OwnershipEventUpdateManyWithWhereWithoutPropertyInput | OwnershipEventUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: OwnershipEventScalarWhereInput | OwnershipEventScalarWhereInput[]
  }

  export type SaleUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<SaleCreateWithoutPropertyInput, SaleUncheckedCreateWithoutPropertyInput> | SaleCreateWithoutPropertyInput[] | SaleUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutPropertyInput | SaleCreateOrConnectWithoutPropertyInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutPropertyInput | SaleUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: SaleCreateManyPropertyInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutPropertyInput | SaleUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutPropertyInput | SaleUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type PermitUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PermitCreateWithoutPropertyInput, PermitUncheckedCreateWithoutPropertyInput> | PermitCreateWithoutPropertyInput[] | PermitUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PermitCreateOrConnectWithoutPropertyInput | PermitCreateOrConnectWithoutPropertyInput[]
    upsert?: PermitUpsertWithWhereUniqueWithoutPropertyInput | PermitUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PermitCreateManyPropertyInputEnvelope
    set?: PermitWhereUniqueInput | PermitWhereUniqueInput[]
    disconnect?: PermitWhereUniqueInput | PermitWhereUniqueInput[]
    delete?: PermitWhereUniqueInput | PermitWhereUniqueInput[]
    connect?: PermitWhereUniqueInput | PermitWhereUniqueInput[]
    update?: PermitUpdateWithWhereUniqueWithoutPropertyInput | PermitUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PermitUpdateManyWithWhereWithoutPropertyInput | PermitUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PermitScalarWhereInput | PermitScalarWhereInput[]
  }

  export type WorkEventUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<WorkEventCreateWithoutPropertyInput, WorkEventUncheckedCreateWithoutPropertyInput> | WorkEventCreateWithoutPropertyInput[] | WorkEventUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: WorkEventCreateOrConnectWithoutPropertyInput | WorkEventCreateOrConnectWithoutPropertyInput[]
    upsert?: WorkEventUpsertWithWhereUniqueWithoutPropertyInput | WorkEventUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: WorkEventCreateManyPropertyInputEnvelope
    set?: WorkEventWhereUniqueInput | WorkEventWhereUniqueInput[]
    disconnect?: WorkEventWhereUniqueInput | WorkEventWhereUniqueInput[]
    delete?: WorkEventWhereUniqueInput | WorkEventWhereUniqueInput[]
    connect?: WorkEventWhereUniqueInput | WorkEventWhereUniqueInput[]
    update?: WorkEventUpdateWithWhereUniqueWithoutPropertyInput | WorkEventUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: WorkEventUpdateManyWithWhereWithoutPropertyInput | WorkEventUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: WorkEventScalarWhereInput | WorkEventScalarWhereInput[]
  }

  export type RentalSignalUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<RentalSignalCreateWithoutPropertyInput, RentalSignalUncheckedCreateWithoutPropertyInput> | RentalSignalCreateWithoutPropertyInput[] | RentalSignalUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: RentalSignalCreateOrConnectWithoutPropertyInput | RentalSignalCreateOrConnectWithoutPropertyInput[]
    upsert?: RentalSignalUpsertWithWhereUniqueWithoutPropertyInput | RentalSignalUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: RentalSignalCreateManyPropertyInputEnvelope
    set?: RentalSignalWhereUniqueInput | RentalSignalWhereUniqueInput[]
    disconnect?: RentalSignalWhereUniqueInput | RentalSignalWhereUniqueInput[]
    delete?: RentalSignalWhereUniqueInput | RentalSignalWhereUniqueInput[]
    connect?: RentalSignalWhereUniqueInput | RentalSignalWhereUniqueInput[]
    update?: RentalSignalUpdateWithWhereUniqueWithoutPropertyInput | RentalSignalUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: RentalSignalUpdateManyWithWhereWithoutPropertyInput | RentalSignalUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: RentalSignalScalarWhereInput | RentalSignalScalarWhereInput[]
  }

  export type InsuranceClaimUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<InsuranceClaimCreateWithoutPropertyInput, InsuranceClaimUncheckedCreateWithoutPropertyInput> | InsuranceClaimCreateWithoutPropertyInput[] | InsuranceClaimUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: InsuranceClaimCreateOrConnectWithoutPropertyInput | InsuranceClaimCreateOrConnectWithoutPropertyInput[]
    upsert?: InsuranceClaimUpsertWithWhereUniqueWithoutPropertyInput | InsuranceClaimUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: InsuranceClaimCreateManyPropertyInputEnvelope
    set?: InsuranceClaimWhereUniqueInput | InsuranceClaimWhereUniqueInput[]
    disconnect?: InsuranceClaimWhereUniqueInput | InsuranceClaimWhereUniqueInput[]
    delete?: InsuranceClaimWhereUniqueInput | InsuranceClaimWhereUniqueInput[]
    connect?: InsuranceClaimWhereUniqueInput | InsuranceClaimWhereUniqueInput[]
    update?: InsuranceClaimUpdateWithWhereUniqueWithoutPropertyInput | InsuranceClaimUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: InsuranceClaimUpdateManyWithWhereWithoutPropertyInput | InsuranceClaimUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: InsuranceClaimScalarWhereInput | InsuranceClaimScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<ReportCreateWithoutPropertyInput, ReportUncheckedCreateWithoutPropertyInput> | ReportCreateWithoutPropertyInput[] | ReportUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutPropertyInput | ReportCreateOrConnectWithoutPropertyInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutPropertyInput | ReportUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: ReportCreateManyPropertyInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutPropertyInput | ReportUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutPropertyInput | ReportUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type NotificationSubscriptionUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<NotificationSubscriptionCreateWithoutPropertyInput, NotificationSubscriptionUncheckedCreateWithoutPropertyInput> | NotificationSubscriptionCreateWithoutPropertyInput[] | NotificationSubscriptionUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: NotificationSubscriptionCreateOrConnectWithoutPropertyInput | NotificationSubscriptionCreateOrConnectWithoutPropertyInput[]
    upsert?: NotificationSubscriptionUpsertWithWhereUniqueWithoutPropertyInput | NotificationSubscriptionUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: NotificationSubscriptionCreateManyPropertyInputEnvelope
    set?: NotificationSubscriptionWhereUniqueInput | NotificationSubscriptionWhereUniqueInput[]
    disconnect?: NotificationSubscriptionWhereUniqueInput | NotificationSubscriptionWhereUniqueInput[]
    delete?: NotificationSubscriptionWhereUniqueInput | NotificationSubscriptionWhereUniqueInput[]
    connect?: NotificationSubscriptionWhereUniqueInput | NotificationSubscriptionWhereUniqueInput[]
    update?: NotificationSubscriptionUpdateWithWhereUniqueWithoutPropertyInput | NotificationSubscriptionUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: NotificationSubscriptionUpdateManyWithWhereWithoutPropertyInput | NotificationSubscriptionUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: NotificationSubscriptionScalarWhereInput | NotificationSubscriptionScalarWhereInput[]
  }

  export type PropertyCreateNestedOneWithoutSourceRecordsInput = {
    create?: XOR<PropertyCreateWithoutSourceRecordsInput, PropertyUncheckedCreateWithoutSourceRecordsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutSourceRecordsInput
    connect?: PropertyWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PropertyUpdateOneRequiredWithoutSourceRecordsNestedInput = {
    create?: XOR<PropertyCreateWithoutSourceRecordsInput, PropertyUncheckedCreateWithoutSourceRecordsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutSourceRecordsInput
    upsert?: PropertyUpsertWithoutSourceRecordsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutSourceRecordsInput, PropertyUpdateWithoutSourceRecordsInput>, PropertyUncheckedUpdateWithoutSourceRecordsInput>
  }

  export type PropertyCreateNestedOneWithoutOwnershipEventsInput = {
    create?: XOR<PropertyCreateWithoutOwnershipEventsInput, PropertyUncheckedCreateWithoutOwnershipEventsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutOwnershipEventsInput
    connect?: PropertyWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type PropertyUpdateOneRequiredWithoutOwnershipEventsNestedInput = {
    create?: XOR<PropertyCreateWithoutOwnershipEventsInput, PropertyUncheckedCreateWithoutOwnershipEventsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutOwnershipEventsInput
    upsert?: PropertyUpsertWithoutOwnershipEventsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutOwnershipEventsInput, PropertyUpdateWithoutOwnershipEventsInput>, PropertyUncheckedUpdateWithoutOwnershipEventsInput>
  }

  export type PropertyCreateNestedOneWithoutSalesInput = {
    create?: XOR<PropertyCreateWithoutSalesInput, PropertyUncheckedCreateWithoutSalesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutSalesInput
    connect?: PropertyWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PropertyUpdateOneRequiredWithoutSalesNestedInput = {
    create?: XOR<PropertyCreateWithoutSalesInput, PropertyUncheckedCreateWithoutSalesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutSalesInput
    upsert?: PropertyUpsertWithoutSalesInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutSalesInput, PropertyUpdateWithoutSalesInput>, PropertyUncheckedUpdateWithoutSalesInput>
  }

  export type PropertyCreateNestedOneWithoutPermitsInput = {
    create?: XOR<PropertyCreateWithoutPermitsInput, PropertyUncheckedCreateWithoutPermitsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPermitsInput
    connect?: PropertyWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutPermitsNestedInput = {
    create?: XOR<PropertyCreateWithoutPermitsInput, PropertyUncheckedCreateWithoutPermitsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPermitsInput
    upsert?: PropertyUpsertWithoutPermitsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutPermitsInput, PropertyUpdateWithoutPermitsInput>, PropertyUncheckedUpdateWithoutPermitsInput>
  }

  export type WorkEventCreateNestedManyWithoutContractorInput = {
    create?: XOR<WorkEventCreateWithoutContractorInput, WorkEventUncheckedCreateWithoutContractorInput> | WorkEventCreateWithoutContractorInput[] | WorkEventUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: WorkEventCreateOrConnectWithoutContractorInput | WorkEventCreateOrConnectWithoutContractorInput[]
    createMany?: WorkEventCreateManyContractorInputEnvelope
    connect?: WorkEventWhereUniqueInput | WorkEventWhereUniqueInput[]
  }

  export type InsuranceClaimCreateNestedManyWithoutContractorInput = {
    create?: XOR<InsuranceClaimCreateWithoutContractorInput, InsuranceClaimUncheckedCreateWithoutContractorInput> | InsuranceClaimCreateWithoutContractorInput[] | InsuranceClaimUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: InsuranceClaimCreateOrConnectWithoutContractorInput | InsuranceClaimCreateOrConnectWithoutContractorInput[]
    createMany?: InsuranceClaimCreateManyContractorInputEnvelope
    connect?: InsuranceClaimWhereUniqueInput | InsuranceClaimWhereUniqueInput[]
  }

  export type WorkEventUncheckedCreateNestedManyWithoutContractorInput = {
    create?: XOR<WorkEventCreateWithoutContractorInput, WorkEventUncheckedCreateWithoutContractorInput> | WorkEventCreateWithoutContractorInput[] | WorkEventUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: WorkEventCreateOrConnectWithoutContractorInput | WorkEventCreateOrConnectWithoutContractorInput[]
    createMany?: WorkEventCreateManyContractorInputEnvelope
    connect?: WorkEventWhereUniqueInput | WorkEventWhereUniqueInput[]
  }

  export type InsuranceClaimUncheckedCreateNestedManyWithoutContractorInput = {
    create?: XOR<InsuranceClaimCreateWithoutContractorInput, InsuranceClaimUncheckedCreateWithoutContractorInput> | InsuranceClaimCreateWithoutContractorInput[] | InsuranceClaimUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: InsuranceClaimCreateOrConnectWithoutContractorInput | InsuranceClaimCreateOrConnectWithoutContractorInput[]
    createMany?: InsuranceClaimCreateManyContractorInputEnvelope
    connect?: InsuranceClaimWhereUniqueInput | InsuranceClaimWhereUniqueInput[]
  }

  export type WorkEventUpdateManyWithoutContractorNestedInput = {
    create?: XOR<WorkEventCreateWithoutContractorInput, WorkEventUncheckedCreateWithoutContractorInput> | WorkEventCreateWithoutContractorInput[] | WorkEventUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: WorkEventCreateOrConnectWithoutContractorInput | WorkEventCreateOrConnectWithoutContractorInput[]
    upsert?: WorkEventUpsertWithWhereUniqueWithoutContractorInput | WorkEventUpsertWithWhereUniqueWithoutContractorInput[]
    createMany?: WorkEventCreateManyContractorInputEnvelope
    set?: WorkEventWhereUniqueInput | WorkEventWhereUniqueInput[]
    disconnect?: WorkEventWhereUniqueInput | WorkEventWhereUniqueInput[]
    delete?: WorkEventWhereUniqueInput | WorkEventWhereUniqueInput[]
    connect?: WorkEventWhereUniqueInput | WorkEventWhereUniqueInput[]
    update?: WorkEventUpdateWithWhereUniqueWithoutContractorInput | WorkEventUpdateWithWhereUniqueWithoutContractorInput[]
    updateMany?: WorkEventUpdateManyWithWhereWithoutContractorInput | WorkEventUpdateManyWithWhereWithoutContractorInput[]
    deleteMany?: WorkEventScalarWhereInput | WorkEventScalarWhereInput[]
  }

  export type InsuranceClaimUpdateManyWithoutContractorNestedInput = {
    create?: XOR<InsuranceClaimCreateWithoutContractorInput, InsuranceClaimUncheckedCreateWithoutContractorInput> | InsuranceClaimCreateWithoutContractorInput[] | InsuranceClaimUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: InsuranceClaimCreateOrConnectWithoutContractorInput | InsuranceClaimCreateOrConnectWithoutContractorInput[]
    upsert?: InsuranceClaimUpsertWithWhereUniqueWithoutContractorInput | InsuranceClaimUpsertWithWhereUniqueWithoutContractorInput[]
    createMany?: InsuranceClaimCreateManyContractorInputEnvelope
    set?: InsuranceClaimWhereUniqueInput | InsuranceClaimWhereUniqueInput[]
    disconnect?: InsuranceClaimWhereUniqueInput | InsuranceClaimWhereUniqueInput[]
    delete?: InsuranceClaimWhereUniqueInput | InsuranceClaimWhereUniqueInput[]
    connect?: InsuranceClaimWhereUniqueInput | InsuranceClaimWhereUniqueInput[]
    update?: InsuranceClaimUpdateWithWhereUniqueWithoutContractorInput | InsuranceClaimUpdateWithWhereUniqueWithoutContractorInput[]
    updateMany?: InsuranceClaimUpdateManyWithWhereWithoutContractorInput | InsuranceClaimUpdateManyWithWhereWithoutContractorInput[]
    deleteMany?: InsuranceClaimScalarWhereInput | InsuranceClaimScalarWhereInput[]
  }

  export type WorkEventUncheckedUpdateManyWithoutContractorNestedInput = {
    create?: XOR<WorkEventCreateWithoutContractorInput, WorkEventUncheckedCreateWithoutContractorInput> | WorkEventCreateWithoutContractorInput[] | WorkEventUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: WorkEventCreateOrConnectWithoutContractorInput | WorkEventCreateOrConnectWithoutContractorInput[]
    upsert?: WorkEventUpsertWithWhereUniqueWithoutContractorInput | WorkEventUpsertWithWhereUniqueWithoutContractorInput[]
    createMany?: WorkEventCreateManyContractorInputEnvelope
    set?: WorkEventWhereUniqueInput | WorkEventWhereUniqueInput[]
    disconnect?: WorkEventWhereUniqueInput | WorkEventWhereUniqueInput[]
    delete?: WorkEventWhereUniqueInput | WorkEventWhereUniqueInput[]
    connect?: WorkEventWhereUniqueInput | WorkEventWhereUniqueInput[]
    update?: WorkEventUpdateWithWhereUniqueWithoutContractorInput | WorkEventUpdateWithWhereUniqueWithoutContractorInput[]
    updateMany?: WorkEventUpdateManyWithWhereWithoutContractorInput | WorkEventUpdateManyWithWhereWithoutContractorInput[]
    deleteMany?: WorkEventScalarWhereInput | WorkEventScalarWhereInput[]
  }

  export type InsuranceClaimUncheckedUpdateManyWithoutContractorNestedInput = {
    create?: XOR<InsuranceClaimCreateWithoutContractorInput, InsuranceClaimUncheckedCreateWithoutContractorInput> | InsuranceClaimCreateWithoutContractorInput[] | InsuranceClaimUncheckedCreateWithoutContractorInput[]
    connectOrCreate?: InsuranceClaimCreateOrConnectWithoutContractorInput | InsuranceClaimCreateOrConnectWithoutContractorInput[]
    upsert?: InsuranceClaimUpsertWithWhereUniqueWithoutContractorInput | InsuranceClaimUpsertWithWhereUniqueWithoutContractorInput[]
    createMany?: InsuranceClaimCreateManyContractorInputEnvelope
    set?: InsuranceClaimWhereUniqueInput | InsuranceClaimWhereUniqueInput[]
    disconnect?: InsuranceClaimWhereUniqueInput | InsuranceClaimWhereUniqueInput[]
    delete?: InsuranceClaimWhereUniqueInput | InsuranceClaimWhereUniqueInput[]
    connect?: InsuranceClaimWhereUniqueInput | InsuranceClaimWhereUniqueInput[]
    update?: InsuranceClaimUpdateWithWhereUniqueWithoutContractorInput | InsuranceClaimUpdateWithWhereUniqueWithoutContractorInput[]
    updateMany?: InsuranceClaimUpdateManyWithWhereWithoutContractorInput | InsuranceClaimUpdateManyWithWhereWithoutContractorInput[]
    deleteMany?: InsuranceClaimScalarWhereInput | InsuranceClaimScalarWhereInput[]
  }

  export type PropertyCreateNestedOneWithoutWorkEventsInput = {
    create?: XOR<PropertyCreateWithoutWorkEventsInput, PropertyUncheckedCreateWithoutWorkEventsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutWorkEventsInput
    connect?: PropertyWhereUniqueInput
  }

  export type ContractorCompanyCreateNestedOneWithoutWorkEventsInput = {
    create?: XOR<ContractorCompanyCreateWithoutWorkEventsInput, ContractorCompanyUncheckedCreateWithoutWorkEventsInput>
    connectOrCreate?: ContractorCompanyCreateOrConnectWithoutWorkEventsInput
    connect?: ContractorCompanyWhereUniqueInput
  }

  export type InsuranceClaimCreateNestedOneWithoutWorkEventsInput = {
    create?: XOR<InsuranceClaimCreateWithoutWorkEventsInput, InsuranceClaimUncheckedCreateWithoutWorkEventsInput>
    connectOrCreate?: InsuranceClaimCreateOrConnectWithoutWorkEventsInput
    connect?: InsuranceClaimWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutWorkEventsNestedInput = {
    create?: XOR<PropertyCreateWithoutWorkEventsInput, PropertyUncheckedCreateWithoutWorkEventsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutWorkEventsInput
    upsert?: PropertyUpsertWithoutWorkEventsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutWorkEventsInput, PropertyUpdateWithoutWorkEventsInput>, PropertyUncheckedUpdateWithoutWorkEventsInput>
  }

  export type ContractorCompanyUpdateOneWithoutWorkEventsNestedInput = {
    create?: XOR<ContractorCompanyCreateWithoutWorkEventsInput, ContractorCompanyUncheckedCreateWithoutWorkEventsInput>
    connectOrCreate?: ContractorCompanyCreateOrConnectWithoutWorkEventsInput
    upsert?: ContractorCompanyUpsertWithoutWorkEventsInput
    disconnect?: ContractorCompanyWhereInput | boolean
    delete?: ContractorCompanyWhereInput | boolean
    connect?: ContractorCompanyWhereUniqueInput
    update?: XOR<XOR<ContractorCompanyUpdateToOneWithWhereWithoutWorkEventsInput, ContractorCompanyUpdateWithoutWorkEventsInput>, ContractorCompanyUncheckedUpdateWithoutWorkEventsInput>
  }

  export type InsuranceClaimUpdateOneWithoutWorkEventsNestedInput = {
    create?: XOR<InsuranceClaimCreateWithoutWorkEventsInput, InsuranceClaimUncheckedCreateWithoutWorkEventsInput>
    connectOrCreate?: InsuranceClaimCreateOrConnectWithoutWorkEventsInput
    upsert?: InsuranceClaimUpsertWithoutWorkEventsInput
    disconnect?: InsuranceClaimWhereInput | boolean
    delete?: InsuranceClaimWhereInput | boolean
    connect?: InsuranceClaimWhereUniqueInput
    update?: XOR<XOR<InsuranceClaimUpdateToOneWithWhereWithoutWorkEventsInput, InsuranceClaimUpdateWithoutWorkEventsInput>, InsuranceClaimUncheckedUpdateWithoutWorkEventsInput>
  }

  export type PropertyCreateNestedOneWithoutRentalSignalsInput = {
    create?: XOR<PropertyCreateWithoutRentalSignalsInput, PropertyUncheckedCreateWithoutRentalSignalsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutRentalSignalsInput
    connect?: PropertyWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutRentalSignalsNestedInput = {
    create?: XOR<PropertyCreateWithoutRentalSignalsInput, PropertyUncheckedCreateWithoutRentalSignalsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutRentalSignalsInput
    upsert?: PropertyUpsertWithoutRentalSignalsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutRentalSignalsInput, PropertyUpdateWithoutRentalSignalsInput>, PropertyUncheckedUpdateWithoutRentalSignalsInput>
  }

  export type PropertyCreateNestedOneWithoutInsuranceClaimsInput = {
    create?: XOR<PropertyCreateWithoutInsuranceClaimsInput, PropertyUncheckedCreateWithoutInsuranceClaimsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutInsuranceClaimsInput
    connect?: PropertyWhereUniqueInput
  }

  export type ContractorCompanyCreateNestedOneWithoutInsuranceClaimsInput = {
    create?: XOR<ContractorCompanyCreateWithoutInsuranceClaimsInput, ContractorCompanyUncheckedCreateWithoutInsuranceClaimsInput>
    connectOrCreate?: ContractorCompanyCreateOrConnectWithoutInsuranceClaimsInput
    connect?: ContractorCompanyWhereUniqueInput
  }

  export type WorkEventCreateNestedManyWithoutInsuranceClaimInput = {
    create?: XOR<WorkEventCreateWithoutInsuranceClaimInput, WorkEventUncheckedCreateWithoutInsuranceClaimInput> | WorkEventCreateWithoutInsuranceClaimInput[] | WorkEventUncheckedCreateWithoutInsuranceClaimInput[]
    connectOrCreate?: WorkEventCreateOrConnectWithoutInsuranceClaimInput | WorkEventCreateOrConnectWithoutInsuranceClaimInput[]
    createMany?: WorkEventCreateManyInsuranceClaimInputEnvelope
    connect?: WorkEventWhereUniqueInput | WorkEventWhereUniqueInput[]
  }

  export type WorkEventUncheckedCreateNestedManyWithoutInsuranceClaimInput = {
    create?: XOR<WorkEventCreateWithoutInsuranceClaimInput, WorkEventUncheckedCreateWithoutInsuranceClaimInput> | WorkEventCreateWithoutInsuranceClaimInput[] | WorkEventUncheckedCreateWithoutInsuranceClaimInput[]
    connectOrCreate?: WorkEventCreateOrConnectWithoutInsuranceClaimInput | WorkEventCreateOrConnectWithoutInsuranceClaimInput[]
    createMany?: WorkEventCreateManyInsuranceClaimInputEnvelope
    connect?: WorkEventWhereUniqueInput | WorkEventWhereUniqueInput[]
  }

  export type PropertyUpdateOneRequiredWithoutInsuranceClaimsNestedInput = {
    create?: XOR<PropertyCreateWithoutInsuranceClaimsInput, PropertyUncheckedCreateWithoutInsuranceClaimsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutInsuranceClaimsInput
    upsert?: PropertyUpsertWithoutInsuranceClaimsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutInsuranceClaimsInput, PropertyUpdateWithoutInsuranceClaimsInput>, PropertyUncheckedUpdateWithoutInsuranceClaimsInput>
  }

  export type ContractorCompanyUpdateOneWithoutInsuranceClaimsNestedInput = {
    create?: XOR<ContractorCompanyCreateWithoutInsuranceClaimsInput, ContractorCompanyUncheckedCreateWithoutInsuranceClaimsInput>
    connectOrCreate?: ContractorCompanyCreateOrConnectWithoutInsuranceClaimsInput
    upsert?: ContractorCompanyUpsertWithoutInsuranceClaimsInput
    disconnect?: ContractorCompanyWhereInput | boolean
    delete?: ContractorCompanyWhereInput | boolean
    connect?: ContractorCompanyWhereUniqueInput
    update?: XOR<XOR<ContractorCompanyUpdateToOneWithWhereWithoutInsuranceClaimsInput, ContractorCompanyUpdateWithoutInsuranceClaimsInput>, ContractorCompanyUncheckedUpdateWithoutInsuranceClaimsInput>
  }

  export type WorkEventUpdateManyWithoutInsuranceClaimNestedInput = {
    create?: XOR<WorkEventCreateWithoutInsuranceClaimInput, WorkEventUncheckedCreateWithoutInsuranceClaimInput> | WorkEventCreateWithoutInsuranceClaimInput[] | WorkEventUncheckedCreateWithoutInsuranceClaimInput[]
    connectOrCreate?: WorkEventCreateOrConnectWithoutInsuranceClaimInput | WorkEventCreateOrConnectWithoutInsuranceClaimInput[]
    upsert?: WorkEventUpsertWithWhereUniqueWithoutInsuranceClaimInput | WorkEventUpsertWithWhereUniqueWithoutInsuranceClaimInput[]
    createMany?: WorkEventCreateManyInsuranceClaimInputEnvelope
    set?: WorkEventWhereUniqueInput | WorkEventWhereUniqueInput[]
    disconnect?: WorkEventWhereUniqueInput | WorkEventWhereUniqueInput[]
    delete?: WorkEventWhereUniqueInput | WorkEventWhereUniqueInput[]
    connect?: WorkEventWhereUniqueInput | WorkEventWhereUniqueInput[]
    update?: WorkEventUpdateWithWhereUniqueWithoutInsuranceClaimInput | WorkEventUpdateWithWhereUniqueWithoutInsuranceClaimInput[]
    updateMany?: WorkEventUpdateManyWithWhereWithoutInsuranceClaimInput | WorkEventUpdateManyWithWhereWithoutInsuranceClaimInput[]
    deleteMany?: WorkEventScalarWhereInput | WorkEventScalarWhereInput[]
  }

  export type WorkEventUncheckedUpdateManyWithoutInsuranceClaimNestedInput = {
    create?: XOR<WorkEventCreateWithoutInsuranceClaimInput, WorkEventUncheckedCreateWithoutInsuranceClaimInput> | WorkEventCreateWithoutInsuranceClaimInput[] | WorkEventUncheckedCreateWithoutInsuranceClaimInput[]
    connectOrCreate?: WorkEventCreateOrConnectWithoutInsuranceClaimInput | WorkEventCreateOrConnectWithoutInsuranceClaimInput[]
    upsert?: WorkEventUpsertWithWhereUniqueWithoutInsuranceClaimInput | WorkEventUpsertWithWhereUniqueWithoutInsuranceClaimInput[]
    createMany?: WorkEventCreateManyInsuranceClaimInputEnvelope
    set?: WorkEventWhereUniqueInput | WorkEventWhereUniqueInput[]
    disconnect?: WorkEventWhereUniqueInput | WorkEventWhereUniqueInput[]
    delete?: WorkEventWhereUniqueInput | WorkEventWhereUniqueInput[]
    connect?: WorkEventWhereUniqueInput | WorkEventWhereUniqueInput[]
    update?: WorkEventUpdateWithWhereUniqueWithoutInsuranceClaimInput | WorkEventUpdateWithWhereUniqueWithoutInsuranceClaimInput[]
    updateMany?: WorkEventUpdateManyWithWhereWithoutInsuranceClaimInput | WorkEventUpdateManyWithWhereWithoutInsuranceClaimInput[]
    deleteMany?: WorkEventScalarWhereInput | WorkEventScalarWhereInput[]
  }

  export type PropertyCreateNestedOneWithoutReportsInput = {
    create?: XOR<PropertyCreateWithoutReportsInput, PropertyUncheckedCreateWithoutReportsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutReportsInput
    connect?: PropertyWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<PropertyCreateWithoutReportsInput, PropertyUncheckedCreateWithoutReportsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutReportsInput
    upsert?: PropertyUpsertWithoutReportsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutReportsInput, PropertyUpdateWithoutReportsInput>, PropertyUncheckedUpdateWithoutReportsInput>
  }

  export type NotificationSubscriptionCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationSubscriptionCreateWithoutUserInput, NotificationSubscriptionUncheckedCreateWithoutUserInput> | NotificationSubscriptionCreateWithoutUserInput[] | NotificationSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationSubscriptionCreateOrConnectWithoutUserInput | NotificationSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: NotificationSubscriptionCreateManyUserInputEnvelope
    connect?: NotificationSubscriptionWhereUniqueInput | NotificationSubscriptionWhereUniqueInput[]
  }

  export type NotificationSubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationSubscriptionCreateWithoutUserInput, NotificationSubscriptionUncheckedCreateWithoutUserInput> | NotificationSubscriptionCreateWithoutUserInput[] | NotificationSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationSubscriptionCreateOrConnectWithoutUserInput | NotificationSubscriptionCreateOrConnectWithoutUserInput[]
    createMany?: NotificationSubscriptionCreateManyUserInputEnvelope
    connect?: NotificationSubscriptionWhereUniqueInput | NotificationSubscriptionWhereUniqueInput[]
  }

  export type NotificationSubscriptionUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationSubscriptionCreateWithoutUserInput, NotificationSubscriptionUncheckedCreateWithoutUserInput> | NotificationSubscriptionCreateWithoutUserInput[] | NotificationSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationSubscriptionCreateOrConnectWithoutUserInput | NotificationSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: NotificationSubscriptionUpsertWithWhereUniqueWithoutUserInput | NotificationSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationSubscriptionCreateManyUserInputEnvelope
    set?: NotificationSubscriptionWhereUniqueInput | NotificationSubscriptionWhereUniqueInput[]
    disconnect?: NotificationSubscriptionWhereUniqueInput | NotificationSubscriptionWhereUniqueInput[]
    delete?: NotificationSubscriptionWhereUniqueInput | NotificationSubscriptionWhereUniqueInput[]
    connect?: NotificationSubscriptionWhereUniqueInput | NotificationSubscriptionWhereUniqueInput[]
    update?: NotificationSubscriptionUpdateWithWhereUniqueWithoutUserInput | NotificationSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationSubscriptionUpdateManyWithWhereWithoutUserInput | NotificationSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationSubscriptionScalarWhereInput | NotificationSubscriptionScalarWhereInput[]
  }

  export type NotificationSubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationSubscriptionCreateWithoutUserInput, NotificationSubscriptionUncheckedCreateWithoutUserInput> | NotificationSubscriptionCreateWithoutUserInput[] | NotificationSubscriptionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationSubscriptionCreateOrConnectWithoutUserInput | NotificationSubscriptionCreateOrConnectWithoutUserInput[]
    upsert?: NotificationSubscriptionUpsertWithWhereUniqueWithoutUserInput | NotificationSubscriptionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationSubscriptionCreateManyUserInputEnvelope
    set?: NotificationSubscriptionWhereUniqueInput | NotificationSubscriptionWhereUniqueInput[]
    disconnect?: NotificationSubscriptionWhereUniqueInput | NotificationSubscriptionWhereUniqueInput[]
    delete?: NotificationSubscriptionWhereUniqueInput | NotificationSubscriptionWhereUniqueInput[]
    connect?: NotificationSubscriptionWhereUniqueInput | NotificationSubscriptionWhereUniqueInput[]
    update?: NotificationSubscriptionUpdateWithWhereUniqueWithoutUserInput | NotificationSubscriptionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationSubscriptionUpdateManyWithWhereWithoutUserInput | NotificationSubscriptionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationSubscriptionScalarWhereInput | NotificationSubscriptionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type PropertyCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<PropertyCreateWithoutNotificationsInput, PropertyUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutNotificationsInput
    connect?: PropertyWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type PropertyUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<PropertyCreateWithoutNotificationsInput, PropertyUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutNotificationsInput
    upsert?: PropertyUpsertWithoutNotificationsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutNotificationsInput, PropertyUpdateWithoutNotificationsInput>, PropertyUncheckedUpdateWithoutNotificationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SourceRecordCreateWithoutPropertyInput = {
    id?: string
    source: string
    sourceId?: string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    ingestedAt?: Date | string
    version?: number
  }

  export type SourceRecordUncheckedCreateWithoutPropertyInput = {
    id?: string
    source: string
    sourceId?: string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    ingestedAt?: Date | string
    version?: number
  }

  export type SourceRecordCreateOrConnectWithoutPropertyInput = {
    where: SourceRecordWhereUniqueInput
    create: XOR<SourceRecordCreateWithoutPropertyInput, SourceRecordUncheckedCreateWithoutPropertyInput>
  }

  export type SourceRecordCreateManyPropertyInputEnvelope = {
    data: SourceRecordCreateManyPropertyInput | SourceRecordCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type OwnershipEventCreateWithoutPropertyInput = {
    id?: string
    ownerName: string
    ownerType?: string | null
    fromDate: Date | string
    toDate?: Date | string | null
    isCurrent?: boolean
    documentRef?: string | null
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OwnershipEventUncheckedCreateWithoutPropertyInput = {
    id?: string
    ownerName: string
    ownerType?: string | null
    fromDate: Date | string
    toDate?: Date | string | null
    isCurrent?: boolean
    documentRef?: string | null
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OwnershipEventCreateOrConnectWithoutPropertyInput = {
    where: OwnershipEventWhereUniqueInput
    create: XOR<OwnershipEventCreateWithoutPropertyInput, OwnershipEventUncheckedCreateWithoutPropertyInput>
  }

  export type OwnershipEventCreateManyPropertyInputEnvelope = {
    data: OwnershipEventCreateManyPropertyInput | OwnershipEventCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type SaleCreateWithoutPropertyInput = {
    id?: string
    saleDate: Date | string
    salePrice: number
    saleType?: string | null
    buyerName?: string | null
    sellerName?: string | null
    documentRef?: string | null
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleUncheckedCreateWithoutPropertyInput = {
    id?: string
    saleDate: Date | string
    salePrice: number
    saleType?: string | null
    buyerName?: string | null
    sellerName?: string | null
    documentRef?: string | null
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleCreateOrConnectWithoutPropertyInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutPropertyInput, SaleUncheckedCreateWithoutPropertyInput>
  }

  export type SaleCreateManyPropertyInputEnvelope = {
    data: SaleCreateManyPropertyInput | SaleCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type PermitCreateWithoutPropertyInput = {
    id?: string
    permitNumber: string
    permitType: string
    status: string
    issuedDate?: Date | string | null
    completedDate?: Date | string | null
    expirationDate?: Date | string | null
    description?: string | null
    contractorName?: string | null
    jurisdiction: string
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermitUncheckedCreateWithoutPropertyInput = {
    id?: string
    permitNumber: string
    permitType: string
    status: string
    issuedDate?: Date | string | null
    completedDate?: Date | string | null
    expirationDate?: Date | string | null
    description?: string | null
    contractorName?: string | null
    jurisdiction: string
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermitCreateOrConnectWithoutPropertyInput = {
    where: PermitWhereUniqueInput
    create: XOR<PermitCreateWithoutPropertyInput, PermitUncheckedCreateWithoutPropertyInput>
  }

  export type PermitCreateManyPropertyInputEnvelope = {
    data: PermitCreateManyPropertyInput | PermitCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type WorkEventCreateWithoutPropertyInput = {
    id?: string
    workType: string
    description?: string | null
    workDate: Date | string
    cost?: number | null
    invoiceNumber?: string | null
    documentUrl?: string | null
    verificationStatus?: string
    warrantyPeriodMonths?: number | null
    warrantyExpirationDate?: Date | string | null
    warrantyType?: string | null
    warrantyDetails?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contractor?: ContractorCompanyCreateNestedOneWithoutWorkEventsInput
    insuranceClaim?: InsuranceClaimCreateNestedOneWithoutWorkEventsInput
  }

  export type WorkEventUncheckedCreateWithoutPropertyInput = {
    id?: string
    contractorId?: string | null
    workType: string
    description?: string | null
    workDate: Date | string
    cost?: number | null
    invoiceNumber?: string | null
    documentUrl?: string | null
    verificationStatus?: string
    warrantyPeriodMonths?: number | null
    warrantyExpirationDate?: Date | string | null
    warrantyType?: string | null
    warrantyDetails?: string | null
    insuranceClaimId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkEventCreateOrConnectWithoutPropertyInput = {
    where: WorkEventWhereUniqueInput
    create: XOR<WorkEventCreateWithoutPropertyInput, WorkEventUncheckedCreateWithoutPropertyInput>
  }

  export type WorkEventCreateManyPropertyInputEnvelope = {
    data: WorkEventCreateManyPropertyInput | WorkEventCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type RentalSignalCreateWithoutPropertyInput = {
    id?: string
    source: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    confidence?: number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RentalSignalUncheckedCreateWithoutPropertyInput = {
    id?: string
    source: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    confidence?: number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RentalSignalCreateOrConnectWithoutPropertyInput = {
    where: RentalSignalWhereUniqueInput
    create: XOR<RentalSignalCreateWithoutPropertyInput, RentalSignalUncheckedCreateWithoutPropertyInput>
  }

  export type RentalSignalCreateManyPropertyInputEnvelope = {
    data: RentalSignalCreateManyPropertyInput | RentalSignalCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type InsuranceClaimCreateWithoutPropertyInput = {
    id?: string
    claimType: string
    claimDate: Date | string
    amount?: number | null
    status?: string | null
    submittedBy?: string | null
    verificationStatus?: string
    documentUrl?: string | null
    workDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contractor?: ContractorCompanyCreateNestedOneWithoutInsuranceClaimsInput
    workEvents?: WorkEventCreateNestedManyWithoutInsuranceClaimInput
  }

  export type InsuranceClaimUncheckedCreateWithoutPropertyInput = {
    id?: string
    claimType: string
    claimDate: Date | string
    amount?: number | null
    status?: string | null
    submittedBy?: string | null
    verificationStatus?: string
    documentUrl?: string | null
    contractorId?: string | null
    workDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workEvents?: WorkEventUncheckedCreateNestedManyWithoutInsuranceClaimInput
  }

  export type InsuranceClaimCreateOrConnectWithoutPropertyInput = {
    where: InsuranceClaimWhereUniqueInput
    create: XOR<InsuranceClaimCreateWithoutPropertyInput, InsuranceClaimUncheckedCreateWithoutPropertyInput>
  }

  export type InsuranceClaimCreateManyPropertyInputEnvelope = {
    data: InsuranceClaimCreateManyPropertyInput | InsuranceClaimCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutPropertyInput = {
    id?: string
    version?: number
    generatedAt?: Date | string
    snapshot: JsonNullValueInput | InputJsonValue
    shareToken?: string | null
    createdAt?: Date | string
  }

  export type ReportUncheckedCreateWithoutPropertyInput = {
    id?: string
    version?: number
    generatedAt?: Date | string
    snapshot: JsonNullValueInput | InputJsonValue
    shareToken?: string | null
    createdAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutPropertyInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutPropertyInput, ReportUncheckedCreateWithoutPropertyInput>
  }

  export type ReportCreateManyPropertyInputEnvelope = {
    data: ReportCreateManyPropertyInput | ReportCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type NotificationSubscriptionCreateWithoutPropertyInput = {
    id?: string
    eventType: string
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationSubscriptionUncheckedCreateWithoutPropertyInput = {
    id?: string
    userId: string
    eventType: string
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationSubscriptionCreateOrConnectWithoutPropertyInput = {
    where: NotificationSubscriptionWhereUniqueInput
    create: XOR<NotificationSubscriptionCreateWithoutPropertyInput, NotificationSubscriptionUncheckedCreateWithoutPropertyInput>
  }

  export type NotificationSubscriptionCreateManyPropertyInputEnvelope = {
    data: NotificationSubscriptionCreateManyPropertyInput | NotificationSubscriptionCreateManyPropertyInput[]
    skipDuplicates?: boolean
  }

  export type SourceRecordUpsertWithWhereUniqueWithoutPropertyInput = {
    where: SourceRecordWhereUniqueInput
    update: XOR<SourceRecordUpdateWithoutPropertyInput, SourceRecordUncheckedUpdateWithoutPropertyInput>
    create: XOR<SourceRecordCreateWithoutPropertyInput, SourceRecordUncheckedCreateWithoutPropertyInput>
  }

  export type SourceRecordUpdateWithWhereUniqueWithoutPropertyInput = {
    where: SourceRecordWhereUniqueInput
    data: XOR<SourceRecordUpdateWithoutPropertyInput, SourceRecordUncheckedUpdateWithoutPropertyInput>
  }

  export type SourceRecordUpdateManyWithWhereWithoutPropertyInput = {
    where: SourceRecordScalarWhereInput
    data: XOR<SourceRecordUpdateManyMutationInput, SourceRecordUncheckedUpdateManyWithoutPropertyInput>
  }

  export type SourceRecordScalarWhereInput = {
    AND?: SourceRecordScalarWhereInput | SourceRecordScalarWhereInput[]
    OR?: SourceRecordScalarWhereInput[]
    NOT?: SourceRecordScalarWhereInput | SourceRecordScalarWhereInput[]
    id?: StringFilter<"SourceRecord"> | string
    propertyId?: StringFilter<"SourceRecord"> | string
    source?: StringFilter<"SourceRecord"> | string
    sourceId?: StringNullableFilter<"SourceRecord"> | string | null
    rawPayload?: JsonNullableFilter<"SourceRecord">
    ingestedAt?: DateTimeFilter<"SourceRecord"> | Date | string
    version?: IntFilter<"SourceRecord"> | number
  }

  export type OwnershipEventUpsertWithWhereUniqueWithoutPropertyInput = {
    where: OwnershipEventWhereUniqueInput
    update: XOR<OwnershipEventUpdateWithoutPropertyInput, OwnershipEventUncheckedUpdateWithoutPropertyInput>
    create: XOR<OwnershipEventCreateWithoutPropertyInput, OwnershipEventUncheckedCreateWithoutPropertyInput>
  }

  export type OwnershipEventUpdateWithWhereUniqueWithoutPropertyInput = {
    where: OwnershipEventWhereUniqueInput
    data: XOR<OwnershipEventUpdateWithoutPropertyInput, OwnershipEventUncheckedUpdateWithoutPropertyInput>
  }

  export type OwnershipEventUpdateManyWithWhereWithoutPropertyInput = {
    where: OwnershipEventScalarWhereInput
    data: XOR<OwnershipEventUpdateManyMutationInput, OwnershipEventUncheckedUpdateManyWithoutPropertyInput>
  }

  export type OwnershipEventScalarWhereInput = {
    AND?: OwnershipEventScalarWhereInput | OwnershipEventScalarWhereInput[]
    OR?: OwnershipEventScalarWhereInput[]
    NOT?: OwnershipEventScalarWhereInput | OwnershipEventScalarWhereInput[]
    id?: StringFilter<"OwnershipEvent"> | string
    propertyId?: StringFilter<"OwnershipEvent"> | string
    ownerName?: StringFilter<"OwnershipEvent"> | string
    ownerType?: StringNullableFilter<"OwnershipEvent"> | string | null
    fromDate?: DateTimeFilter<"OwnershipEvent"> | Date | string
    toDate?: DateTimeNullableFilter<"OwnershipEvent"> | Date | string | null
    isCurrent?: BoolFilter<"OwnershipEvent"> | boolean
    documentRef?: StringNullableFilter<"OwnershipEvent"> | string | null
    source?: StringFilter<"OwnershipEvent"> | string
    createdAt?: DateTimeFilter<"OwnershipEvent"> | Date | string
    updatedAt?: DateTimeFilter<"OwnershipEvent"> | Date | string
  }

  export type SaleUpsertWithWhereUniqueWithoutPropertyInput = {
    where: SaleWhereUniqueInput
    update: XOR<SaleUpdateWithoutPropertyInput, SaleUncheckedUpdateWithoutPropertyInput>
    create: XOR<SaleCreateWithoutPropertyInput, SaleUncheckedCreateWithoutPropertyInput>
  }

  export type SaleUpdateWithWhereUniqueWithoutPropertyInput = {
    where: SaleWhereUniqueInput
    data: XOR<SaleUpdateWithoutPropertyInput, SaleUncheckedUpdateWithoutPropertyInput>
  }

  export type SaleUpdateManyWithWhereWithoutPropertyInput = {
    where: SaleScalarWhereInput
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyWithoutPropertyInput>
  }

  export type SaleScalarWhereInput = {
    AND?: SaleScalarWhereInput | SaleScalarWhereInput[]
    OR?: SaleScalarWhereInput[]
    NOT?: SaleScalarWhereInput | SaleScalarWhereInput[]
    id?: StringFilter<"Sale"> | string
    propertyId?: StringFilter<"Sale"> | string
    saleDate?: DateTimeFilter<"Sale"> | Date | string
    salePrice?: FloatFilter<"Sale"> | number
    saleType?: StringNullableFilter<"Sale"> | string | null
    buyerName?: StringNullableFilter<"Sale"> | string | null
    sellerName?: StringNullableFilter<"Sale"> | string | null
    documentRef?: StringNullableFilter<"Sale"> | string | null
    source?: StringFilter<"Sale"> | string
    createdAt?: DateTimeFilter<"Sale"> | Date | string
    updatedAt?: DateTimeFilter<"Sale"> | Date | string
  }

  export type PermitUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PermitWhereUniqueInput
    update: XOR<PermitUpdateWithoutPropertyInput, PermitUncheckedUpdateWithoutPropertyInput>
    create: XOR<PermitCreateWithoutPropertyInput, PermitUncheckedCreateWithoutPropertyInput>
  }

  export type PermitUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PermitWhereUniqueInput
    data: XOR<PermitUpdateWithoutPropertyInput, PermitUncheckedUpdateWithoutPropertyInput>
  }

  export type PermitUpdateManyWithWhereWithoutPropertyInput = {
    where: PermitScalarWhereInput
    data: XOR<PermitUpdateManyMutationInput, PermitUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PermitScalarWhereInput = {
    AND?: PermitScalarWhereInput | PermitScalarWhereInput[]
    OR?: PermitScalarWhereInput[]
    NOT?: PermitScalarWhereInput | PermitScalarWhereInput[]
    id?: StringFilter<"Permit"> | string
    propertyId?: StringFilter<"Permit"> | string
    permitNumber?: StringFilter<"Permit"> | string
    permitType?: StringFilter<"Permit"> | string
    status?: StringFilter<"Permit"> | string
    issuedDate?: DateTimeNullableFilter<"Permit"> | Date | string | null
    completedDate?: DateTimeNullableFilter<"Permit"> | Date | string | null
    expirationDate?: DateTimeNullableFilter<"Permit"> | Date | string | null
    description?: StringNullableFilter<"Permit"> | string | null
    contractorName?: StringNullableFilter<"Permit"> | string | null
    jurisdiction?: StringFilter<"Permit"> | string
    source?: StringFilter<"Permit"> | string
    createdAt?: DateTimeFilter<"Permit"> | Date | string
    updatedAt?: DateTimeFilter<"Permit"> | Date | string
  }

  export type WorkEventUpsertWithWhereUniqueWithoutPropertyInput = {
    where: WorkEventWhereUniqueInput
    update: XOR<WorkEventUpdateWithoutPropertyInput, WorkEventUncheckedUpdateWithoutPropertyInput>
    create: XOR<WorkEventCreateWithoutPropertyInput, WorkEventUncheckedCreateWithoutPropertyInput>
  }

  export type WorkEventUpdateWithWhereUniqueWithoutPropertyInput = {
    where: WorkEventWhereUniqueInput
    data: XOR<WorkEventUpdateWithoutPropertyInput, WorkEventUncheckedUpdateWithoutPropertyInput>
  }

  export type WorkEventUpdateManyWithWhereWithoutPropertyInput = {
    where: WorkEventScalarWhereInput
    data: XOR<WorkEventUpdateManyMutationInput, WorkEventUncheckedUpdateManyWithoutPropertyInput>
  }

  export type WorkEventScalarWhereInput = {
    AND?: WorkEventScalarWhereInput | WorkEventScalarWhereInput[]
    OR?: WorkEventScalarWhereInput[]
    NOT?: WorkEventScalarWhereInput | WorkEventScalarWhereInput[]
    id?: StringFilter<"WorkEvent"> | string
    propertyId?: StringFilter<"WorkEvent"> | string
    contractorId?: StringNullableFilter<"WorkEvent"> | string | null
    workType?: StringFilter<"WorkEvent"> | string
    description?: StringNullableFilter<"WorkEvent"> | string | null
    workDate?: DateTimeFilter<"WorkEvent"> | Date | string
    cost?: FloatNullableFilter<"WorkEvent"> | number | null
    invoiceNumber?: StringNullableFilter<"WorkEvent"> | string | null
    documentUrl?: StringNullableFilter<"WorkEvent"> | string | null
    verificationStatus?: StringFilter<"WorkEvent"> | string
    warrantyPeriodMonths?: IntNullableFilter<"WorkEvent"> | number | null
    warrantyExpirationDate?: DateTimeNullableFilter<"WorkEvent"> | Date | string | null
    warrantyType?: StringNullableFilter<"WorkEvent"> | string | null
    warrantyDetails?: StringNullableFilter<"WorkEvent"> | string | null
    insuranceClaimId?: StringNullableFilter<"WorkEvent"> | string | null
    createdAt?: DateTimeFilter<"WorkEvent"> | Date | string
    updatedAt?: DateTimeFilter<"WorkEvent"> | Date | string
  }

  export type RentalSignalUpsertWithWhereUniqueWithoutPropertyInput = {
    where: RentalSignalWhereUniqueInput
    update: XOR<RentalSignalUpdateWithoutPropertyInput, RentalSignalUncheckedUpdateWithoutPropertyInput>
    create: XOR<RentalSignalCreateWithoutPropertyInput, RentalSignalUncheckedCreateWithoutPropertyInput>
  }

  export type RentalSignalUpdateWithWhereUniqueWithoutPropertyInput = {
    where: RentalSignalWhereUniqueInput
    data: XOR<RentalSignalUpdateWithoutPropertyInput, RentalSignalUncheckedUpdateWithoutPropertyInput>
  }

  export type RentalSignalUpdateManyWithWhereWithoutPropertyInput = {
    where: RentalSignalScalarWhereInput
    data: XOR<RentalSignalUpdateManyMutationInput, RentalSignalUncheckedUpdateManyWithoutPropertyInput>
  }

  export type RentalSignalScalarWhereInput = {
    AND?: RentalSignalScalarWhereInput | RentalSignalScalarWhereInput[]
    OR?: RentalSignalScalarWhereInput[]
    NOT?: RentalSignalScalarWhereInput | RentalSignalScalarWhereInput[]
    id?: StringFilter<"RentalSignal"> | string
    propertyId?: StringFilter<"RentalSignal"> | string
    source?: StringFilter<"RentalSignal"> | string
    startDate?: DateTimeNullableFilter<"RentalSignal"> | Date | string | null
    endDate?: DateTimeNullableFilter<"RentalSignal"> | Date | string | null
    confidence?: FloatFilter<"RentalSignal"> | number
    evidence?: JsonNullableFilter<"RentalSignal">
    createdAt?: DateTimeFilter<"RentalSignal"> | Date | string
    updatedAt?: DateTimeFilter<"RentalSignal"> | Date | string
  }

  export type InsuranceClaimUpsertWithWhereUniqueWithoutPropertyInput = {
    where: InsuranceClaimWhereUniqueInput
    update: XOR<InsuranceClaimUpdateWithoutPropertyInput, InsuranceClaimUncheckedUpdateWithoutPropertyInput>
    create: XOR<InsuranceClaimCreateWithoutPropertyInput, InsuranceClaimUncheckedCreateWithoutPropertyInput>
  }

  export type InsuranceClaimUpdateWithWhereUniqueWithoutPropertyInput = {
    where: InsuranceClaimWhereUniqueInput
    data: XOR<InsuranceClaimUpdateWithoutPropertyInput, InsuranceClaimUncheckedUpdateWithoutPropertyInput>
  }

  export type InsuranceClaimUpdateManyWithWhereWithoutPropertyInput = {
    where: InsuranceClaimScalarWhereInput
    data: XOR<InsuranceClaimUpdateManyMutationInput, InsuranceClaimUncheckedUpdateManyWithoutPropertyInput>
  }

  export type InsuranceClaimScalarWhereInput = {
    AND?: InsuranceClaimScalarWhereInput | InsuranceClaimScalarWhereInput[]
    OR?: InsuranceClaimScalarWhereInput[]
    NOT?: InsuranceClaimScalarWhereInput | InsuranceClaimScalarWhereInput[]
    id?: StringFilter<"InsuranceClaim"> | string
    propertyId?: StringFilter<"InsuranceClaim"> | string
    claimType?: StringFilter<"InsuranceClaim"> | string
    claimDate?: DateTimeFilter<"InsuranceClaim"> | Date | string
    amount?: FloatNullableFilter<"InsuranceClaim"> | number | null
    status?: StringNullableFilter<"InsuranceClaim"> | string | null
    submittedBy?: StringNullableFilter<"InsuranceClaim"> | string | null
    verificationStatus?: StringFilter<"InsuranceClaim"> | string
    documentUrl?: StringNullableFilter<"InsuranceClaim"> | string | null
    contractorId?: StringNullableFilter<"InsuranceClaim"> | string | null
    workDescription?: StringNullableFilter<"InsuranceClaim"> | string | null
    createdAt?: DateTimeFilter<"InsuranceClaim"> | Date | string
    updatedAt?: DateTimeFilter<"InsuranceClaim"> | Date | string
  }

  export type ReportUpsertWithWhereUniqueWithoutPropertyInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutPropertyInput, ReportUncheckedUpdateWithoutPropertyInput>
    create: XOR<ReportCreateWithoutPropertyInput, ReportUncheckedCreateWithoutPropertyInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutPropertyInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutPropertyInput, ReportUncheckedUpdateWithoutPropertyInput>
  }

  export type ReportUpdateManyWithWhereWithoutPropertyInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutPropertyInput>
  }

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[]
    OR?: ReportScalarWhereInput[]
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[]
    id?: StringFilter<"Report"> | string
    propertyId?: StringFilter<"Report"> | string
    version?: IntFilter<"Report"> | number
    generatedAt?: DateTimeFilter<"Report"> | Date | string
    snapshot?: JsonFilter<"Report">
    shareToken?: StringNullableFilter<"Report"> | string | null
    createdAt?: DateTimeFilter<"Report"> | Date | string
  }

  export type NotificationSubscriptionUpsertWithWhereUniqueWithoutPropertyInput = {
    where: NotificationSubscriptionWhereUniqueInput
    update: XOR<NotificationSubscriptionUpdateWithoutPropertyInput, NotificationSubscriptionUncheckedUpdateWithoutPropertyInput>
    create: XOR<NotificationSubscriptionCreateWithoutPropertyInput, NotificationSubscriptionUncheckedCreateWithoutPropertyInput>
  }

  export type NotificationSubscriptionUpdateWithWhereUniqueWithoutPropertyInput = {
    where: NotificationSubscriptionWhereUniqueInput
    data: XOR<NotificationSubscriptionUpdateWithoutPropertyInput, NotificationSubscriptionUncheckedUpdateWithoutPropertyInput>
  }

  export type NotificationSubscriptionUpdateManyWithWhereWithoutPropertyInput = {
    where: NotificationSubscriptionScalarWhereInput
    data: XOR<NotificationSubscriptionUpdateManyMutationInput, NotificationSubscriptionUncheckedUpdateManyWithoutPropertyInput>
  }

  export type NotificationSubscriptionScalarWhereInput = {
    AND?: NotificationSubscriptionScalarWhereInput | NotificationSubscriptionScalarWhereInput[]
    OR?: NotificationSubscriptionScalarWhereInput[]
    NOT?: NotificationSubscriptionScalarWhereInput | NotificationSubscriptionScalarWhereInput[]
    id?: StringFilter<"NotificationSubscription"> | string
    userId?: StringFilter<"NotificationSubscription"> | string
    propertyId?: StringFilter<"NotificationSubscription"> | string
    eventType?: StringFilter<"NotificationSubscription"> | string
    enabled?: BoolFilter<"NotificationSubscription"> | boolean
    createdAt?: DateTimeFilter<"NotificationSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationSubscription"> | Date | string
  }

  export type PropertyCreateWithoutSourceRecordsInput = {
    id?: string
    apn?: string | null
    address: string
    addressLine2?: string | null
    city: string
    state?: string
    zipCode: string
    county?: string
    latitude?: number | null
    longitude?: number | null
    lotSize?: number | null
    livingArea?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    propertyType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownershipEvents?: OwnershipEventCreateNestedManyWithoutPropertyInput
    sales?: SaleCreateNestedManyWithoutPropertyInput
    permits?: PermitCreateNestedManyWithoutPropertyInput
    workEvents?: WorkEventCreateNestedManyWithoutPropertyInput
    rentalSignals?: RentalSignalCreateNestedManyWithoutPropertyInput
    insuranceClaims?: InsuranceClaimCreateNestedManyWithoutPropertyInput
    reports?: ReportCreateNestedManyWithoutPropertyInput
    notifications?: NotificationSubscriptionCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutSourceRecordsInput = {
    id?: string
    apn?: string | null
    address: string
    addressLine2?: string | null
    city: string
    state?: string
    zipCode: string
    county?: string
    latitude?: number | null
    longitude?: number | null
    lotSize?: number | null
    livingArea?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    propertyType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ownershipEvents?: OwnershipEventUncheckedCreateNestedManyWithoutPropertyInput
    sales?: SaleUncheckedCreateNestedManyWithoutPropertyInput
    permits?: PermitUncheckedCreateNestedManyWithoutPropertyInput
    workEvents?: WorkEventUncheckedCreateNestedManyWithoutPropertyInput
    rentalSignals?: RentalSignalUncheckedCreateNestedManyWithoutPropertyInput
    insuranceClaims?: InsuranceClaimUncheckedCreateNestedManyWithoutPropertyInput
    reports?: ReportUncheckedCreateNestedManyWithoutPropertyInput
    notifications?: NotificationSubscriptionUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutSourceRecordsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutSourceRecordsInput, PropertyUncheckedCreateWithoutSourceRecordsInput>
  }

  export type PropertyUpsertWithoutSourceRecordsInput = {
    update: XOR<PropertyUpdateWithoutSourceRecordsInput, PropertyUncheckedUpdateWithoutSourceRecordsInput>
    create: XOR<PropertyCreateWithoutSourceRecordsInput, PropertyUncheckedCreateWithoutSourceRecordsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutSourceRecordsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutSourceRecordsInput, PropertyUncheckedUpdateWithoutSourceRecordsInput>
  }

  export type PropertyUpdateWithoutSourceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    apn?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    livingArea?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownershipEvents?: OwnershipEventUpdateManyWithoutPropertyNestedInput
    sales?: SaleUpdateManyWithoutPropertyNestedInput
    permits?: PermitUpdateManyWithoutPropertyNestedInput
    workEvents?: WorkEventUpdateManyWithoutPropertyNestedInput
    rentalSignals?: RentalSignalUpdateManyWithoutPropertyNestedInput
    insuranceClaims?: InsuranceClaimUpdateManyWithoutPropertyNestedInput
    reports?: ReportUpdateManyWithoutPropertyNestedInput
    notifications?: NotificationSubscriptionUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutSourceRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    apn?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    livingArea?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ownershipEvents?: OwnershipEventUncheckedUpdateManyWithoutPropertyNestedInput
    sales?: SaleUncheckedUpdateManyWithoutPropertyNestedInput
    permits?: PermitUncheckedUpdateManyWithoutPropertyNestedInput
    workEvents?: WorkEventUncheckedUpdateManyWithoutPropertyNestedInput
    rentalSignals?: RentalSignalUncheckedUpdateManyWithoutPropertyNestedInput
    insuranceClaims?: InsuranceClaimUncheckedUpdateManyWithoutPropertyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutPropertyNestedInput
    notifications?: NotificationSubscriptionUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateWithoutOwnershipEventsInput = {
    id?: string
    apn?: string | null
    address: string
    addressLine2?: string | null
    city: string
    state?: string
    zipCode: string
    county?: string
    latitude?: number | null
    longitude?: number | null
    lotSize?: number | null
    livingArea?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    propertyType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceRecords?: SourceRecordCreateNestedManyWithoutPropertyInput
    sales?: SaleCreateNestedManyWithoutPropertyInput
    permits?: PermitCreateNestedManyWithoutPropertyInput
    workEvents?: WorkEventCreateNestedManyWithoutPropertyInput
    rentalSignals?: RentalSignalCreateNestedManyWithoutPropertyInput
    insuranceClaims?: InsuranceClaimCreateNestedManyWithoutPropertyInput
    reports?: ReportCreateNestedManyWithoutPropertyInput
    notifications?: NotificationSubscriptionCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutOwnershipEventsInput = {
    id?: string
    apn?: string | null
    address: string
    addressLine2?: string | null
    city: string
    state?: string
    zipCode: string
    county?: string
    latitude?: number | null
    longitude?: number | null
    lotSize?: number | null
    livingArea?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    propertyType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceRecords?: SourceRecordUncheckedCreateNestedManyWithoutPropertyInput
    sales?: SaleUncheckedCreateNestedManyWithoutPropertyInput
    permits?: PermitUncheckedCreateNestedManyWithoutPropertyInput
    workEvents?: WorkEventUncheckedCreateNestedManyWithoutPropertyInput
    rentalSignals?: RentalSignalUncheckedCreateNestedManyWithoutPropertyInput
    insuranceClaims?: InsuranceClaimUncheckedCreateNestedManyWithoutPropertyInput
    reports?: ReportUncheckedCreateNestedManyWithoutPropertyInput
    notifications?: NotificationSubscriptionUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutOwnershipEventsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutOwnershipEventsInput, PropertyUncheckedCreateWithoutOwnershipEventsInput>
  }

  export type PropertyUpsertWithoutOwnershipEventsInput = {
    update: XOR<PropertyUpdateWithoutOwnershipEventsInput, PropertyUncheckedUpdateWithoutOwnershipEventsInput>
    create: XOR<PropertyCreateWithoutOwnershipEventsInput, PropertyUncheckedCreateWithoutOwnershipEventsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutOwnershipEventsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutOwnershipEventsInput, PropertyUncheckedUpdateWithoutOwnershipEventsInput>
  }

  export type PropertyUpdateWithoutOwnershipEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    apn?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    livingArea?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceRecords?: SourceRecordUpdateManyWithoutPropertyNestedInput
    sales?: SaleUpdateManyWithoutPropertyNestedInput
    permits?: PermitUpdateManyWithoutPropertyNestedInput
    workEvents?: WorkEventUpdateManyWithoutPropertyNestedInput
    rentalSignals?: RentalSignalUpdateManyWithoutPropertyNestedInput
    insuranceClaims?: InsuranceClaimUpdateManyWithoutPropertyNestedInput
    reports?: ReportUpdateManyWithoutPropertyNestedInput
    notifications?: NotificationSubscriptionUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutOwnershipEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    apn?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    livingArea?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceRecords?: SourceRecordUncheckedUpdateManyWithoutPropertyNestedInput
    sales?: SaleUncheckedUpdateManyWithoutPropertyNestedInput
    permits?: PermitUncheckedUpdateManyWithoutPropertyNestedInput
    workEvents?: WorkEventUncheckedUpdateManyWithoutPropertyNestedInput
    rentalSignals?: RentalSignalUncheckedUpdateManyWithoutPropertyNestedInput
    insuranceClaims?: InsuranceClaimUncheckedUpdateManyWithoutPropertyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutPropertyNestedInput
    notifications?: NotificationSubscriptionUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateWithoutSalesInput = {
    id?: string
    apn?: string | null
    address: string
    addressLine2?: string | null
    city: string
    state?: string
    zipCode: string
    county?: string
    latitude?: number | null
    longitude?: number | null
    lotSize?: number | null
    livingArea?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    propertyType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceRecords?: SourceRecordCreateNestedManyWithoutPropertyInput
    ownershipEvents?: OwnershipEventCreateNestedManyWithoutPropertyInput
    permits?: PermitCreateNestedManyWithoutPropertyInput
    workEvents?: WorkEventCreateNestedManyWithoutPropertyInput
    rentalSignals?: RentalSignalCreateNestedManyWithoutPropertyInput
    insuranceClaims?: InsuranceClaimCreateNestedManyWithoutPropertyInput
    reports?: ReportCreateNestedManyWithoutPropertyInput
    notifications?: NotificationSubscriptionCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutSalesInput = {
    id?: string
    apn?: string | null
    address: string
    addressLine2?: string | null
    city: string
    state?: string
    zipCode: string
    county?: string
    latitude?: number | null
    longitude?: number | null
    lotSize?: number | null
    livingArea?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    propertyType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceRecords?: SourceRecordUncheckedCreateNestedManyWithoutPropertyInput
    ownershipEvents?: OwnershipEventUncheckedCreateNestedManyWithoutPropertyInput
    permits?: PermitUncheckedCreateNestedManyWithoutPropertyInput
    workEvents?: WorkEventUncheckedCreateNestedManyWithoutPropertyInput
    rentalSignals?: RentalSignalUncheckedCreateNestedManyWithoutPropertyInput
    insuranceClaims?: InsuranceClaimUncheckedCreateNestedManyWithoutPropertyInput
    reports?: ReportUncheckedCreateNestedManyWithoutPropertyInput
    notifications?: NotificationSubscriptionUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutSalesInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutSalesInput, PropertyUncheckedCreateWithoutSalesInput>
  }

  export type PropertyUpsertWithoutSalesInput = {
    update: XOR<PropertyUpdateWithoutSalesInput, PropertyUncheckedUpdateWithoutSalesInput>
    create: XOR<PropertyCreateWithoutSalesInput, PropertyUncheckedCreateWithoutSalesInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutSalesInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutSalesInput, PropertyUncheckedUpdateWithoutSalesInput>
  }

  export type PropertyUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    apn?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    livingArea?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceRecords?: SourceRecordUpdateManyWithoutPropertyNestedInput
    ownershipEvents?: OwnershipEventUpdateManyWithoutPropertyNestedInput
    permits?: PermitUpdateManyWithoutPropertyNestedInput
    workEvents?: WorkEventUpdateManyWithoutPropertyNestedInput
    rentalSignals?: RentalSignalUpdateManyWithoutPropertyNestedInput
    insuranceClaims?: InsuranceClaimUpdateManyWithoutPropertyNestedInput
    reports?: ReportUpdateManyWithoutPropertyNestedInput
    notifications?: NotificationSubscriptionUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    apn?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    livingArea?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceRecords?: SourceRecordUncheckedUpdateManyWithoutPropertyNestedInput
    ownershipEvents?: OwnershipEventUncheckedUpdateManyWithoutPropertyNestedInput
    permits?: PermitUncheckedUpdateManyWithoutPropertyNestedInput
    workEvents?: WorkEventUncheckedUpdateManyWithoutPropertyNestedInput
    rentalSignals?: RentalSignalUncheckedUpdateManyWithoutPropertyNestedInput
    insuranceClaims?: InsuranceClaimUncheckedUpdateManyWithoutPropertyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutPropertyNestedInput
    notifications?: NotificationSubscriptionUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateWithoutPermitsInput = {
    id?: string
    apn?: string | null
    address: string
    addressLine2?: string | null
    city: string
    state?: string
    zipCode: string
    county?: string
    latitude?: number | null
    longitude?: number | null
    lotSize?: number | null
    livingArea?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    propertyType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceRecords?: SourceRecordCreateNestedManyWithoutPropertyInput
    ownershipEvents?: OwnershipEventCreateNestedManyWithoutPropertyInput
    sales?: SaleCreateNestedManyWithoutPropertyInput
    workEvents?: WorkEventCreateNestedManyWithoutPropertyInput
    rentalSignals?: RentalSignalCreateNestedManyWithoutPropertyInput
    insuranceClaims?: InsuranceClaimCreateNestedManyWithoutPropertyInput
    reports?: ReportCreateNestedManyWithoutPropertyInput
    notifications?: NotificationSubscriptionCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutPermitsInput = {
    id?: string
    apn?: string | null
    address: string
    addressLine2?: string | null
    city: string
    state?: string
    zipCode: string
    county?: string
    latitude?: number | null
    longitude?: number | null
    lotSize?: number | null
    livingArea?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    propertyType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceRecords?: SourceRecordUncheckedCreateNestedManyWithoutPropertyInput
    ownershipEvents?: OwnershipEventUncheckedCreateNestedManyWithoutPropertyInput
    sales?: SaleUncheckedCreateNestedManyWithoutPropertyInput
    workEvents?: WorkEventUncheckedCreateNestedManyWithoutPropertyInput
    rentalSignals?: RentalSignalUncheckedCreateNestedManyWithoutPropertyInput
    insuranceClaims?: InsuranceClaimUncheckedCreateNestedManyWithoutPropertyInput
    reports?: ReportUncheckedCreateNestedManyWithoutPropertyInput
    notifications?: NotificationSubscriptionUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutPermitsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutPermitsInput, PropertyUncheckedCreateWithoutPermitsInput>
  }

  export type PropertyUpsertWithoutPermitsInput = {
    update: XOR<PropertyUpdateWithoutPermitsInput, PropertyUncheckedUpdateWithoutPermitsInput>
    create: XOR<PropertyCreateWithoutPermitsInput, PropertyUncheckedCreateWithoutPermitsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutPermitsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutPermitsInput, PropertyUncheckedUpdateWithoutPermitsInput>
  }

  export type PropertyUpdateWithoutPermitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    apn?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    livingArea?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceRecords?: SourceRecordUpdateManyWithoutPropertyNestedInput
    ownershipEvents?: OwnershipEventUpdateManyWithoutPropertyNestedInput
    sales?: SaleUpdateManyWithoutPropertyNestedInput
    workEvents?: WorkEventUpdateManyWithoutPropertyNestedInput
    rentalSignals?: RentalSignalUpdateManyWithoutPropertyNestedInput
    insuranceClaims?: InsuranceClaimUpdateManyWithoutPropertyNestedInput
    reports?: ReportUpdateManyWithoutPropertyNestedInput
    notifications?: NotificationSubscriptionUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutPermitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    apn?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    livingArea?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceRecords?: SourceRecordUncheckedUpdateManyWithoutPropertyNestedInput
    ownershipEvents?: OwnershipEventUncheckedUpdateManyWithoutPropertyNestedInput
    sales?: SaleUncheckedUpdateManyWithoutPropertyNestedInput
    workEvents?: WorkEventUncheckedUpdateManyWithoutPropertyNestedInput
    rentalSignals?: RentalSignalUncheckedUpdateManyWithoutPropertyNestedInput
    insuranceClaims?: InsuranceClaimUncheckedUpdateManyWithoutPropertyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutPropertyNestedInput
    notifications?: NotificationSubscriptionUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type WorkEventCreateWithoutContractorInput = {
    id?: string
    workType: string
    description?: string | null
    workDate: Date | string
    cost?: number | null
    invoiceNumber?: string | null
    documentUrl?: string | null
    verificationStatus?: string
    warrantyPeriodMonths?: number | null
    warrantyExpirationDate?: Date | string | null
    warrantyType?: string | null
    warrantyDetails?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutWorkEventsInput
    insuranceClaim?: InsuranceClaimCreateNestedOneWithoutWorkEventsInput
  }

  export type WorkEventUncheckedCreateWithoutContractorInput = {
    id?: string
    propertyId: string
    workType: string
    description?: string | null
    workDate: Date | string
    cost?: number | null
    invoiceNumber?: string | null
    documentUrl?: string | null
    verificationStatus?: string
    warrantyPeriodMonths?: number | null
    warrantyExpirationDate?: Date | string | null
    warrantyType?: string | null
    warrantyDetails?: string | null
    insuranceClaimId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkEventCreateOrConnectWithoutContractorInput = {
    where: WorkEventWhereUniqueInput
    create: XOR<WorkEventCreateWithoutContractorInput, WorkEventUncheckedCreateWithoutContractorInput>
  }

  export type WorkEventCreateManyContractorInputEnvelope = {
    data: WorkEventCreateManyContractorInput | WorkEventCreateManyContractorInput[]
    skipDuplicates?: boolean
  }

  export type InsuranceClaimCreateWithoutContractorInput = {
    id?: string
    claimType: string
    claimDate: Date | string
    amount?: number | null
    status?: string | null
    submittedBy?: string | null
    verificationStatus?: string
    documentUrl?: string | null
    workDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutInsuranceClaimsInput
    workEvents?: WorkEventCreateNestedManyWithoutInsuranceClaimInput
  }

  export type InsuranceClaimUncheckedCreateWithoutContractorInput = {
    id?: string
    propertyId: string
    claimType: string
    claimDate: Date | string
    amount?: number | null
    status?: string | null
    submittedBy?: string | null
    verificationStatus?: string
    documentUrl?: string | null
    workDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workEvents?: WorkEventUncheckedCreateNestedManyWithoutInsuranceClaimInput
  }

  export type InsuranceClaimCreateOrConnectWithoutContractorInput = {
    where: InsuranceClaimWhereUniqueInput
    create: XOR<InsuranceClaimCreateWithoutContractorInput, InsuranceClaimUncheckedCreateWithoutContractorInput>
  }

  export type InsuranceClaimCreateManyContractorInputEnvelope = {
    data: InsuranceClaimCreateManyContractorInput | InsuranceClaimCreateManyContractorInput[]
    skipDuplicates?: boolean
  }

  export type WorkEventUpsertWithWhereUniqueWithoutContractorInput = {
    where: WorkEventWhereUniqueInput
    update: XOR<WorkEventUpdateWithoutContractorInput, WorkEventUncheckedUpdateWithoutContractorInput>
    create: XOR<WorkEventCreateWithoutContractorInput, WorkEventUncheckedCreateWithoutContractorInput>
  }

  export type WorkEventUpdateWithWhereUniqueWithoutContractorInput = {
    where: WorkEventWhereUniqueInput
    data: XOR<WorkEventUpdateWithoutContractorInput, WorkEventUncheckedUpdateWithoutContractorInput>
  }

  export type WorkEventUpdateManyWithWhereWithoutContractorInput = {
    where: WorkEventScalarWhereInput
    data: XOR<WorkEventUpdateManyMutationInput, WorkEventUncheckedUpdateManyWithoutContractorInput>
  }

  export type InsuranceClaimUpsertWithWhereUniqueWithoutContractorInput = {
    where: InsuranceClaimWhereUniqueInput
    update: XOR<InsuranceClaimUpdateWithoutContractorInput, InsuranceClaimUncheckedUpdateWithoutContractorInput>
    create: XOR<InsuranceClaimCreateWithoutContractorInput, InsuranceClaimUncheckedCreateWithoutContractorInput>
  }

  export type InsuranceClaimUpdateWithWhereUniqueWithoutContractorInput = {
    where: InsuranceClaimWhereUniqueInput
    data: XOR<InsuranceClaimUpdateWithoutContractorInput, InsuranceClaimUncheckedUpdateWithoutContractorInput>
  }

  export type InsuranceClaimUpdateManyWithWhereWithoutContractorInput = {
    where: InsuranceClaimScalarWhereInput
    data: XOR<InsuranceClaimUpdateManyMutationInput, InsuranceClaimUncheckedUpdateManyWithoutContractorInput>
  }

  export type PropertyCreateWithoutWorkEventsInput = {
    id?: string
    apn?: string | null
    address: string
    addressLine2?: string | null
    city: string
    state?: string
    zipCode: string
    county?: string
    latitude?: number | null
    longitude?: number | null
    lotSize?: number | null
    livingArea?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    propertyType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceRecords?: SourceRecordCreateNestedManyWithoutPropertyInput
    ownershipEvents?: OwnershipEventCreateNestedManyWithoutPropertyInput
    sales?: SaleCreateNestedManyWithoutPropertyInput
    permits?: PermitCreateNestedManyWithoutPropertyInput
    rentalSignals?: RentalSignalCreateNestedManyWithoutPropertyInput
    insuranceClaims?: InsuranceClaimCreateNestedManyWithoutPropertyInput
    reports?: ReportCreateNestedManyWithoutPropertyInput
    notifications?: NotificationSubscriptionCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutWorkEventsInput = {
    id?: string
    apn?: string | null
    address: string
    addressLine2?: string | null
    city: string
    state?: string
    zipCode: string
    county?: string
    latitude?: number | null
    longitude?: number | null
    lotSize?: number | null
    livingArea?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    propertyType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceRecords?: SourceRecordUncheckedCreateNestedManyWithoutPropertyInput
    ownershipEvents?: OwnershipEventUncheckedCreateNestedManyWithoutPropertyInput
    sales?: SaleUncheckedCreateNestedManyWithoutPropertyInput
    permits?: PermitUncheckedCreateNestedManyWithoutPropertyInput
    rentalSignals?: RentalSignalUncheckedCreateNestedManyWithoutPropertyInput
    insuranceClaims?: InsuranceClaimUncheckedCreateNestedManyWithoutPropertyInput
    reports?: ReportUncheckedCreateNestedManyWithoutPropertyInput
    notifications?: NotificationSubscriptionUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutWorkEventsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutWorkEventsInput, PropertyUncheckedCreateWithoutWorkEventsInput>
  }

  export type ContractorCompanyCreateWithoutWorkEventsInput = {
    id?: string
    name: string
    licenseNumber?: string | null
    licenseType?: string | null
    state?: string
    verificationStatus?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    address?: string | null
    rating?: number | null
    totalJobs?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    insuranceClaims?: InsuranceClaimCreateNestedManyWithoutContractorInput
  }

  export type ContractorCompanyUncheckedCreateWithoutWorkEventsInput = {
    id?: string
    name: string
    licenseNumber?: string | null
    licenseType?: string | null
    state?: string
    verificationStatus?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    address?: string | null
    rating?: number | null
    totalJobs?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    insuranceClaims?: InsuranceClaimUncheckedCreateNestedManyWithoutContractorInput
  }

  export type ContractorCompanyCreateOrConnectWithoutWorkEventsInput = {
    where: ContractorCompanyWhereUniqueInput
    create: XOR<ContractorCompanyCreateWithoutWorkEventsInput, ContractorCompanyUncheckedCreateWithoutWorkEventsInput>
  }

  export type InsuranceClaimCreateWithoutWorkEventsInput = {
    id?: string
    claimType: string
    claimDate: Date | string
    amount?: number | null
    status?: string | null
    submittedBy?: string | null
    verificationStatus?: string
    documentUrl?: string | null
    workDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutInsuranceClaimsInput
    contractor?: ContractorCompanyCreateNestedOneWithoutInsuranceClaimsInput
  }

  export type InsuranceClaimUncheckedCreateWithoutWorkEventsInput = {
    id?: string
    propertyId: string
    claimType: string
    claimDate: Date | string
    amount?: number | null
    status?: string | null
    submittedBy?: string | null
    verificationStatus?: string
    documentUrl?: string | null
    contractorId?: string | null
    workDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InsuranceClaimCreateOrConnectWithoutWorkEventsInput = {
    where: InsuranceClaimWhereUniqueInput
    create: XOR<InsuranceClaimCreateWithoutWorkEventsInput, InsuranceClaimUncheckedCreateWithoutWorkEventsInput>
  }

  export type PropertyUpsertWithoutWorkEventsInput = {
    update: XOR<PropertyUpdateWithoutWorkEventsInput, PropertyUncheckedUpdateWithoutWorkEventsInput>
    create: XOR<PropertyCreateWithoutWorkEventsInput, PropertyUncheckedCreateWithoutWorkEventsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutWorkEventsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutWorkEventsInput, PropertyUncheckedUpdateWithoutWorkEventsInput>
  }

  export type PropertyUpdateWithoutWorkEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    apn?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    livingArea?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceRecords?: SourceRecordUpdateManyWithoutPropertyNestedInput
    ownershipEvents?: OwnershipEventUpdateManyWithoutPropertyNestedInput
    sales?: SaleUpdateManyWithoutPropertyNestedInput
    permits?: PermitUpdateManyWithoutPropertyNestedInput
    rentalSignals?: RentalSignalUpdateManyWithoutPropertyNestedInput
    insuranceClaims?: InsuranceClaimUpdateManyWithoutPropertyNestedInput
    reports?: ReportUpdateManyWithoutPropertyNestedInput
    notifications?: NotificationSubscriptionUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutWorkEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    apn?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    livingArea?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceRecords?: SourceRecordUncheckedUpdateManyWithoutPropertyNestedInput
    ownershipEvents?: OwnershipEventUncheckedUpdateManyWithoutPropertyNestedInput
    sales?: SaleUncheckedUpdateManyWithoutPropertyNestedInput
    permits?: PermitUncheckedUpdateManyWithoutPropertyNestedInput
    rentalSignals?: RentalSignalUncheckedUpdateManyWithoutPropertyNestedInput
    insuranceClaims?: InsuranceClaimUncheckedUpdateManyWithoutPropertyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutPropertyNestedInput
    notifications?: NotificationSubscriptionUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type ContractorCompanyUpsertWithoutWorkEventsInput = {
    update: XOR<ContractorCompanyUpdateWithoutWorkEventsInput, ContractorCompanyUncheckedUpdateWithoutWorkEventsInput>
    create: XOR<ContractorCompanyCreateWithoutWorkEventsInput, ContractorCompanyUncheckedCreateWithoutWorkEventsInput>
    where?: ContractorCompanyWhereInput
  }

  export type ContractorCompanyUpdateToOneWithWhereWithoutWorkEventsInput = {
    where?: ContractorCompanyWhereInput
    data: XOR<ContractorCompanyUpdateWithoutWorkEventsInput, ContractorCompanyUncheckedUpdateWithoutWorkEventsInput>
  }

  export type ContractorCompanyUpdateWithoutWorkEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseType?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    verificationStatus?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalJobs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    insuranceClaims?: InsuranceClaimUpdateManyWithoutContractorNestedInput
  }

  export type ContractorCompanyUncheckedUpdateWithoutWorkEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseType?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    verificationStatus?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalJobs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    insuranceClaims?: InsuranceClaimUncheckedUpdateManyWithoutContractorNestedInput
  }

  export type InsuranceClaimUpsertWithoutWorkEventsInput = {
    update: XOR<InsuranceClaimUpdateWithoutWorkEventsInput, InsuranceClaimUncheckedUpdateWithoutWorkEventsInput>
    create: XOR<InsuranceClaimCreateWithoutWorkEventsInput, InsuranceClaimUncheckedCreateWithoutWorkEventsInput>
    where?: InsuranceClaimWhereInput
  }

  export type InsuranceClaimUpdateToOneWithWhereWithoutWorkEventsInput = {
    where?: InsuranceClaimWhereInput
    data: XOR<InsuranceClaimUpdateWithoutWorkEventsInput, InsuranceClaimUncheckedUpdateWithoutWorkEventsInput>
  }

  export type InsuranceClaimUpdateWithoutWorkEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    claimType?: StringFieldUpdateOperationsInput | string
    claimDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutInsuranceClaimsNestedInput
    contractor?: ContractorCompanyUpdateOneWithoutInsuranceClaimsNestedInput
  }

  export type InsuranceClaimUncheckedUpdateWithoutWorkEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    claimType?: StringFieldUpdateOperationsInput | string
    claimDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contractorId?: NullableStringFieldUpdateOperationsInput | string | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyCreateWithoutRentalSignalsInput = {
    id?: string
    apn?: string | null
    address: string
    addressLine2?: string | null
    city: string
    state?: string
    zipCode: string
    county?: string
    latitude?: number | null
    longitude?: number | null
    lotSize?: number | null
    livingArea?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    propertyType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceRecords?: SourceRecordCreateNestedManyWithoutPropertyInput
    ownershipEvents?: OwnershipEventCreateNestedManyWithoutPropertyInput
    sales?: SaleCreateNestedManyWithoutPropertyInput
    permits?: PermitCreateNestedManyWithoutPropertyInput
    workEvents?: WorkEventCreateNestedManyWithoutPropertyInput
    insuranceClaims?: InsuranceClaimCreateNestedManyWithoutPropertyInput
    reports?: ReportCreateNestedManyWithoutPropertyInput
    notifications?: NotificationSubscriptionCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutRentalSignalsInput = {
    id?: string
    apn?: string | null
    address: string
    addressLine2?: string | null
    city: string
    state?: string
    zipCode: string
    county?: string
    latitude?: number | null
    longitude?: number | null
    lotSize?: number | null
    livingArea?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    propertyType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceRecords?: SourceRecordUncheckedCreateNestedManyWithoutPropertyInput
    ownershipEvents?: OwnershipEventUncheckedCreateNestedManyWithoutPropertyInput
    sales?: SaleUncheckedCreateNestedManyWithoutPropertyInput
    permits?: PermitUncheckedCreateNestedManyWithoutPropertyInput
    workEvents?: WorkEventUncheckedCreateNestedManyWithoutPropertyInput
    insuranceClaims?: InsuranceClaimUncheckedCreateNestedManyWithoutPropertyInput
    reports?: ReportUncheckedCreateNestedManyWithoutPropertyInput
    notifications?: NotificationSubscriptionUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutRentalSignalsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutRentalSignalsInput, PropertyUncheckedCreateWithoutRentalSignalsInput>
  }

  export type PropertyUpsertWithoutRentalSignalsInput = {
    update: XOR<PropertyUpdateWithoutRentalSignalsInput, PropertyUncheckedUpdateWithoutRentalSignalsInput>
    create: XOR<PropertyCreateWithoutRentalSignalsInput, PropertyUncheckedCreateWithoutRentalSignalsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutRentalSignalsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutRentalSignalsInput, PropertyUncheckedUpdateWithoutRentalSignalsInput>
  }

  export type PropertyUpdateWithoutRentalSignalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    apn?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    livingArea?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceRecords?: SourceRecordUpdateManyWithoutPropertyNestedInput
    ownershipEvents?: OwnershipEventUpdateManyWithoutPropertyNestedInput
    sales?: SaleUpdateManyWithoutPropertyNestedInput
    permits?: PermitUpdateManyWithoutPropertyNestedInput
    workEvents?: WorkEventUpdateManyWithoutPropertyNestedInput
    insuranceClaims?: InsuranceClaimUpdateManyWithoutPropertyNestedInput
    reports?: ReportUpdateManyWithoutPropertyNestedInput
    notifications?: NotificationSubscriptionUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutRentalSignalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    apn?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    livingArea?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceRecords?: SourceRecordUncheckedUpdateManyWithoutPropertyNestedInput
    ownershipEvents?: OwnershipEventUncheckedUpdateManyWithoutPropertyNestedInput
    sales?: SaleUncheckedUpdateManyWithoutPropertyNestedInput
    permits?: PermitUncheckedUpdateManyWithoutPropertyNestedInput
    workEvents?: WorkEventUncheckedUpdateManyWithoutPropertyNestedInput
    insuranceClaims?: InsuranceClaimUncheckedUpdateManyWithoutPropertyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutPropertyNestedInput
    notifications?: NotificationSubscriptionUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateWithoutInsuranceClaimsInput = {
    id?: string
    apn?: string | null
    address: string
    addressLine2?: string | null
    city: string
    state?: string
    zipCode: string
    county?: string
    latitude?: number | null
    longitude?: number | null
    lotSize?: number | null
    livingArea?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    propertyType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceRecords?: SourceRecordCreateNestedManyWithoutPropertyInput
    ownershipEvents?: OwnershipEventCreateNestedManyWithoutPropertyInput
    sales?: SaleCreateNestedManyWithoutPropertyInput
    permits?: PermitCreateNestedManyWithoutPropertyInput
    workEvents?: WorkEventCreateNestedManyWithoutPropertyInput
    rentalSignals?: RentalSignalCreateNestedManyWithoutPropertyInput
    reports?: ReportCreateNestedManyWithoutPropertyInput
    notifications?: NotificationSubscriptionCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutInsuranceClaimsInput = {
    id?: string
    apn?: string | null
    address: string
    addressLine2?: string | null
    city: string
    state?: string
    zipCode: string
    county?: string
    latitude?: number | null
    longitude?: number | null
    lotSize?: number | null
    livingArea?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    propertyType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceRecords?: SourceRecordUncheckedCreateNestedManyWithoutPropertyInput
    ownershipEvents?: OwnershipEventUncheckedCreateNestedManyWithoutPropertyInput
    sales?: SaleUncheckedCreateNestedManyWithoutPropertyInput
    permits?: PermitUncheckedCreateNestedManyWithoutPropertyInput
    workEvents?: WorkEventUncheckedCreateNestedManyWithoutPropertyInput
    rentalSignals?: RentalSignalUncheckedCreateNestedManyWithoutPropertyInput
    reports?: ReportUncheckedCreateNestedManyWithoutPropertyInput
    notifications?: NotificationSubscriptionUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutInsuranceClaimsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutInsuranceClaimsInput, PropertyUncheckedCreateWithoutInsuranceClaimsInput>
  }

  export type ContractorCompanyCreateWithoutInsuranceClaimsInput = {
    id?: string
    name: string
    licenseNumber?: string | null
    licenseType?: string | null
    state?: string
    verificationStatus?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    address?: string | null
    rating?: number | null
    totalJobs?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workEvents?: WorkEventCreateNestedManyWithoutContractorInput
  }

  export type ContractorCompanyUncheckedCreateWithoutInsuranceClaimsInput = {
    id?: string
    name: string
    licenseNumber?: string | null
    licenseType?: string | null
    state?: string
    verificationStatus?: string
    phone?: string | null
    email?: string | null
    website?: string | null
    address?: string | null
    rating?: number | null
    totalJobs?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workEvents?: WorkEventUncheckedCreateNestedManyWithoutContractorInput
  }

  export type ContractorCompanyCreateOrConnectWithoutInsuranceClaimsInput = {
    where: ContractorCompanyWhereUniqueInput
    create: XOR<ContractorCompanyCreateWithoutInsuranceClaimsInput, ContractorCompanyUncheckedCreateWithoutInsuranceClaimsInput>
  }

  export type WorkEventCreateWithoutInsuranceClaimInput = {
    id?: string
    workType: string
    description?: string | null
    workDate: Date | string
    cost?: number | null
    invoiceNumber?: string | null
    documentUrl?: string | null
    verificationStatus?: string
    warrantyPeriodMonths?: number | null
    warrantyExpirationDate?: Date | string | null
    warrantyType?: string | null
    warrantyDetails?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutWorkEventsInput
    contractor?: ContractorCompanyCreateNestedOneWithoutWorkEventsInput
  }

  export type WorkEventUncheckedCreateWithoutInsuranceClaimInput = {
    id?: string
    propertyId: string
    contractorId?: string | null
    workType: string
    description?: string | null
    workDate: Date | string
    cost?: number | null
    invoiceNumber?: string | null
    documentUrl?: string | null
    verificationStatus?: string
    warrantyPeriodMonths?: number | null
    warrantyExpirationDate?: Date | string | null
    warrantyType?: string | null
    warrantyDetails?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkEventCreateOrConnectWithoutInsuranceClaimInput = {
    where: WorkEventWhereUniqueInput
    create: XOR<WorkEventCreateWithoutInsuranceClaimInput, WorkEventUncheckedCreateWithoutInsuranceClaimInput>
  }

  export type WorkEventCreateManyInsuranceClaimInputEnvelope = {
    data: WorkEventCreateManyInsuranceClaimInput | WorkEventCreateManyInsuranceClaimInput[]
    skipDuplicates?: boolean
  }

  export type PropertyUpsertWithoutInsuranceClaimsInput = {
    update: XOR<PropertyUpdateWithoutInsuranceClaimsInput, PropertyUncheckedUpdateWithoutInsuranceClaimsInput>
    create: XOR<PropertyCreateWithoutInsuranceClaimsInput, PropertyUncheckedCreateWithoutInsuranceClaimsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutInsuranceClaimsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutInsuranceClaimsInput, PropertyUncheckedUpdateWithoutInsuranceClaimsInput>
  }

  export type PropertyUpdateWithoutInsuranceClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    apn?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    livingArea?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceRecords?: SourceRecordUpdateManyWithoutPropertyNestedInput
    ownershipEvents?: OwnershipEventUpdateManyWithoutPropertyNestedInput
    sales?: SaleUpdateManyWithoutPropertyNestedInput
    permits?: PermitUpdateManyWithoutPropertyNestedInput
    workEvents?: WorkEventUpdateManyWithoutPropertyNestedInput
    rentalSignals?: RentalSignalUpdateManyWithoutPropertyNestedInput
    reports?: ReportUpdateManyWithoutPropertyNestedInput
    notifications?: NotificationSubscriptionUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutInsuranceClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    apn?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    livingArea?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceRecords?: SourceRecordUncheckedUpdateManyWithoutPropertyNestedInput
    ownershipEvents?: OwnershipEventUncheckedUpdateManyWithoutPropertyNestedInput
    sales?: SaleUncheckedUpdateManyWithoutPropertyNestedInput
    permits?: PermitUncheckedUpdateManyWithoutPropertyNestedInput
    workEvents?: WorkEventUncheckedUpdateManyWithoutPropertyNestedInput
    rentalSignals?: RentalSignalUncheckedUpdateManyWithoutPropertyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutPropertyNestedInput
    notifications?: NotificationSubscriptionUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type ContractorCompanyUpsertWithoutInsuranceClaimsInput = {
    update: XOR<ContractorCompanyUpdateWithoutInsuranceClaimsInput, ContractorCompanyUncheckedUpdateWithoutInsuranceClaimsInput>
    create: XOR<ContractorCompanyCreateWithoutInsuranceClaimsInput, ContractorCompanyUncheckedCreateWithoutInsuranceClaimsInput>
    where?: ContractorCompanyWhereInput
  }

  export type ContractorCompanyUpdateToOneWithWhereWithoutInsuranceClaimsInput = {
    where?: ContractorCompanyWhereInput
    data: XOR<ContractorCompanyUpdateWithoutInsuranceClaimsInput, ContractorCompanyUncheckedUpdateWithoutInsuranceClaimsInput>
  }

  export type ContractorCompanyUpdateWithoutInsuranceClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseType?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    verificationStatus?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalJobs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workEvents?: WorkEventUpdateManyWithoutContractorNestedInput
  }

  export type ContractorCompanyUncheckedUpdateWithoutInsuranceClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    licenseType?: NullableStringFieldUpdateOperationsInput | string | null
    state?: StringFieldUpdateOperationsInput | string
    verificationStatus?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalJobs?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workEvents?: WorkEventUncheckedUpdateManyWithoutContractorNestedInput
  }

  export type WorkEventUpsertWithWhereUniqueWithoutInsuranceClaimInput = {
    where: WorkEventWhereUniqueInput
    update: XOR<WorkEventUpdateWithoutInsuranceClaimInput, WorkEventUncheckedUpdateWithoutInsuranceClaimInput>
    create: XOR<WorkEventCreateWithoutInsuranceClaimInput, WorkEventUncheckedCreateWithoutInsuranceClaimInput>
  }

  export type WorkEventUpdateWithWhereUniqueWithoutInsuranceClaimInput = {
    where: WorkEventWhereUniqueInput
    data: XOR<WorkEventUpdateWithoutInsuranceClaimInput, WorkEventUncheckedUpdateWithoutInsuranceClaimInput>
  }

  export type WorkEventUpdateManyWithWhereWithoutInsuranceClaimInput = {
    where: WorkEventScalarWhereInput
    data: XOR<WorkEventUpdateManyMutationInput, WorkEventUncheckedUpdateManyWithoutInsuranceClaimInput>
  }

  export type PropertyCreateWithoutReportsInput = {
    id?: string
    apn?: string | null
    address: string
    addressLine2?: string | null
    city: string
    state?: string
    zipCode: string
    county?: string
    latitude?: number | null
    longitude?: number | null
    lotSize?: number | null
    livingArea?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    propertyType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceRecords?: SourceRecordCreateNestedManyWithoutPropertyInput
    ownershipEvents?: OwnershipEventCreateNestedManyWithoutPropertyInput
    sales?: SaleCreateNestedManyWithoutPropertyInput
    permits?: PermitCreateNestedManyWithoutPropertyInput
    workEvents?: WorkEventCreateNestedManyWithoutPropertyInput
    rentalSignals?: RentalSignalCreateNestedManyWithoutPropertyInput
    insuranceClaims?: InsuranceClaimCreateNestedManyWithoutPropertyInput
    notifications?: NotificationSubscriptionCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutReportsInput = {
    id?: string
    apn?: string | null
    address: string
    addressLine2?: string | null
    city: string
    state?: string
    zipCode: string
    county?: string
    latitude?: number | null
    longitude?: number | null
    lotSize?: number | null
    livingArea?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    propertyType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceRecords?: SourceRecordUncheckedCreateNestedManyWithoutPropertyInput
    ownershipEvents?: OwnershipEventUncheckedCreateNestedManyWithoutPropertyInput
    sales?: SaleUncheckedCreateNestedManyWithoutPropertyInput
    permits?: PermitUncheckedCreateNestedManyWithoutPropertyInput
    workEvents?: WorkEventUncheckedCreateNestedManyWithoutPropertyInput
    rentalSignals?: RentalSignalUncheckedCreateNestedManyWithoutPropertyInput
    insuranceClaims?: InsuranceClaimUncheckedCreateNestedManyWithoutPropertyInput
    notifications?: NotificationSubscriptionUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutReportsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutReportsInput, PropertyUncheckedCreateWithoutReportsInput>
  }

  export type PropertyUpsertWithoutReportsInput = {
    update: XOR<PropertyUpdateWithoutReportsInput, PropertyUncheckedUpdateWithoutReportsInput>
    create: XOR<PropertyCreateWithoutReportsInput, PropertyUncheckedCreateWithoutReportsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutReportsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutReportsInput, PropertyUncheckedUpdateWithoutReportsInput>
  }

  export type PropertyUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    apn?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    livingArea?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceRecords?: SourceRecordUpdateManyWithoutPropertyNestedInput
    ownershipEvents?: OwnershipEventUpdateManyWithoutPropertyNestedInput
    sales?: SaleUpdateManyWithoutPropertyNestedInput
    permits?: PermitUpdateManyWithoutPropertyNestedInput
    workEvents?: WorkEventUpdateManyWithoutPropertyNestedInput
    rentalSignals?: RentalSignalUpdateManyWithoutPropertyNestedInput
    insuranceClaims?: InsuranceClaimUpdateManyWithoutPropertyNestedInput
    notifications?: NotificationSubscriptionUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    apn?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    livingArea?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceRecords?: SourceRecordUncheckedUpdateManyWithoutPropertyNestedInput
    ownershipEvents?: OwnershipEventUncheckedUpdateManyWithoutPropertyNestedInput
    sales?: SaleUncheckedUpdateManyWithoutPropertyNestedInput
    permits?: PermitUncheckedUpdateManyWithoutPropertyNestedInput
    workEvents?: WorkEventUncheckedUpdateManyWithoutPropertyNestedInput
    rentalSignals?: RentalSignalUncheckedUpdateManyWithoutPropertyNestedInput
    insuranceClaims?: InsuranceClaimUncheckedUpdateManyWithoutPropertyNestedInput
    notifications?: NotificationSubscriptionUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type NotificationSubscriptionCreateWithoutUserInput = {
    id?: string
    eventType: string
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationSubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    propertyId: string
    eventType: string
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationSubscriptionCreateOrConnectWithoutUserInput = {
    where: NotificationSubscriptionWhereUniqueInput
    create: XOR<NotificationSubscriptionCreateWithoutUserInput, NotificationSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type NotificationSubscriptionCreateManyUserInputEnvelope = {
    data: NotificationSubscriptionCreateManyUserInput | NotificationSubscriptionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationSubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationSubscriptionWhereUniqueInput
    update: XOR<NotificationSubscriptionUpdateWithoutUserInput, NotificationSubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationSubscriptionCreateWithoutUserInput, NotificationSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type NotificationSubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationSubscriptionWhereUniqueInput
    data: XOR<NotificationSubscriptionUpdateWithoutUserInput, NotificationSubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type NotificationSubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: NotificationSubscriptionScalarWhereInput
    data: XOR<NotificationSubscriptionUpdateManyMutationInput, NotificationSubscriptionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    name?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    name?: string | null
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type PropertyCreateWithoutNotificationsInput = {
    id?: string
    apn?: string | null
    address: string
    addressLine2?: string | null
    city: string
    state?: string
    zipCode: string
    county?: string
    latitude?: number | null
    longitude?: number | null
    lotSize?: number | null
    livingArea?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    propertyType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceRecords?: SourceRecordCreateNestedManyWithoutPropertyInput
    ownershipEvents?: OwnershipEventCreateNestedManyWithoutPropertyInput
    sales?: SaleCreateNestedManyWithoutPropertyInput
    permits?: PermitCreateNestedManyWithoutPropertyInput
    workEvents?: WorkEventCreateNestedManyWithoutPropertyInput
    rentalSignals?: RentalSignalCreateNestedManyWithoutPropertyInput
    insuranceClaims?: InsuranceClaimCreateNestedManyWithoutPropertyInput
    reports?: ReportCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutNotificationsInput = {
    id?: string
    apn?: string | null
    address: string
    addressLine2?: string | null
    city: string
    state?: string
    zipCode: string
    county?: string
    latitude?: number | null
    longitude?: number | null
    lotSize?: number | null
    livingArea?: number | null
    bedrooms?: number | null
    bathrooms?: number | null
    yearBuilt?: number | null
    propertyType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceRecords?: SourceRecordUncheckedCreateNestedManyWithoutPropertyInput
    ownershipEvents?: OwnershipEventUncheckedCreateNestedManyWithoutPropertyInput
    sales?: SaleUncheckedCreateNestedManyWithoutPropertyInput
    permits?: PermitUncheckedCreateNestedManyWithoutPropertyInput
    workEvents?: WorkEventUncheckedCreateNestedManyWithoutPropertyInput
    rentalSignals?: RentalSignalUncheckedCreateNestedManyWithoutPropertyInput
    insuranceClaims?: InsuranceClaimUncheckedCreateNestedManyWithoutPropertyInput
    reports?: ReportUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutNotificationsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutNotificationsInput, PropertyUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyUpsertWithoutNotificationsInput = {
    update: XOR<PropertyUpdateWithoutNotificationsInput, PropertyUncheckedUpdateWithoutNotificationsInput>
    create: XOR<PropertyCreateWithoutNotificationsInput, PropertyUncheckedCreateWithoutNotificationsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutNotificationsInput, PropertyUncheckedUpdateWithoutNotificationsInput>
  }

  export type PropertyUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    apn?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    livingArea?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceRecords?: SourceRecordUpdateManyWithoutPropertyNestedInput
    ownershipEvents?: OwnershipEventUpdateManyWithoutPropertyNestedInput
    sales?: SaleUpdateManyWithoutPropertyNestedInput
    permits?: PermitUpdateManyWithoutPropertyNestedInput
    workEvents?: WorkEventUpdateManyWithoutPropertyNestedInput
    rentalSignals?: RentalSignalUpdateManyWithoutPropertyNestedInput
    insuranceClaims?: InsuranceClaimUpdateManyWithoutPropertyNestedInput
    reports?: ReportUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    apn?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    addressLine2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    zipCode?: StringFieldUpdateOperationsInput | string
    county?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lotSize?: NullableFloatFieldUpdateOperationsInput | number | null
    livingArea?: NullableFloatFieldUpdateOperationsInput | number | null
    bedrooms?: NullableIntFieldUpdateOperationsInput | number | null
    bathrooms?: NullableFloatFieldUpdateOperationsInput | number | null
    yearBuilt?: NullableIntFieldUpdateOperationsInput | number | null
    propertyType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceRecords?: SourceRecordUncheckedUpdateManyWithoutPropertyNestedInput
    ownershipEvents?: OwnershipEventUncheckedUpdateManyWithoutPropertyNestedInput
    sales?: SaleUncheckedUpdateManyWithoutPropertyNestedInput
    permits?: PermitUncheckedUpdateManyWithoutPropertyNestedInput
    workEvents?: WorkEventUncheckedUpdateManyWithoutPropertyNestedInput
    rentalSignals?: RentalSignalUncheckedUpdateManyWithoutPropertyNestedInput
    insuranceClaims?: InsuranceClaimUncheckedUpdateManyWithoutPropertyNestedInput
    reports?: ReportUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type SourceRecordCreateManyPropertyInput = {
    id?: string
    source: string
    sourceId?: string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    ingestedAt?: Date | string
    version?: number
  }

  export type OwnershipEventCreateManyPropertyInput = {
    id?: string
    ownerName: string
    ownerType?: string | null
    fromDate: Date | string
    toDate?: Date | string | null
    isCurrent?: boolean
    documentRef?: string | null
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SaleCreateManyPropertyInput = {
    id?: string
    saleDate: Date | string
    salePrice: number
    saleType?: string | null
    buyerName?: string | null
    sellerName?: string | null
    documentRef?: string | null
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PermitCreateManyPropertyInput = {
    id?: string
    permitNumber: string
    permitType: string
    status: string
    issuedDate?: Date | string | null
    completedDate?: Date | string | null
    expirationDate?: Date | string | null
    description?: string | null
    contractorName?: string | null
    jurisdiction: string
    source: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkEventCreateManyPropertyInput = {
    id?: string
    contractorId?: string | null
    workType: string
    description?: string | null
    workDate: Date | string
    cost?: number | null
    invoiceNumber?: string | null
    documentUrl?: string | null
    verificationStatus?: string
    warrantyPeriodMonths?: number | null
    warrantyExpirationDate?: Date | string | null
    warrantyType?: string | null
    warrantyDetails?: string | null
    insuranceClaimId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RentalSignalCreateManyPropertyInput = {
    id?: string
    source: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    confidence?: number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InsuranceClaimCreateManyPropertyInput = {
    id?: string
    claimType: string
    claimDate: Date | string
    amount?: number | null
    status?: string | null
    submittedBy?: string | null
    verificationStatus?: string
    documentUrl?: string | null
    contractorId?: string | null
    workDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCreateManyPropertyInput = {
    id?: string
    version?: number
    generatedAt?: Date | string
    snapshot: JsonNullValueInput | InputJsonValue
    shareToken?: string | null
    createdAt?: Date | string
  }

  export type NotificationSubscriptionCreateManyPropertyInput = {
    id?: string
    userId: string
    eventType: string
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SourceRecordUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    ingestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
  }

  export type SourceRecordUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    ingestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
  }

  export type SourceRecordUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    sourceId?: NullableStringFieldUpdateOperationsInput | string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    ingestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    version?: IntFieldUpdateOperationsInput | number
  }

  export type OwnershipEventUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerName?: StringFieldUpdateOperationsInput | string
    ownerType?: NullableStringFieldUpdateOperationsInput | string | null
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    documentRef?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnershipEventUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerName?: StringFieldUpdateOperationsInput | string
    ownerType?: NullableStringFieldUpdateOperationsInput | string | null
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    documentRef?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OwnershipEventUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerName?: StringFieldUpdateOperationsInput | string
    ownerType?: NullableStringFieldUpdateOperationsInput | string | null
    fromDate?: DateTimeFieldUpdateOperationsInput | Date | string
    toDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isCurrent?: BoolFieldUpdateOperationsInput | boolean
    documentRef?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salePrice?: FloatFieldUpdateOperationsInput | number
    saleType?: NullableStringFieldUpdateOperationsInput | string | null
    buyerName?: NullableStringFieldUpdateOperationsInput | string | null
    sellerName?: NullableStringFieldUpdateOperationsInput | string | null
    documentRef?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salePrice?: FloatFieldUpdateOperationsInput | number
    saleType?: NullableStringFieldUpdateOperationsInput | string | null
    buyerName?: NullableStringFieldUpdateOperationsInput | string | null
    sellerName?: NullableStringFieldUpdateOperationsInput | string | null
    documentRef?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    salePrice?: FloatFieldUpdateOperationsInput | number
    saleType?: NullableStringFieldUpdateOperationsInput | string | null
    buyerName?: NullableStringFieldUpdateOperationsInput | string | null
    sellerName?: NullableStringFieldUpdateOperationsInput | string | null
    documentRef?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermitUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    permitNumber?: StringFieldUpdateOperationsInput | string
    permitType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contractorName?: NullableStringFieldUpdateOperationsInput | string | null
    jurisdiction?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermitUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    permitNumber?: StringFieldUpdateOperationsInput | string
    permitType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contractorName?: NullableStringFieldUpdateOperationsInput | string | null
    jurisdiction?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermitUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    permitNumber?: StringFieldUpdateOperationsInput | string
    permitType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    contractorName?: NullableStringFieldUpdateOperationsInput | string | null
    jurisdiction?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkEventUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    workDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    warrantyPeriodMonths?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyExpirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyType?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyDetails?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractor?: ContractorCompanyUpdateOneWithoutWorkEventsNestedInput
    insuranceClaim?: InsuranceClaimUpdateOneWithoutWorkEventsNestedInput
  }

  export type WorkEventUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractorId?: NullableStringFieldUpdateOperationsInput | string | null
    workType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    workDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    warrantyPeriodMonths?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyExpirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyType?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyDetails?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceClaimId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkEventUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractorId?: NullableStringFieldUpdateOperationsInput | string | null
    workType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    workDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    warrantyPeriodMonths?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyExpirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyType?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyDetails?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceClaimId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RentalSignalUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confidence?: FloatFieldUpdateOperationsInput | number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RentalSignalUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confidence?: FloatFieldUpdateOperationsInput | number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RentalSignalUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confidence?: FloatFieldUpdateOperationsInput | number
    evidence?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsuranceClaimUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    claimType?: StringFieldUpdateOperationsInput | string
    claimDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractor?: ContractorCompanyUpdateOneWithoutInsuranceClaimsNestedInput
    workEvents?: WorkEventUpdateManyWithoutInsuranceClaimNestedInput
  }

  export type InsuranceClaimUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    claimType?: StringFieldUpdateOperationsInput | string
    claimDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contractorId?: NullableStringFieldUpdateOperationsInput | string | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workEvents?: WorkEventUncheckedUpdateManyWithoutInsuranceClaimNestedInput
  }

  export type InsuranceClaimUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    claimType?: StringFieldUpdateOperationsInput | string
    claimDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    contractorId?: NullableStringFieldUpdateOperationsInput | string | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshot?: JsonNullValueInput | InputJsonValue
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshot?: JsonNullValueInput | InputJsonValue
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshot?: JsonNullValueInput | InputJsonValue
    shareToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSubscriptionUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationSubscriptionUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSubscriptionUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkEventCreateManyContractorInput = {
    id?: string
    propertyId: string
    workType: string
    description?: string | null
    workDate: Date | string
    cost?: number | null
    invoiceNumber?: string | null
    documentUrl?: string | null
    verificationStatus?: string
    warrantyPeriodMonths?: number | null
    warrantyExpirationDate?: Date | string | null
    warrantyType?: string | null
    warrantyDetails?: string | null
    insuranceClaimId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InsuranceClaimCreateManyContractorInput = {
    id?: string
    propertyId: string
    claimType: string
    claimDate: Date | string
    amount?: number | null
    status?: string | null
    submittedBy?: string | null
    verificationStatus?: string
    documentUrl?: string | null
    workDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkEventUpdateWithoutContractorInput = {
    id?: StringFieldUpdateOperationsInput | string
    workType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    workDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    warrantyPeriodMonths?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyExpirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyType?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyDetails?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutWorkEventsNestedInput
    insuranceClaim?: InsuranceClaimUpdateOneWithoutWorkEventsNestedInput
  }

  export type WorkEventUncheckedUpdateWithoutContractorInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    workType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    workDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    warrantyPeriodMonths?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyExpirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyType?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyDetails?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceClaimId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkEventUncheckedUpdateManyWithoutContractorInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    workType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    workDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    warrantyPeriodMonths?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyExpirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyType?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyDetails?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceClaimId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsuranceClaimUpdateWithoutContractorInput = {
    id?: StringFieldUpdateOperationsInput | string
    claimType?: StringFieldUpdateOperationsInput | string
    claimDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutInsuranceClaimsNestedInput
    workEvents?: WorkEventUpdateManyWithoutInsuranceClaimNestedInput
  }

  export type InsuranceClaimUncheckedUpdateWithoutContractorInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    claimType?: StringFieldUpdateOperationsInput | string
    claimDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workEvents?: WorkEventUncheckedUpdateManyWithoutInsuranceClaimNestedInput
  }

  export type InsuranceClaimUncheckedUpdateManyWithoutContractorInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    claimType?: StringFieldUpdateOperationsInput | string
    claimDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    submittedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkEventCreateManyInsuranceClaimInput = {
    id?: string
    propertyId: string
    contractorId?: string | null
    workType: string
    description?: string | null
    workDate: Date | string
    cost?: number | null
    invoiceNumber?: string | null
    documentUrl?: string | null
    verificationStatus?: string
    warrantyPeriodMonths?: number | null
    warrantyExpirationDate?: Date | string | null
    warrantyType?: string | null
    warrantyDetails?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkEventUpdateWithoutInsuranceClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    workType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    workDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    warrantyPeriodMonths?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyExpirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyType?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyDetails?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutWorkEventsNestedInput
    contractor?: ContractorCompanyUpdateOneWithoutWorkEventsNestedInput
  }

  export type WorkEventUncheckedUpdateWithoutInsuranceClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    contractorId?: NullableStringFieldUpdateOperationsInput | string | null
    workType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    workDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    warrantyPeriodMonths?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyExpirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyType?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyDetails?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkEventUncheckedUpdateManyWithoutInsuranceClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    contractorId?: NullableStringFieldUpdateOperationsInput | string | null
    workType?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    workDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cost?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiceNumber?: NullableStringFieldUpdateOperationsInput | string | null
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    warrantyPeriodMonths?: NullableIntFieldUpdateOperationsInput | number | null
    warrantyExpirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyType?: NullableStringFieldUpdateOperationsInput | string | null
    warrantyDetails?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSubscriptionCreateManyUserInput = {
    id?: string
    propertyId: string
    eventType: string
    enabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationSubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationSubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationSubscriptionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    enabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}